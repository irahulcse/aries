Solving,use crate::core::literals::{Disjunction, Lits};
Solving,use crate::core::state::{Domains, OptDomain};
Solving,use crate::core::{cst_int_to_long, IntCst, Lit, SignedVar, VarRef};
Solving,use crate::model::lang::alternative::NFAlternative;
Solving,use crate::model::lang::linear::NFLinearLeq;
Solving,use crate::model::lang::max::NFEqMax;
Solving,use crate::model::lang::mul::{EqMul, NFEqVarMulLit};
Solving,use crate::model::lang::ValidityScope;
Solving,use crate::model::{Label, Model};
Solving,use std::fmt::{Debug, Formatter};
Solving,use std::ops::Not;
Solving,fn decompose(self, model: &mut Model<Lbl>) -> ReifExpr;
Solving,let prez = |var| assignment.present(var).unwrap();
Solving,};
Solving,let lvalue = |lit: Lit| assignment.value(lit).unwrap();
Solving,let sprez = |svar: SignedVar| prez(svar.variable());
Solving,};
Solving,return Some(true);
Solving,return Some(false);
Solving,assert!(lits.iter().any(|l| !prez(l.variable())));
Solving,let lin = lin.simplify();
Solving,let mut sum = 0;
Solving,debug_assert!(prez(term.var));
Solving,sum += cst_int_to_long(value(term.var)) * cst_int_to_long(term.factor);
Solving,let main_value = value(*main);
Solving,let mut present_alternatives = alternatives.iter().filter(|a| prez(a.var));
Solving,let left_value = svalue(*lhs);
Solving,let right_value = rhs.iter().filter(|e| sprez(e.var)).map(|e| svalue(e.var) + e.cst).max();
Solving,let lit_value: IntCst = lvalue(*lit).into();
Solving,type Output = Self;
Solving,let mut lits = lits.into_lits();
Solving,lits.iter_mut().for_each(|l| *l = !*l);
Solving,lits.iter_mut().for_each(|l| *l = !*l);
Solving,assert_ne!(b, VarRef::ZERO);
Solving,assert_ne!(a, VarRef::ZERO);
Solving,type Output = Self;
Solving,use crate::{core::Lit, reif::ReifExpr};
Solving,use crate::backtrack::{Backtrack, DecLvl};
Solving,use crate::collections::set::IterableRefSet;
Solving,use crate::core::literals::{Disjunction, Lits};
Solving,use crate::core::state::*;
Solving,use crate::core::*;
Solving,use crate::model::extensions::{AssignmentExt, DisjunctionExt, SavedAssignment, Shaped};
Solving,use crate::model::lang::IAtom;
Solving,use crate::model::{Constraint, Label, Model, ModelShape};
Solving,use crate::reasoners::cp::max::{AtLeastOneGeq, MaxElem};
Solving,use crate::reasoners::{Contradiction, ReasonerId, Reasoners};
Solving,use crate::reif::{DifferenceExpression, ReifExpr, Reifiable};
Solving,use crate::solver::musmcs::marco::{MapSolverMode, Marco, SubsetSolverOptiMode};
Solving,use crate::solver::musmcs::MusMcsEnumerator;
Solving,use crate::solver::parallel::signals::{InputSignal, InputStream, SolverOutput, Synchro};
Solving,use crate::solver::search::{default_brancher, Decision, SearchControl};
Solving,use crate::solver::stats::Stats;
Solving,use crate::utils::cpu_time::StartCycleCount;
Solving,use crossbeam_channel::Sender;
Solving,use env_param::EnvParam;
Solving,use itertools::Itertools;
Solving,use std::fmt::Formatter;
Solving,use std::sync::Arc;
Solving,use std::time::Instant;
Solving,use tracing::instrument;
Solving,static LOG_DECISIONS: EnvParam<bool> = EnvParam::new("ARIES_LOG_DECISIONS", "false");
Solving,static STATS_AT_SOLUTION: EnvParam<bool> = EnvParam::new("ARIES_STATS_AT_SOLUTION", "false");
Solving,static DYNAMIC_EDGES: EnvParam<bool> = EnvParam::new("ARIES_DYNAMIC_EDGES", "true");
Solving,print!("[{:?}] ", std::thread::current().id());
Solving,println!($($arg)+);
Solving,pub type UnsatCore = Explanation;
Solving,self.sync.set_output(output);
Solving,assert_eq!(self.decision_level, DecLvl::ROOT);
Solving,self.model.enforce(bool_expr, scope);
Solving,assert_eq!(self.decision_level, DecLvl::ROOT);
Solving,self.model.enforce_all(bools, scope);
Solving,let Constraint::HalfReified(expr, value) = constraint;
Solving,let value = *value;
Solving,assert_eq!(self.model.state.current_decision_level(), DecLvl::ROOT);
Solving,let scope = self.model.presence_literal(value.variable());
Solving,let expr_scope = self.model.presence_literal(lit.variable());
Solving,assert!(self.model.state.implies(scope, expr_scope), "Incompatible scopes");
Solving,let rhs = diff.a;
Solving,let rhs_add = diff.ub;
Solving,let lhs = diff.b;
Solving,.add_half_reified_edge(value, rhs, lhs, rhs_add, &self.model.state);
Solving,let lit = self.reasoners.eq.add_edge(*a, *b, &mut self.model);
Solving,let lit = !self.reasoners.eq.add_edge(*a, *b, &mut self.model);
Solving,let (lb, ub) = self.model.state.bounds(*a);
Solving,};
Solving,let lit = !self.reasoners.eq.add_val_edge(*a, *b, &mut self.model);
Solving,let mut clause = Lits::with_capacity(disjuncts.len() + 1);
Solving,clause.push(!value);
Solving,clause.extend_from_slice(disjuncts);
Solving,self.add_clause(clause, scope)?;
Solving,self.add_clause([lit], scope)?;
Solving,self.add_clause([!value, lit], scope)?;
Solving,let lin = lin.simplify();
Solving,))?;
Solving,let elem = lin.sum.first().unwrap();
Solving,debug_assert_ne!(elem.factor, 0);
Solving,};
Solving,let ub = lin.upper_bound / elem.factor.abs();
Solving,let lit = svar.leq(ub);
Solving,self.post_constraint(&Constraint::HalfReified(ReifExpr::Lit(lit), value))?;
Solving,let fst = lin.sum.first().unwrap();
Solving,let snd = lin.sum.get(1).unwrap();
Solving,debug_assert_ne!(fst.factor, 0);
Solving,debug_assert_ne!(snd.factor, 0);
Solving,let b = if fst.factor > 0 { fst } else { snd };
Solving,let a = if fst.factor < 0 { fst } else { snd };
Solving,let diff = DifferenceExpression::new(b.var, a.var, lin.upper_bound / b.factor);
Solving,self.post_constraint(&Constraint::HalfReified(ReifExpr::MaxDiff(diff), value))?;
Solving,};
Solving,.add_half_reif_linear_constraint(&lin, value, &self.model.state);
Solving,let permutations = [[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]];
Solving,let x = -lin.sum[xi];
Solving,let y = lin.sum[yi];
Solving,let d = -lin.sum[di];
Solving,continue;
Solving,continue;
Solving,continue;
Solving,let src = x.var;
Solving,let tgt = y.var;
Solving,};
Solving,let prez = |v: VarRef| self.model.state.presence_literal(v);
Solving,);
Solving,assert_eq!(prez(a.main), prez(value.variable()));
Solving,let scope = prez(a.main);
Solving,let presences = a.alternatives.iter().map(|alt| prez(alt.var)).collect_vec();
Solving,self.add_clause(&presences, scope)?;
Solving,self.add_clause([!p1, !p2], scope)?;
Solving,let alt_scope = self.model.state.presence_literal(alt.var);
Solving,debug_assert!(self.model.state.implies(alt_scope, scope));
Solving,let alt_value = self.model.get_tautology_of_scope(alt_scope);
Solving,))?;
Solving,))?;
Solving,let prez = |v: VarRef| self.model.state.presence_literal(v);
Solving,});
Solving,});
Solving,let prez = |v: SignedVar| self.model.state.presence(v);
Solving,assert!(self.model.entails(value), "Unsupported half reified eqmax constraints.");
Solving,assert_eq!(prez(a.lhs), prez(value.variable().into()));
Solving,let scope = prez(a.lhs);
Solving,let presences = a.rhs.iter().map(|alt| prez(alt.var)).collect_vec();
Solving,self.add_clause(&presences, scope)?;
Solving,let item_scope = self.model.state.presence(item.var);
Solving,debug_assert!(self.model.state.implies(item_scope, scope));
Solving,let alt_value = self.model.get_tautology_of_scope(item_scope);
Solving,assert!(a.lhs.is_plus());
Solving,))?;
Solving,assert!(a.lhs.is_minus());
Solving,let x = item.var.variable();
Solving,let y = a.lhs.variable();
Solving,))?;
Solving,let prez = |v: SignedVar| self.model.state.presence(v);
Solving,});
Solving,.add_half_reified_mul_constraint(eq_mul, value, &self.model.state);
Solving,);
Solving,self.reasoners.cp.add_eq_var_mul_lit_constraint(mul);
Solving,assert_eq!(self.current_decision_level(), DecLvl::ROOT);
Solving,let mut clause: Disjunction = clause.into();
Solving,clause.retain(|l| !self.model.entails(!l));
Solving,let (propagatable, scope) = self.scoped_disjunction(clause, scope);
Solving,return self.model.state.set(!scope, Cause::Encoding).map(|_| ());
Solving,self.reasoners.sat.add_clause_scoped(propagatable.literals(), scope);
Solving,let prez = |l: Lit| self.model.presence_literal(l.variable());
Solving,let disjuncts = disjuncts.into();
Solving,return (disjuncts, scope);
Solving,return (Disjunction::from([!scope]), Lit::TRUE);
Solving,let mut disjuncts = disjuncts.into_lits();
Solving,disjuncts.push(!scope);
Solving,let start_time = Instant::now();
Solving,let start_cycles = StartCycleCount::now();
Solving,let c = &self.model.shape.constraints[self.next_unposted_constraint];
Solving,let size_before = self.model.shape.constraints.len();
Solving,};
Solving,self.post_constraint(c)?;
Solving,);
Solving,self.next_unposted_constraint += 1;
Solving,self.stats.init_time += start_time.elapsed();
Solving,self.stats.init_cycles += start_cycles.elapsed();
Solving,return Ok(None);
Solving,let mut valid_assignments = Vec::with_capacity(64);
Solving,return Ok(valid_assignments);
Solving,let assignment = variables.iter().map(|var| domains.lb(*var)).collect();
Solving,valid_assignments.push(assignment);
Solving,};
Solving,self.enumerate_with(variables, on_new_solution)?;
Solving,assert_eq!(self.decision_level, DecLvl::ROOT);
Solving,);
Solving,return Ok(false);
Solving,let mut sat = false;
Solving,sat = true;
Solving,let solution = Arc::new(self.model.state.clone());
Solving,let mut clause = Vec::with_capacity(variables.len() * 2);
Solving,let (val, _) = solution.bounds(*v);
Solving,clause.push(Lit::lt(*v, val));
Solving,clause.push(Lit::gt(*v, val));
Solving,on_new_solution(&solution);
Solving,self.restore(dl);
Solving,self.reasoners.sat.add_clause(&clause);
Solving,return Ok(sat);
Solving,debug_assert!(conflict.is_empty());
Solving,return Err(Explanation::new());
Solving,};
Solving,let mut successfully_pushed = vec![];
Solving,self.reset_search();
Solving,self.restore_last();
Solving,.extract_unsat_core_after_conflict(conflict, &mut self.reasoners);
Solving,self.brancher.import_vars(&self.model);
Solving,assert_eq!(self.decision_level, DecLvl::ROOT);
Solving,debug_assert!(conflict.is_empty());
Solving,return Ok(Err(Explanation::new()));
Solving,};
Solving,return Ok(Err(unsat_core));
Solving,.extract_unsat_core_after_conflict(conflict, &mut self.reasoners);
Solving,assert!(self.all_constraints_posted());
Solving,self.brancher.import_vars(&self.model);
Solving,let start_time = Instant::now();
Solving,let start_cycles = StartCycleCount::now();
Solving,self.stats.solve_time += start_time.elapsed();
Solving,self.stats.solve_cycles += start_cycles.elapsed();
Solving,return Ok(SearchResult::Unsat(conflict));
Solving,let mut requires_new_propagation = false;
Solving,self.stats.solve_time += start_time.elapsed();
Solving,self.stats.solve_cycles += start_cycles.elapsed();
Solving,return Err(Exit::Interrupted);
Solving,self.reasoners.sat.add_forgettable_clause(cl.literals());
Solving,requires_new_propagation = true;
Solving,self.stats.solve_time += start_time.elapsed();
Solving,self.stats.solve_cycles += start_cycles.elapsed();
Solving,return Ok(SearchResult::ExternalSolution(assignment));
Solving,continue;
Solving,// println!("Decision: {}", self.model.fmt(lit));
Solving,self.decide(lit);
Solving,self.reset_search();
Solving,self.stats.add_restart();
Solving,log_dec!("=> SOLUTION");
Solving,self.stats.solve_time += start_time.elapsed();
Solving,self.stats.solve_cycles += start_cycles.elapsed();
Solving,self.model.shape.validate(&self.model.state).unwrap();
Solving,});
Solving,return Ok(SearchResult::AtSolution);
Solving,assert_eq!(self.decision_level, DecLvl::ROOT);
Solving,assert_eq!(self.last_assumption_level, DecLvl::ROOT);
Solving,let mut best = None;
Solving,self.brancher.new_assignment_found(objective_value, sol.clone());
Solving,return Ok(None);
Solving,let sol = Arc::new(self.model.state.clone());
Solving,self.sync.notify_solution_found(sol.clone());
Solving,let objective_value = sol.var_domain(objective).lb;
Solving,println!("*********  New sol: {objective_value} *********");
Solving,self.print_stats();
Solving,on_new_solution(objective_value, &sol);
Solving,};
Solving,let objective_value = sol.var_domain(objective).lb;
Solving,};
Solving,self.brancher.new_assignment_found(objective_value, sol.clone());
Solving,best = Some((objective_value, sol));
Solving,};
Solving,self.reset_search();
Solving,assert!(self.all_constraints_posted());
Solving,self.save_state();
Solving,);
Solving,let res = self.model.state.decide(decision);
Solving,assert_eq!(res, Ok(true), "Decision did not result in a valid modification.");
Solving,assert!(self.all_constraints_posted());
Solving,assert_eq!(self.last_assumption_level, self.decision_level);
Solving,);
Solving,self.save_state();
Solving,self.last_assumption_level = self.decision_level;
Solving,debug_assert_eq!(self.model.state.value_of_clause(clause.iter().copied()), Some(false));
Solving,let last_assumption_dec_lvl = self.last_assumption_level;
Solving,let mut max = last_assumption_dec_lvl;
Solving,let mut max_next = last_assumption_dec_lvl;
Solving,debug_assert!(self.model.state.entails(!lit));
Solving,let dl = self.model.state.trail().decision_level(ev);
Solving,max_next = max;
Solving,max = dl;
Solving,max_next = dl;
Solving,debug_assert!(max >= last_assumption_dec_lvl);
Solving,debug_assert!(max_next >= last_assumption_dec_lvl);
Solving,// println!("conflict ({}) :", expl.literals().len());
Solving,//         print!("  > {}", self.model.fmt(l));
Solving,//         print!("    {}", self.model.fmt(l));
Solving,//     // let prez = self.model.state.presence(l.variable());
Solving,//     //     .collect();
Solving,//     // print!("  / {}   <<<<   ", self.model.fmt(prez));
Solving,//     // print!("  [");
Solving,//     //     print!("  & {}", self.model.fmt(prez));
Solving,//     // println!("]");
Solving,// println!();
Solving,self.brancher.conflict(expl, &self.model, &mut self.reasoners, dl);
Solving,self.restore(dl);
Solving,// println!("conflict:");
Solving,//     println!("  {l:?}  {}  {:?}", self.model.fmt(l), self.model.value_of_literal(l));
Solving,debug_assert_eq!(self.model.state.value_of_clause(&expl.clause), None);
Solving,self.reasoners.sat.add_learnt_clause(expl.clause.literals());
Solving,);
Solving,self.sync.notify_learnt(&conflict.clause);
Solving,return Err(conflict);
Solving,let mut working_lbd_compute = IterableRefSet::new();
Solving,working_lbd_compute.insert(lvl);
Solving,let lvl = model.entailing_level(!l);
Solving,working_lbd_compute.insert(lvl);
Solving,// eprintln!("LBD: {}", working_lbd_compute.len());
Solving,assert_eq!(self.current_decision_level(), DecLvl::ROOT);
Solving,return Err(Conflict::contradiction());
Solving,let global_start = StartCycleCount::now();
Solving,let num_events_at_start = self.model.state.num_events();
Solving,);
Solving,let trail_size = self.model.state.trail().len() as u64;
Solving,let theory_propagation_start = StartCycleCount::now();
Solving,self.stats[i].propagation_loops += 1;
Solving,let th = self.reasoners.reasoner_mut(i);
Solving,let num_dom_updates = self.model.state.trail().len() as u64 - trail_size;
Solving,self.stats[i].dom_updates += num_dom_updates;
Solving,self.stats.num_dom_updates += num_dom_updates;
Solving,self.brancher.pre_conflict_analysis(&self.model);
Solving,};
Solving,let lbd = self.lbd(&clause, &self.model.state);
Solving,.add_conflict(self.current_decision_level(), clause.len(), lbd);
Solving,self.stats[i].conflicts += 1;
Solving,self.stats.propagation_time += global_start.elapsed();
Solving,self.stats[i].propagation_time += theory_propagation_start.elapsed();
Solving,return Err(clause);
Solving,self.stats[i].propagation_time += theory_propagation_start.elapsed();
Solving,let num_dom_updates = self.model.state.trail().len() as u64 - trail_size;
Solving,self.stats[i].dom_updates += num_dom_updates;
Solving,self.stats.num_dom_updates += num_dom_updates;
Solving,break;
Solving,self.stats.propagation_time += global_start.elapsed();
Solving,println!("{}", self.stats);
Solving,println!("====== {i} =====");
Solving,th.print_stats();
Solving,self.restore(self.last_assumption_level);
Solving,self.brancher.pre_save_state(&self.model);
Solving,self.decision_level += 1;
Solving,let n = self.decision_level;
Solving,assert_eq!(self.model.save_state(), n);
Solving,assert_eq!(self.brancher.save_state(), n);
Solving,let th = self.reasoners.reasoner_mut(*w);
Solving,assert_eq!(th.save_state(), n);
Solving,let n = self.decision_level.to_int();
Solving,assert_eq!(self.model.num_saved(), n);
Solving,assert_eq!(self.brancher.num_saved(), n);
Solving,assert_eq!(th.num_saved(), n);
Solving,});
Solving,assert!(self.decision_level > DecLvl::ROOT);
Solving,self.restore(self.decision_level - 1);
Solving,self.decision_level = saved_id;
Solving,self.last_assumption_level = saved_id;
Solving,self.model.restore(saved_id);
Solving,self.brancher.restore(saved_id);
Solving,let th = self.reasoners.reasoner_mut(*w);
Solving,th.restore(saved_id);
Solving,debug_assert_eq!(self.current_decision_level(), saved_id);
Solving,use crate::core::literals::Disjunction;
Solving,use crate::core::Lit;
Solving,type Model = crate::model::Model<&'static str>;
Solving,type Solver = crate::solver::Solver<&'static str>;
Solving,let mut m = Model::new();
Solving,let px = m.new_presence_variable(Lit::TRUE, "px").true_lit();
Solving,let x1 = m.new_optional_bvar(px, "x1").true_lit();
Solving,let x2 = m.new_optional_bvar(px, "x2").true_lit();
Solving,let py = m.new_presence_variable(Lit::TRUE, "py").true_lit();
Solving,// let y1 = m.new_optional_bvar(py, "y1").true_lit();
Solving,// let y2 = m.new_optional_bvar(py, "y2").true_lit();
Solving,let pxy = m.get_conjunctive_scope(&[px, py]);
Solving,let xy1 = m.new_optional_bvar(pxy, "xy1").true_lit();
Solving,// let xy2 = m.new_optional_bvar(pxy, "xy2").true_lit();
Solving,let s = &Solver::new(m);
Solving,let clause = clause.into();
Solving,let result = s.scoped_disjunction(clause, scope);
Solving,let expected = expected.into();
Solving,assert_eq!(result, (expected, expected_scope));
Solving,check(s, px, [x1], [x1], px);
Solving,// check(s, T, [!px, x1], [x1]);
Solving,check(s, px, [x1, x2], [x1, x2], px);
Solving,// check(s, T, [!px, x1, x2], [x1, x2]);
Solving,check(s, py, [xy1], [xy1], py);
Solving,check(s, pxy, [xy1], [xy1], pxy);
Solving,check(s, pxy, [x1], [!pxy, x1], Lit::TRUE);
Solving,// check(s, T, [!pxy, xy1], [xy1]);
Solving,// check(s, T, [!px, !py, xy1], [xy1]);
Solving,use std::collections::{BTreeMap, BTreeSet};
Solving,use std::sync::Arc;
Solving,use crate::backtrack::Backtrack;
Solving,use crate::core::{Lit, INT_CST_MAX};
Solving,use crate::model::extensions::SavedAssignment;
Solving,use crate::model::lang::{expr::or, linear::LinearSum, IAtom};
Solving,use crate::model::Model;
Solving,use crate::solver::search::activity::{ActivityBrancher, BranchingParams};
Solving,use crate::solver::Exit;
Solving,use itertools::Itertools;
Solving,type Solver = crate::solver::Solver<u8>;
Solving,type SolveFn = dyn Fn(&mut Solver) -> Result<Option<Arc<SavedAssignment>>, Exit>;
Solving,let mut solver = Solver::new(Model::new());
Solving,let mut literals_translate_in = BTreeMap::<Lit, Lit>::new();
Solving,let mut literals_translate_out = BTreeMap::<Lit, Lit>::new();
Solving,let lit_in = solver.model.state.new_var(0, 1).geq(1);
Solving,debug_assert!(!literals_translate_in.contains_key(&lit_out));
Solving,debug_assert!(!literals_translate_out.contains_key(&lit_in));
Solving,literals_translate_in.insert(lit_out, lit_in);
Solving,literals_translate_out.insert(lit_in, lit_out);
Solving,.collect::<BTreeSet<Lit>>();
Solving,});
Solving,solver.set_brancher(brancher);
Solving,});
Solving,solver.set_brancher(brancher);
Solving,let sum = LinearSum::of(literals.iter().map(|&l| IAtom::from(l.variable())).collect_vec());
Solving,let obj = IAtom::from(solver.model.state.new_var(0, INT_CST_MAX));
Solving,solver.model.enforce(sum.geq(obj), []);
Solving,let sum = LinearSum::of(literals.iter().map(|&l| IAtom::from(l.variable())).collect_vec());
Solving,let obj = IAtom::from(solver.model.state.new_var(0, INT_CST_MAX));
Solving,solver.model.enforce(sum.leq(obj), []);
Solving,};
Solving,let mut res = BTreeSet::new();
Solving,self.solver.reset();
Solving,self.solver.reset();
Solving,return res;
Solving,self.solver.reset();
Solving,return res;
Solving,continue;
Solving,res.insert(self.trout(lit));
Solving,res.insert(self.trout(lit.not()));
Solving,self.solver.reset();
Solving,);
Solving,self.solver.reset();
Solving,self.solver.reset();
Solving,let translated_mcs = mcs.iter().map(|&l| self.trin(l)).collect_vec();
Solving,self.known_singleton_mcses_out.insert(self.trout(singleton_mcs));
Solving,self.solver.enforce(or(translated_mcs), []);
Solving,let translated_mus_negs = mus.iter().map(|&l| self.trin(l).not()).collect_vec();
Solving,self.solver.enforce(or(translated_mus_negs), []);
Solving,mod mapsolver;
Solving,use crate::backtrack::{Backtrack, DecLvl};
Solving,use crate::core::Lit;
Solving,use crate::model::Label;
Solving,use crate::solver::{Exit, Solver};
Solving,use std::collections::BTreeSet;
Solving,use itertools::Itertools;
Solving,use crate::solver::musmcs::*;
Solving,use mapsolver::MapSolver;
Solving,pub use mapsolver::MapSolverMode;
Solving,type Item = MusMcs;
Solving,assert_eq!(main_solver.current_decision_level(), DecLvl::ROOT);
Solving,let map_solver = MapSolver::new(literals.clone(), map_solver_mode);
Solving,let (_, mcs) = self.grow(&sat_subset)?;
Solving,self.map_solver.block_down(&mcs);
Solving,self.debug_check_mcs_is_new_and_correct(&mcs);
Solving,return Ok(Some(MusMcs::Mcs(mcs)));
Solving,let mus = self.shrink(&unsat_subset)?;
Solving,self.map_solver.block_up(&mus);
Solving,self.debug_check_mus_is_new_and_correct(&mus);
Solving,return Ok(Some(MusMcs::Mus(mus)));
Solving,let res = self.main_solver.solve_with_assumptions(assumptions)?;
Solving,self.main_solver.reset();
Solving,};
Solving,};
Solving,let sat_subset_complement = self.literals.difference(sat_subset).copied().collect_vec();
Solving,let mut current = sat_subset.clone();
Solving,let mut skip = BTreeSet::<Lit>::new();
Solving,self.grow_optional_optimisation_lits_to_skip(&current, &mut skip);
Solving,continue;
Solving,current.insert(lit);
Solving,current = superset;
Solving,self.grow_optional_optimisation_lits_to_skip(&current, &mut skip);
Solving,current.remove(&lit);
Solving,let mss = current;
Solving,let mcs = self.literals.difference(&mss).copied().collect();
Solving,let mut current = unsat_subset.clone();
Solving,let mut skip = BTreeSet::<Lit>::new();
Solving,self.shrink_optional_optimisation_lits_to_skip(&current, &mut skip);
Solving,continue;
Solving,current.remove(&lit);
Solving,current = unsat_core;
Solving,self.shrink_optional_optimisation_lits_to_skip(&current, &mut skip);
Solving,current.insert(lit);
Solving,let mus = current;
Solving,let implications = self.map_solver.known_implications(current);
Solving,skip.clear();
Solving,);
Solving,.known_implications(&self.literals.difference(current).map(|&l| !l).collect());
Solving,skip.clear();
Solving,);
Solving,debug_assert!(self.debug_found_mcses.insert(mcs.clone()));
Solving,assert_eq!(self.main_solver.current_decision_level(), DecLvl::ROOT);
Solving,let mss = self.literals.difference(mcs).copied().collect_vec();
Solving,let mcs = mcs.iter().copied().collect_vec();
Solving,debug_assert!(self.main_solver.solve_with_assumptions(&mss).unwrap().is_ok());
Solving,self.main_solver.reset();
Solving,self.main_solver.reset();
Solving,debug_assert!(self.debug_found_muses.insert(mus.clone()));
Solving,assert_eq!(self.main_solver.current_decision_level(), DecLvl::ROOT);
Solving,let mus = mus.iter().copied().collect_vec();
Solving,debug_assert!(self.main_solver.solve_with_assumptions(&mus).unwrap().is_err());
Solving,self.main_solver.reset();
Solving,.is_ok());
Solving,self.main_solver.reset();
Solving,use std::collections::BTreeSet;
Solving,use itertools::Itertools;
Solving,use crate::core::Lit;
Solving,use crate::model::lang::expr::{geq, lt};
Solving,use crate::solver::musmcs::marco::mapsolver::MapSolverMode;
Solving,use crate::solver::musmcs::{Mcs, Mus, MusMcs};
Solving,type Lbl = &'static str;
Solving,type Model = crate::model::Model<Lbl>;
Solving,type Solver = crate::solver::Solver<Lbl>;
Solving,type Marco<'a> = crate::solver::musmcs::marco::Marco<'a, Lbl>;
Solving,let mut solver = Solver::new(Model::new());
Solving,let x0 = solver.model.new_ivar(0, 10, "x0");
Solving,let x1 = solver.model.new_ivar(0, 10, "x1");
Solving,let x2 = solver.model.new_ivar(0, 10, "x2");
Solving,let x3 = solver.model.new_ivar(0, 10, "x3");
Solving,let soft_constraints = [lt(x0, x1), lt(x1, x2), lt(x2, x0), lt(x0, x2), lt(x3, 5), geq(x3, 5)];
Solving,let soft_reiflits = soft_constraints.iter().map(|sc| solver.half_reify(*sc)).collect_vec();
Solving,);
Solving,let res = marco.collect_vec();
Solving,let mut res_muses = BTreeSet::<Mus>::new();
Solving,let mut res_mcses = BTreeSet::<Mcs>::new();
Solving,res_muses.insert(set);
Solving,res_mcses.insert(set);
Solving,let set = |elem: &[Lit]| BTreeSet::from_iter(elem.iter().copied());
Solving,]);
Solving,]);
Solving,assert_eq!(res_muses, expected_muses);
Solving,assert_eq!(res_mcses, expected_mcses);
Solving,pub mod marco;
Solving,use std::collections::BTreeSet;
Solving,use crate::{core::Lit, solver::musmcs::marco::Marco};
Solving,pub type MusMcsEnumerator<'a, Lbl> = Marco<'a, Lbl>;
Solving,pub type Mus = BTreeSet<Lit>;
Solving,pub type Mcs = BTreeSet<Lit>;
Solving,pub mod activity;
Solving,pub mod beta;
Solving,pub mod combinators;
Solving,pub mod conflicts;
Solving,pub mod lexical;
Solving,pub mod random;
Solving,use crate::backtrack::{Backtrack, DecLvl};
Solving,use crate::core::state::{Conflict, Explainer};
Solving,use crate::core::*;
Solving,use crate::model::extensions::SavedAssignment;
Solving,use crate::model::{Label, Model};
Solving,use crate::solver::stats::Stats;
Solving,pub type Brancher<L> = Box<dyn SearchControl<L> + Send>;
Solving,fn next_decision(&mut self, stats: &Stats, model: &Model<Lbl>) -> Option<Decision>;
Solving,fn clone_to_box(&self) -> Brancher<Lbl>;
Solving,use crate::core::literals::Disjunction;
Solving,use crate::model::extensions::SavedAssignment;
Solving,use crossbeam_channel::{Receiver, Sender};
Solving,use env_param::EnvParam;
Solving,use std::fmt::{Debug, Formatter};
Solving,use std::sync::atomic::{AtomicUsize, Ordering};
Solving,use std::sync::Arc;
Solving,static MAX_CLAUSE_SHARING_SIZE: EnvParam<usize> = EnvParam::new("ARIES_MAX_CLAUSE_SHARING_SIZE", "3");
Solving,static THREAD_ID_COUNTER: AtomicUsize = AtomicUsize::new(0);
Solving,pub type ThreadID = usize;
Solving,write!(f, "{:?} ", self.emitter)?;
Solving,let (snd, rcv) = crossbeam_channel::unbounded();
Solving,let len = clause.len();
Solving,let msg = OutputSignal::LearntClause(Arc::new(Disjunction::from(clause)));
Solving,let _ = output.send(SolverOutput { emitter: self.id, msg });
Solving,let msg = OutputSignal::SolutionFound(assignment);
Solving,let _ = output.send(SolverOutput { emitter: self.id, msg });
Solving,let mut res = Self::new();
Solving,use crate::core::IntCst;
Solving,use crate::core::Lit;
Solving,use crate::model::extensions::{AssignmentExt, SavedAssignment};
Solving,use crate::model::lang::IAtom;
Solving,use crate::model::Label;
Solving,use crate::solver::parallel::signals::{InputSignal, InputStream, OutputSignal, SolverOutput, ThreadID};
Solving,use crate::solver::{Exit, Solver, UnsatCore};
Solving,use crossbeam_channel::{select, Receiver, Sender};
Solving,use itertools::Itertools;
Solving,use std::sync::Arc;
Solving,use std::thread;
Solving,use std::time::{Duration, Instant};
Solving,pub type Solution = Arc<SavedAssignment>;
Solving,};
Solving,let mut replace = Worker::Running(stream);
Solving,std::mem::swap(&mut replace, self);
Solving,let _ = input.sender.send(InputSignal::Interrupt);
Solving,*self = Worker::Halting;
Solving,};
Solving,let mut s = base_solver.clone();
Solving,adapt(i, &mut s);
Solving,solver.solvers.push(Worker::Idle(s));
Solving,adapt(num_workers - 1, &mut base_solver);
Solving,solver.solvers.push(Worker::Idle(base_solver));
Solving,let (snd, rcv) = crossbeam_channel::unbounded();
Solving,solver.set_solver_output(snd.clone());
Solving,let mut res: Result<(), UnsatCore> = Ok(());
Solving,res = Err(unsat_core);
Solving,res = Err(unsat_core);
Solving,);
Solving,};
Solving,let objective = objective.into();
Solving,let objective = objective.into();
Solving,let mut previous_best = None;
Solving,let obj_value = ass.var_domain(objective).lb;
Solving,};
Solving,on_improved_solution(ass);
Solving,};
Solving,let solvers_output = self.plug_solvers_output();
Solving,let (result_snd, result_rcv) = crossbeam_channel::unbounded();
Solving,let output = run(&mut solver);
Solving,let answer = WorkerResult { id, output, solver };
Solving,let _ = result_snd.send(answer);
Solving,});
Solving,};
Solving,let mut solvers_inputs = Vec::with_capacity(self.solvers.len());
Solving,let solver = worker.extract().expect("A solver is already busy");
Solving,solvers_inputs.push(solver.input_stream());
Solving,spawn.clone()(i, solver, result_snd.clone());
Solving,let mut status = SolverStatus::Pending;
Solving,};
Solving,} = res.unwrap();
Solving,self.solvers[worker_id] = Worker::Idle(solver);
Solving,eprintln!("Unexpected interruption of solver.");
Solving,};
Solving,status = SolverStatus::Final(result);
Solving,self.share_among_solvers(&msg);
Solving,on_new_sol(assignment.clone());
Solving,status = SolverStatus::Intermediate(assignment);
Solving,};
Solving,status = SolverStatus::Final(result);
Solving,let _ = input.sender.send(InputSignal::LearnedClause(cl.clone()));
Solving,let _ = input.sender.send(InputSignal::SolutionFound(assignment.clone()));
Solving,println!("\n==== Worker {}", id + 1);
Solving,println!("Solver is running");
Solving,mod parallel_solver;
Solving,pub mod signals;
Solving,pub use parallel_solver::*;
Solving,pub mod musmcs;
Solving,pub mod parallel;
Solving,pub mod search;
Solving,pub mod stats;
Solving,mod solver_impl;
Solving,pub use solver_impl::*;
Solving,use crate::backtrack::DecLvl;
Solving,use crate::core::{IntCst, Lit};
Solving,use crate::reasoners::ReasonerId;
Solving,use crate::reasoners::REASONERS;
Solving,use crate::utils::cpu_time::*;
Solving,use env_param::EnvParam;
Solving,use std::collections::BTreeMap;
Solving,use std::fmt::{Display, Error, Formatter};
Solving,use std::ops::{Index, IndexMut};
Solving,use std::time::Duration;
Solving,static PRINT_RUNNING_STATS: EnvParam<bool> = EnvParam::new("ARIES_PRINT_RUNNING_STATS", "false");
Solving,let mut per_mod = BTreeMap::new();
Solving,per_mod.insert(*id, ModuleStat::default());
Solving,self.num_decisions += 1;
Solving,self.running.add_decision();
Solving,self.num_conflicts += 1;
Solving,self.running.add_conflict(size, depth, lbd);
Solving,self.print_running(" ");
Solving,self.num_solutions += 1;
Solving,self.best_cost = Some(cost);
Solving,self.print_running("*");
Solving,self.num_restarts += 1;
Solving,self.print_running("<");
Solving,];
Solving,print!("{first}");
Solving,print!(" {cell:>8}");
Solving,println!();
Solving,self.running.clear();
Solving,number(f, "<12,.3d", value)?;
Solving,label(f, "solutions")?;
Solving,writeln!(f, "{:<12}", self.num_solutions)?;
Solving,label(f, "restarts")?;
Solving,writeln!(f, "{:<12}", self.num_restarts)?;
Solving,label(f, "decisions")?;
Solving,val_throughput(f, self.num_decisions, &self.solve_time)?;
Solving,new_line(f)?;
Solving,label(f, "conflicts")?;
Solving,val_throughput(f, self.num_conflicts, &self.solve_time)?;
Solving,new_line(f)?;
Solving,label(f, "dom-updates")?;
Solving,val_throughput(f, self.num_dom_updates, &self.solve_time)?;
Solving,new_line(f)?;
Solving,writeln!(f, "================= ")?;
Solving,label(f, "Solvers")?;
Solving,write!(f, "{:>15}", format!("{i}"))?;
Solving,new_line(f)?;
Solving,label(f, "% CPU (propagation)")?;
Solving,let portion = format!("{}", ms.propagation_time / self.propagation_time);
Solving,write!(f, "{portion:>15}")?;
Solving,new_line(f)?;
Solving,label(f, "# propagation loops")?;
Solving,number(f, ">15,.3d", ms.propagation_loops)?;
Solving,new_line(f)?;
Solving,label(f, "# bound updates")?;
Solving,number(f, ">15,.3d", ms.dom_updates)?;
Solving,new_line(f)?;
Solving,label(f, "# conflicts")?;
Solving,number(f, ">15,.3d", ms.conflicts)?;
Solving,writeln!(f, "\n================= ")?;
Solving,label(f, "Init time")?;
Solving,writeln!(f, "{:.6} s", self.init_time.as_secs_f64())?;
Solving,label(f, "Solve time")?;
Solving,writeln!(f, "{:.6} s", self.solve_time.as_secs_f64())?;
Solving,self.decisions += 1;
Solving,self.count += 1;
Solving,self.size += size as u64;
Solving,self.lbd += lbd as u64;
Solving,self.search_space_left *= 1f64 - 1f64 / (2f64.powf(lbd as f64));
Solving,self.depth += depth.to_int() as u64;
Solving,let avg = (measure as f32) / (self.count as f32);
Solving,type Output = ModuleStat;
Solving,use crate::backtrack::{Backtrack, DecLvl, ObsTrailCursor, Trail};
Solving,use crate::collections::heap::IdxHeap;
Solving,use crate::collections::ref_store::{RefMap, RefVec};
Solving,use crate::core::literals::{LitSet, Watches};
Solving,use crate::core::state::{Conflict, Domains, Event, Explainer, IntDomain, Origin};
Solving,use crate::core::{IntCst, Lit, VarRef};
Solving,use crate::model::extensions::{AssignmentExt, SavedAssignment};
Solving,use crate::model::Model;
Solving,use crate::solver::search::{Decision, SearchControl};
Solving,use crate::solver::stats::Stats;
Solving,use crate::collections::set::IterableRefSet;
Solving,use hashbrown::HashSet;
Solving,use itertools::Itertools;
Solving,use rand::prelude::SmallRng;
Solving,use rand::{Rng, SeedableRng};
Solving,use std::collections::BTreeSet;
Solving,use std::fmt::Debug;
Solving,struct PreferredValueOrigin(u32);
Solving,const PHASE: PreferredValueOrigin = PreferredValueOrigin(0);
Solving,debug_assert!(solution_id > 0);
Solving,self.last_solution_id += 1;
Solving,.insert(var, (value, PreferredValueOrigin::from_solution(self.last_solution_id)));
Solving,let params = self;
Solving,params.heuristic = Heuristic::LearningRate;
Solving,params.active = ActiveLiterals::Reasoned;
Solving,params.heuristic = Heuristic::Vsids;
Solving,let period = x.strip_prefix("+rand").unwrap().parse().unwrap();
Solving,params.random_var_period = period;
Solving,let vars: BTreeSet<VarRef> = choices.iter().map(|l| l.variable()).collect();
Solving,debug_assert!(!self.heap.is_declared(var));
Solving,let prez = model.presence_literal(var);
Solving,self.heap.declare_variable(var, None);
Solving,self.presences.add_watch(var, prez);
Solving,self.heap.enqueue_variable(var);
Solving,self.process_events(model);
Solving,self.heap.enqueue_variable(var);
Solving,let v = x.affected_bound.variable();
Solving,self.conflicts.conflict_since_assignment.fill_with(v, || 0f64);
Solving,self.conflicts.assignment_time.insert(v, self.conflicts.num_conflicts);
Solving,self.conflicts.conflict_since_assignment[v] = 0f64;
Solving,self.conflicts.assignments.trail.push(v);
Solving,self.import_vars(model);
Solving,let decidable = |var: VarRef| !model.state.is_bound(var) && model.state.present(var) == Some(true);
Solving,.collect_vec();
Solving,let idx = self.rng.gen_range(0..vars.len());
Solving,self.heap.pop().unwrap();
Solving,break Some(v);
Solving,break None;
Solving,};
Solving,let IntDomain { lb, ub } = model.var_domain(v);
Solving,debug_assert!(lb < ub);
Solving,let value = self.default_assignment.get(v).unwrap_or(lb);
Solving,};
Solving,// println!("dec: {literal:?}   {}", self.heap.activity(literal));
Solving,};
Solving,self.heap.lit_bump_activity(lit);
Solving,let prez = model.state.presence(lit.variable());
Solving,type Heap = IdxHeap<VarRef, f64>;
Solving,debug_assert!(!self.is_declared(v));
Solving,let priority = initial_priority.unwrap_or(0.0);
Solving,self.heap.declare_element(v, priority);
Solving,self.vars.insert(v);
Solving,debug_assert!(self.is_declared(v));
Solving,self.heap.enqueue(v);
Solving,self.trail.push(HeapEvent::Removal(var));
Solving,let var = lit.variable();
Solving,let var_inc = self.params.var_inc * factor;
Solving,self.heap.change_priority(var, |p| *p += var_inc);
Solving,let p = self.heap.priority(var);
Solving,debug_assert!(!new_value.is_nan());
Solving,debug_assert!(!factor.is_nan());
Solving,let var = lit.variable();
Solving,// assert!(self.params.var_inc == 1.0_f32);
Solving,let var_inc = self.params.var_inc;
Solving,let previous = self.heap.priority(var);
Solving,.min(1e300_f64);
Solving,let corrected = previous * correction;
Solving,let corrected = corrected.clamp(0.0, var_inc);
Solving,let new = corrected * (1.0 - factor) + new_value * factor * var_inc;
Solving,self.var_rescale_activity();
Solving,break new;
Solving,};
Solving,);
Solving,};
Solving,});
Solving,self.heap.change_priority(var, |p| *p = new_priority);
Solving,self.params.var_inc /= self.params.var_decay;
Solving,*p *= 1e-300;
Solving,});
Solving,self.params.var_inc *= 1e-300;
Solving,self.heap.enqueue(var);
Solving,self.conflicts.assignments.save_state();
Solving,let tot = self.conflicts.num_conflicts - self.conflicts.assignment_time[v];
Solving,let involved = self.conflicts.conflict_since_assignment[v];
Solving,// println!("{v:?}: {involved} / {tot}     {}", self.conflicts.num_conflicts);
Solving,self.conflicts.assignment_time.remove(v);
Solving,let lr = involved / (tot as f64);
Solving,self.heap.lit_update_activity(v.geq(1), lr, 0.05, tot as u32);
Solving,});
Solving,};
Solving,self.default_assignment.objective_found = Some(objective);
Solving,self.default_assignment.bump_solution_id();
Solving,self.default_assignment.set_from_solution(var, val);
Solving,self.process_events(_model);
Solving,self.process_events(_model);
Solving,let current_min = self.params.value_selection.min_unbound_dec_vars;
Solving,let mut count = 0;
Solving,count += 1;
Solving,break;
Solving,self.params.value_selection.min_unbound_dec_vars = count;
Solving,};
Solving,let mut num_undone_decision = 0;
Solving,num_undone_decision += 1;
Solving,let var = ev.affected_bound.variable();
Solving,debug_assert!(num_undone_decision > 0);
Solving,self.conflicts.num_conflicts += 1;
Solving,self.heap.decay_activities();
Solving,let mut culprits = LitSet::new();
Solving,culprits.insert(!*b);
Solving,culprits.insert(l);
Solving,let l = !*disjunct;
Solving,debug_assert!(model.entails(r) || model.presence_literal(r.variable()) == Lit::TRUE);
Solving,culprits.insert(r);
Solving,let lbd = lbd(clause, &model.state);
Solving,};
Solving,self.bump_activity(culprit, model);
Solving,let v = culprit.variable();
Solving,// println!("  culprit: {v:?}  {:?}  ", model.value_of_literal(culprit),);
Solving,// debug_assert!(dbg!(self.conflicts.assignment_time[v]) <= dbg!(self.conflicts.num_conflicts));
Solving,// );
Solving,self.conflicts.conflict_since_assignment[v] += impact;
Solving,let mut working_lbd_compute = IterableRefSet::new();
Solving,let mut uncounted = 0u32;
Solving,uncounted += 1;
Solving,let lvl = model.entailing_level(!l);
Solving,working_lbd_compute.insert(lvl);
Solving,//eprintln!("LBD: {}", working_lbd_compute.len());
Solving,use crate::backtrack::{Backtrack, DecLvl};
Solving,use crate::core::state::{Conflict, Explainer};
Solving,use crate::core::IntCst;
Solving,use crate::model::extensions::SavedAssignment;
Solving,use crate::model::Model;
Solving,use crate::solver::search::{Brancher, Decision, SearchControl};
Solving,use crate::solver::stats::Stats;
Solving,use itertools::Itertools;
Solving,use std::sync::Arc;
Solving,fn and_then(self, fallback: Brancher<L>) -> Brancher<L>;
Solving,fn with_restarts(self, allowed_conflicts: u64, increase_ratio: f32) -> Brancher<L>;
Solving,self.first.save_state();
Solving,self.first.restore_last();
Solving,self.second.restore_last();
Solving,self.first.import_vars(model);
Solving,self.second.import_vars(model);
Solving,self.first.new_assignment_found(objective_value, assignment.clone());
Solving,self.second.new_assignment_found(objective_value, assignment);
Solving,self.first.conflict(clause, model, explainer, backtrack_level);
Solving,self.second.conflict(clause, model, explainer, backtrack_level);
Solving,self.first.pre_save_state(model);
Solving,self.first.pre_conflict_analysis(model);
Solving,self.brancher.restore_last();
Solving,self.active = false;
Solving,self.brancher.pre_save_state(model);
Solving,self.brancher.pre_conflict_analysis(model);
Solving,self.conflicts_at_last_restart = stats.num_conflicts();
Solving,self.allowed_conflicts = (self.allowed_conflicts as f32 * self.increase_ratio_for_allowed_conflict) as u64;
Solving,self.brancher.pre_save_state(model);
Solving,self.brancher.pre_conflict_analysis(model);
Solving,self.current_mut().restore_last();
Solving,self.current_idx = (self.current_idx + 1) % self.branchers.len();
Solving,self.num_conflicts_since_switch = 0;
Solving,self.num_conflicts_per_period = (self.num_conflicts_per_period as f64 * self.increase_factor) as u64;
Solving,self.current_mut().pre_save_state(_model);
Solving,self.current_mut().pre_conflict_analysis(_model);
Solving,self.num_conflicts_since_switch += 1;
Solving,use crate::backtrack::{Backtrack, DecLvl, ObsTrailCursor, Trail};
Solving,use crate::collections::heap::IdxHeap;
Solving,use crate::collections::ref_store::RefMap;
Solving,use crate::core::literals::Watches;
Solving,use crate::core::state::{Conflict, Event, Explainer, IntDomain};
Solving,use crate::core::*;
Solving,use crate::model::extensions::{AssignmentExt, SavedAssignment, Shaped};
Solving,use crate::model::{Label, Model};
Solving,use crate::solver::search::{Decision, SearchControl};
Solving,use crate::solver::stats::Stats;
Solving,use env_param::EnvParam;
Solving,use std::sync::Arc;
Solving,pub static PREFER_MIN_VALUE: EnvParam<bool> = EnvParam::new("ARIES_SMT_PREFER_MIN_VALUE", "true");
Solving,pub static INITIALLY_ALLOWED_CONFLICTS: EnvParam<u64> = EnvParam::new("ARIES_SMT_INITIALLY_ALLOWED_CONFLICT", "100");
Solving,EnvParam::new("ARIES_SMT_INCREASE_RATIO_FOR_ALLOWED_CONFLICTS", "1.5");
Solving,pub static USE_LNS: EnvParam<bool> = EnvParam::new("ARIES_ACTIVITY_USES_LNS", "true");
Solving,fn decision_stage(&self, var: VarRef, label: Option<&Lbl>, model: &Model<Lbl>) -> u8;
Solving,pub struct DefaultHeuristic;
Solving,let mut count = 0;
Solving,let unprocessed_vars = (self.num_processed_var..model.state.num_variables()).map(VarRef::from);
Solving,debug_assert!(!self.heap.is_declared(var));
Solving,let prez = model.presence_literal(var);
Solving,self.heap.declare_variable(var, self.priority(var, model), None);
Solving,self.presences.add_watch(var, prez);
Solving,self.heap.enqueue_variable(var);
Solving,count += 1;
Solving,self.num_processed_var += count;
Solving,self.heap.enqueue_variable(var);
Solving,self.import_vars(model);
Solving,let mut popper = self.heap.extractor();
Solving,popper.pop().unwrap();
Solving,break Some(v);
Solving,break None;
Solving,};
Solving,self.conflicts_at_last_restart = stats.num_conflicts();
Solving,(self.params.allowed_conflicts as f32 * self.params.increase_ratio_for_allowed_conflicts) as u64;
Solving,let IntDomain { lb, ub } = model.var_domain(v);
Solving,debug_assert!(lb < ub);
Solving,.unwrap_or(if self.params.prefer_min_value { lb } else { ub });
Solving,debug_assert!(ub > value);
Solving,};
Solving,self.default_assignment.values.insert(var, val);
Solving,self.heap.var_bump_activity(bvar);
Solving,assert!(self.default_assignment.objective_found.iter().all(|&c| c > cost));
Solving,self.default_assignment.objective_found = Some(cost);
Solving,type Heap = IdxHeap<VarRef, BoolVarHeuristicValue>;
Solving,debug_assert!(!self.is_declared(v));
Solving,};
Solving,let priority = stage as usize;
Solving,self.heaps.push(IdxHeap::new());
Solving,self.heaps[priority].declare_element(v, hvalue);
Solving,self.stages.insert(v, priority as u8);
Solving,debug_assert!(self.is_declared(v));
Solving,let priority = self.stages[v] as usize;
Solving,self.heaps[priority].enqueue(v);
Solving,let heap_index = self.stage_of(v) as usize;
Solving,let heap_index = self.stage_of(v) as usize;
Solving,let mut heaps = self.heaps.iter_mut();
Solving,let current_heap = heaps.next();
Solving,let var_inc = self.params.var_inc;
Solving,let heap = self.mut_heap_of(var);
Solving,heap.change_priority(var, |p| p.activity += var_inc);
Solving,self.params.var_inc /= self.params.var_decay;
Solving,heap.change_all_priorities_in_place(|p| p.activity *= 1e-30_f32);
Solving,self.params.var_inc *= 1e-30_f32;
Solving,let heaps = &mut self.heaps;
Solving,heaps[prio as usize].enqueue(var);
Solving,return Some(var);
Solving,self.current_heap = self.heaps.next();
Solving,self.stage += 1;
Solving,self.trail.push(HeapEvent::Removal(var, self.stage));
Solving,return Some(var);
Solving,self.current_heap = self.heaps.next();
Solving,self.stage += 1;
Solving,.unwrap_or(true);
Solving,self.default_assignment.objective_found = Some(objective);
Solving,self.set_default_value(var, val);
Solving,self.heap.decay_activities();
Solving,self.bump_activity(b.variable(), model);
Solving,use std::collections::BTreeSet;
Solving,use crate::backtrack::{Backtrack, DecLvl, DecisionLevelTracker};
Solving,use crate::core::VarRef;
Solving,use crate::model::extensions::AssignmentExt;
Solving,use crate::model::Model;
Solving,use crate::solver::search::{Decision, SearchControl};
Solving,use crate::solver::stats::Stats;
Solving,};
Solving,let dom = model.var_domain(v);
Solving,use crate::model::Label;
Solving,use crate::solver::search::beta::restart::Restart;
Solving,pub struct Never;
Solving,use crate::backtrack::DecLvl;
Solving,use crate::core::state::Conflict;
Solving,use crate::core::state::Explainer;
Solving,use crate::model::Label;
Solving,use crate::model::Model;
Solving,use crate::solver::search::beta::restart::Restart;
Solving,debug_assert!(scaling_factor >= 1.0);
Solving,debug_assert!(period >= 1);
Solving,self.period = (self.scaling_factor * self.period as f32) as u32;
Solving,self.countdown = self.countdown.saturating_sub(1);
Solving,debug_assert!(self.countdown <= self.period);
Solving,let timesup = self.countdown == 0;
Solving,self.scale();
Solving,self.countdown = self.period;
Solving,mod geometric;
Solving,mod never;
Solving,use crate::backtrack::DecLvl;
Solving,use crate::core::state::Conflict;
Solving,use crate::core::state::Explainer;
Solving,use crate::model::Label;
Solving,use crate::model::Model;
Solving,pub use crate::solver::search::beta::restart::geometric::Geometric;
Solving,pub use crate::solver::search::beta::restart::never::Never;
Solving,fn restart(&mut self) -> bool;
Solving,use crate::core::Lit;
Solving,use crate::core::VarRef;
Solving,use crate::model::Label;
Solving,use crate::model::Model;
Solving,use crate::solver::search::beta::value_order::ValueOrder;
Solving,pub struct LowerHalf;
Solving,let (lb, ub) = model.state.bounds(var);
Solving,debug_assert!(lb < ub);
Solving,let mid = (lb + ub) / 2;
Solving,use super::*;
Solving,let mut model = Model::<String>::new();
Solving,let x = model.new_ivar(0, 1, "x").into();
Solving,let y = model.new_ivar(3, 5, "y").into();
Solving,let z = model.new_ivar(-5, -3, "z").into();
Solving,assert_eq!(LowerHalf.select(x, &model), x.leq(0));
Solving,assert_eq!(LowerHalf.select(y, &model), y.leq(4));
Solving,assert_eq!(LowerHalf.select(z, &model), z.leq(-4));
Solving,use crate::core::Lit;
Solving,use crate::core::VarRef;
Solving,use crate::model::Label;
Solving,use crate::model::Model;
Solving,use crate::solver::search::beta::value_order::ValueOrder;
Solving,pub struct Min;
Solving,let lb = model.state.lb(var);
Solving,use super::*;
Solving,let mut model = Model::<String>::new();
Solving,let x = model.new_ivar(0, 1, "x").into();
Solving,let y = model.new_ivar(3, 5, "y").into();
Solving,assert_eq!(Min.select(x, &model), x.leq(0));
Solving,assert_eq!(Min.select(y, &model), y.leq(3));
Solving,use num_integer::Integer;
Solving,use crate::core::Lit;
Solving,use crate::core::VarRef;
Solving,use crate::model::Label;
Solving,use crate::model::Model;
Solving,use crate::solver::search::beta::value_order::ValueOrder;
Solving,pub struct UpperHalf;
Solving,let (lb, ub) = model.state.bounds(var);
Solving,let (mid, rem) = (lb + ub).div_mod_floor(&2);
Solving,use super::*;
Solving,let mut model = Model::<String>::new();
Solving,let x = model.new_ivar(0, 1, "x").into();
Solving,let y = model.new_ivar(3, 5, "y").into();
Solving,assert_eq!(UpperHalf.select(x, &model), x.geq(1));
Solving,assert_eq!(UpperHalf.select(y, &model), y.geq(4));
Solving,use crate::core::Lit;
Solving,use crate::core::VarRef;
Solving,use crate::model::Label;
Solving,use crate::model::Model;
Solving,use crate::solver::search::beta::value_order::ValueOrder;
Solving,pub struct Max;
Solving,let ub = model.state.ub(var);
Solving,use super::*;
Solving,let mut model = Model::<String>::new();
Solving,let x = model.new_ivar(0, 1, "x").into();
Solving,let y = model.new_ivar(3, 5, "y").into();
Solving,assert_eq!(Max.select(x, &model), x.geq(1));
Solving,assert_eq!(Max.select(y, &model), y.geq(5));
Solving,mod dynamic;
Solving,mod lower_half;
Solving,mod max;
Solving,mod min;
Solving,mod upper_half;
Solving,use crate::core::Lit;
Solving,use crate::core::VarRef;
Solving,use crate::model::Label;
Solving,use crate::model::Model;
Solving,use crate::solver::search::Conflict;
Solving,use crate::solver::search::DecLvl;
Solving,use crate::solver::search::Explainer;
Solving,pub use crate::solver::search::beta::value_order::dynamic::Dynamic;
Solving,pub use crate::solver::search::beta::value_order::lower_half::LowerHalf;
Solving,pub use crate::solver::search::beta::value_order::max::Max;
Solving,pub use crate::solver::search::beta::value_order::min::Min;
Solving,pub use crate::solver::search::beta::value_order::upper_half::UpperHalf;
Solving,fn select(&mut self, var: VarRef, model: &Model<Lbl>) -> Lit;
Solving,debug_assert!(!model.state.is_bound(var));
Solving,use hashbrown::HashMap;
Solving,use crate::core::state::Conflict;
Solving,use crate::core::state::Explainer;
Solving,use crate::core::Lit;
Solving,use crate::core::Relation;
Solving,use crate::core::VarRef;
Solving,use crate::model::Label;
Solving,use crate::model::Model;
Solving,use crate::solver::search::beta::value_order::ValueOrder;
Solving,use crate::solver::search::DecLvl;
Solving,assert!(period >= 1);
Solving,self.zero_pos = !self.zero_pos;
Solving,*s += value;
Solving,self.table.insert(var, value);
Solving,let var = lit.variable();
Solving,};
Solving,self.bump(var, b);
Solving,*score /= 2;
Solving,self.countdown -= 1;
Solving,self.decay();
Solving,self.countdown = self.period;
Solving,let score = self.get(&var);
Solving,let (lb, ub) = model.state.bounds(var);
Solving,let positive = score > 0 || (score == 0 && self.zero_is_pos());
Solving,self.handle_decay();
Solving,self.handle(lit);
Solving,self.handle(&lit);
Solving,use super::*;
Solving,/// let (model, x, y, z) = model();
Solving,let mut model = Model::new();
Solving,let x = model.new_ivar(0, 7, "x").into();
Solving,let y = model.new_ivar(3, 6, "y").into();
Solving,let z = model.new_ivar(-2, 4, "z").into();
Solving,let (_model, x, y, z) = basic_model();
Solving,let mut dynamic = Dynamic::default();
Solving,dynamic.handle(&x.geq(0));
Solving,dynamic.handle(&y.leq(6));
Solving,assert_eq!(dynamic.get(&x), 1);
Solving,assert_eq!(dynamic.get(&y), -1);
Solving,assert_eq!(dynamic.get(&z), 0);
Solving,let (model, x, y, z) = basic_model();
Solving,let mut dynamic = Dynamic::default();
Solving,dynamic.bump(x, -1);
Solving,dynamic.bump(y, 1);
Solving,assert_eq!(dynamic.select(x, &model), x.leq(0));
Solving,assert_eq!(dynamic.select(y, &model), y.geq(6));
Solving,assert_eq!(dynamic.select(z, &model), z.geq(4));
Solving,use crate::backtrack::Backtrack;
Solving,use crate::backtrack::DecLvl;
Solving,use crate::backtrack::DecisionLevelTracker;
Solving,use crate::core::state::Conflict;
Solving,use crate::core::state::Explainer;
Solving,use crate::model::Label;
Solving,use crate::model::Model;
Solving,use crate::solver::search::beta::restart::Restart;
Solving,use crate::solver::search::beta::restart::RestartKind;
Solving,use crate::solver::search::beta::value_order::ValueOrder;
Solving,use crate::solver::search::beta::value_order::ValueOrderKind;
Solving,use crate::solver::search::beta::var_order::VarOrder;
Solving,use crate::solver::search::beta::var_order::VarOrderKind;
Solving,use crate::solver::search::Brancher;
Solving,use crate::solver::search::Decision;
Solving,use crate::solver::search::SearchControl;
Solving,use crate::solver::stats::Stats;
Solving,let lvl = DecisionLevelTracker::new();
Solving,let var = self.var_order.select(model)?;
Solving,let lit = self.value_order.select(var, model);
Solving,self.var_order.conflict(clause, model, explainer, backtrack_level);
Solving,self.value_order.conflict(clause, model, explainer, backtrack_level);
Solving,self.restart.conflict(clause, model, explainer, backtrack_level);
Solving,mod beta_brancher;
Solving,pub mod restart;
Solving,pub mod value_order;
Solving,pub mod var_order;
Solving,pub use beta_brancher::BetaBrancher;
Solving,use std::collections::HashMap;
Solving,use crate::backtrack::DecLvl;
Solving,use crate::core::state::Conflict;
Solving,use crate::core::state::Explainer;
Solving,use crate::core::VarRef;
Solving,use crate::model::Label;
Solving,use crate::model::Model;
Solving,use crate::solver::search::beta::var_order::VarOrder;
Solving,debug_assert!((0.0..=1.0).contains(&decay_factor));
Solving,let activity = self.get(var) + 1.0;
Solving,self.table.insert(var, activity);
Solving,*activity *= self.decay_factor;
Solving,self.decay();
Solving,self.bump(literal.variable());
Solving,use crate::core::VarRef;
Solving,use crate::model::Label;
Solving,use crate::model::Model;
Solving,use crate::solver::search::beta::var_order::VarOrder;
Solving,pub struct FirstFail;
Solving,let (lb, ub) = model.state.bounds(*v);
Solving,use super::*;
Solving,let mut model = Model::<String>::new();
Solving,let _ = model.new_ivar(3, 5, "y");
Solving,let z = model.new_ivar(0, 1, "z").into();
Solving,assert_eq!(FirstFail.select(&model), Some(z));
Solving,mod activity;
Solving,mod first_fail;
Solving,mod lexical;
Solving,use crate::backtrack::DecLvl;
Solving,use crate::core::state::Conflict;
Solving,use crate::core::state::Explainer;
Solving,use crate::core::VarRef;
Solving,use crate::model::Label;
Solving,use crate::model::Model;
Solving,pub use crate::solver::search::beta::var_order::activity::Activity;
Solving,pub use crate::solver::search::beta::var_order::first_fail::FirstFail;
Solving,pub use crate::solver::search::beta::var_order::lexical::Lexical;
Solving,fn select(&self, model: &Model<Lbl>) -> Option<VarRef>;
Solving,use crate::core::VarRef;
Solving,use crate::model::Label;
Solving,use crate::model::Model;
Solving,use crate::solver::search::beta::var_order::VarOrder;
Solving,pub struct Lexical;
Solving,use super::*;
Solving,let mut model = Model::<String>::new();
Solving,let y = model.new_ivar(3, 5, "y").into();
Solving,let _ = model.new_ivar(0, 1, "z");
Solving,assert_eq!(Lexical.select(&model), Some(y));
Solving,use crate::backtrack::{Backtrack, DecLvl, DecisionLevelTracker};
Solving,use crate::core::Lit;
Solving,use crate::model::extensions::AssignmentExt;
Solving,use crate::model::Model;
Solving,use crate::solver::search::{Decision, SearchControl};
Solving,use crate::solver::stats::Stats;
Solving,use itertools::Itertools;
Solving,use rand::rngs::SmallRng;
Solving,use rand::{Rng, SeedableRng};
Solving,let dom = model.var_domain(*v);
Solving,.collect_vec();
Solving,return None;
Solving,let var_id = self.rng.gen_range(0..variables.len());
Solving,let var = variables[var_id];
Solving,let (lb, ub) = model.state.bounds(var);
Solving,let upper: bool = self.rng.gen();
Solving,let val = self.rng.gen_range(lb..ub);
Solving,let val = self.rng.gen_range((lb + 1)..=ub);
Solving,use crate::collections::id_map::IdMap;
Solving,use crate::core::{u32_to_cst, IntCst};
Solving,use crate::create_ref_type;
Solving,use crate::model::types::{TypeHierarchy, TypeId};
Solving,use anyhow::*;
Solving,use std::collections::HashMap;
Solving,use std::fmt::{self, Write};
Solving,use std::fmt::{Debug, Display, Formatter};
Solving,use std::hash::Hash;
Solving,use crate::collections::ref_store::RefVec;
Solving,use crate::utils::input::Sym;
Solving,use std::borrow::Borrow;
Solving,writeln!(f, "{:?}\t<- {:?}", SymId::from(i), x)?;
Solving,let last_id: usize = last.into();
Solving,let sym = usize::from(sym);
Solving,type Item = SymId;
Solving,self.first += 1;
Solving,let th = TypeHierarchy::new(Vec::new()).unwrap();
Solving,let mut instances_by_type = HashMap::new();
Solving,let tpe_id = th.id_of(&tpe).ok_or_else(|| tpe.invalid("Unknown atom"))?;
Solving,.push(sym);
Solving,};
Solving,let first = table.symbols.len();
Solving,);
Solving,tracing::warn!("duplicated instance : {}", sym);
Solving,continue;
Solving,let id = SymId::from(table.symbols.len());
Solving,table.symbols.push(sym.clone());
Solving,table.ids.insert(sym, id);
Solving,let sym_alias = table.symbol_types.push(tpe);
Solving,assert_eq!(id, sym_alias, "Problem in the insertion order");
Solving,let after_last = table.symbols.len();
Solving,.insert(tpe, ContiguousSymbols { first, after_last });
Solving,let i: usize = id.into();
Solving,let mut instance = self.instances_by_exact_type[tpe];
Solving,instance.after_last = self.instances_by_exact_type[self.types.last_subtype(tpe)].after_last;
Solving,let mut s = String::from("(");
Solving,write!(s, "{} ", self.symbol(*sym)).unwrap();
Solving,s.pop();
Solving,s.push(')');
Solving,create_ref_type!(SymId);
Solving,use super::*;
Solving,use crate::model::types::TypeHierarchy;
Solving,use crate::utils::enumerate;
Solving,use streaming_iterator::StreamingIterator;
Solving,let symbols = table();
Solving,let types = &symbols.types;
Solving,let rover = types.id_of("rover").unwrap();
Solving,let predicate = types.id_of("predicate").unwrap();
Solving,let location = types.id_of("location").unwrap();
Solving,let object = types.id_of("object").unwrap();
Solving,assert_eq!(symbols.instances_of_type(predicate).count(), 2);
Solving,assert_eq!(symbols.instances_of_type(object).count(), 3);
Solving,assert_eq!(symbols.instances_of_type(rover).count(), 1);
Solving,assert_eq!(symbols.instances_of_type(location).count(), 2);
Solving,let symbols = table();
Solving,let types = &symbols.types;
Solving,let rover = types.id_of("rover").unwrap();
Solving,let predicate = types.id_of("predicate").unwrap();
Solving,let location = types.id_of("location").unwrap();
Solving,let _object = types.id_of("object").unwrap();
Solving,];
Solving,let mut xx = enumerate(x.to_vec());
Solving,];
Solving,let types = TypeHierarchy::new(types).unwrap();
Solving,];
Solving,use crate::core::literals::StableLitSet;
Solving,use crate::core::*;
Solving,use std::collections::HashMap;
Solving,use std::sync::Arc;
Solving,};
Solving,s.insert(StableLitSet::EMPTY, Lit::TRUE);
Solving,s.tautologies.insert(Lit::TRUE, Lit::TRUE);
Solving,assert!(!self.tautologies.contains_key(&scope));
Solving,self.tautologies.insert(scope, tautology);
Solving,debug_assert!(!self.conjunctive_scopes.contains_key(&conjunction));
Solving,let conjunction = Arc::new(conjunction);
Solving,.or_insert_with(|| conjunction.clone());
Solving,debug_assert!(self.conjunction_of[&literal].len() <= conjunction.len(), "Sanity check");
Solving,self.conjunctive_scopes.insert(conjunction, literal);
Solving,use crate::collections::id_map::IdMap;
Solving,use crate::collections::ref_store::RefPool;
Solving,use crate::model::lang::Type;
Solving,use crate::utils::input::Sym;
Solving,use std::borrow::Borrow;
Solving,use std::error::Error;
Solving,use std::fmt::{Debug, Display, Formatter};
Solving,use std::hash::Hash;
Solving,pub struct TypeId(usize);
Solving,pub struct NotASymbolicType(Type);
Solving,type Error = NotASymbolicType;
Solving,pub struct UnreachableFromRoot<T>(Vec<(T, Option<T>)>);
Solving,let top_type = Sym::new("any");
Solving,types.insert(0, (top_type.clone(), None));
Solving,};
Solving,let mut trace: Vec<Option<Sym>> = vec![None];
Solving,let parent = trace.last().unwrap();
Solving,let child = types.remove(pos_of_child);
Solving,sys.types.push(child.0.clone());
Solving,trace.push(Some(child.0));
Solving,let parent_id = sys.types.get_ref(p).unwrap();
Solving,sys.last_subtype.insert(parent_id, sys.types.last_key().unwrap());
Solving,trace.pop();
Solving,let sub = self.last_subtype[tpe];
Solving,debug_assert!(self.is_subtype(tpe, sub));
Solving,use super::*;
Solving,];
Solving,let ts = TypeHierarchy::new(types).unwrap();
Solving,let types = ["A", "B", "A1", "A11", "A12", "A2"];
Solving,let ids: Vec<TypeId> = types.iter().map(|name| ts.id_of(*name).unwrap()).collect();
Solving,let [a, b, a1, a11, a12, a2] = *ids else { unreachable!() };
Solving,assert!(ts.is_subtype(a, a));
Solving,assert!(ts.is_subtype(a, a1));
Solving,assert!(ts.is_subtype(a, a11));
Solving,assert!(ts.is_subtype(a, a12));
Solving,assert!(ts.is_subtype(a, a2));
Solving,assert!(ts.is_subtype(a1, a1));
Solving,assert!(ts.is_subtype(a1, a11));
Solving,assert!(ts.is_subtype(a1, a12));
Solving,assert!(!ts.is_subtype(a1, a));
Solving,assert!(!ts.is_subtype(a, b));
Solving,assert!(!ts.is_subtype(b, a));
Solving,assert!(ts.are_compatible(a, a1));
Solving,assert!(ts.are_compatible(a, a2));
Solving,assert!(ts.are_compatible(a1, a1));
Solving,assert!(ts.are_compatible(a, a1));
Solving,assert!(ts.are_compatible(a, a2));
Solving,assert!(ts.are_compatible(a1, a1));
Solving,assert!(ts.are_compatible(a, a));
Solving,assert!(ts.are_compatible(a, a1));
Solving,assert!(ts.are_compatible(a, a2));
Solving,assert!(ts.are_compatible(a, a11));
Solving,assert!(ts.are_compatible(a11, a));
Solving,assert!(!ts.are_compatible(a, b));
Solving,assert!(!ts.are_compatible(a2, a1));
Solving,use std::convert::TryFrom;
Solving,use std::fmt::Formatter;
Solving,use std::sync::Arc;
Solving,use crate::backtrack::{Backtrack, DecLvl};
Solving,use crate::collections::ref_store::RefMap;
Solving,use crate::core::literals::StableLitSet;
Solving,use crate::core::state::*;
Solving,use crate::core::*;
Solving,use crate::model::extensions::{AssignmentExt, SavedAssignment, Shaped};
Solving,use crate::model::label::{Label, VariableLabels};
Solving,use crate::model::lang::expr::or;
Solving,use crate::model::lang::reification::Reification;
Solving,use crate::model::lang::*;
Solving,use crate::model::model_impl::scopes::Scopes;
Solving,use crate::model::symbols::SymbolTable;
Solving,use crate::model::types::TypeId;
Solving,use crate::reif::{ReifExpr, Reifiable};
Solving,mod scopes;
Solving,self.types.insert(var, typ);
Solving,let c = Constraint::HalfReified(expr, value);
Solving,tracing::trace!("Adding constraint: {}", c);
Solving,];
Solving,tracing::trace!("Adding constraint: {}", c);
Solving,let Constraint::HalfReified(expr, enabler) = c;
Solving,let actual_value = expr.eval(assignment);
Solving,);
Solving,self.state = domains;
Solving,let lit = self.state.new_var(0, 1).geq(1);
Solving,self.shape.conjunctive_scopes.insert(StableLitSet::from([lit]), lit);
Solving,self.state.add_implication(lit, scope);
Solving,let var = lit.variable();
Solving,self.shape.set_label(var, label);
Solving,self.shape.set_type(var, Type::Bool);
Solving,.all(|l| self.state.presence(l.variable()) == Lit::TRUE));
Solving,let empty: &[Lit] = &[];
Solving,let scope = ValidityScope::new(presence_variables.iter().copied(), empty.iter().copied());
Solving,);
Solving,return Lit::TRUE;
Solving,let var = self.state.new_optional_var(1, 1, scope);
Solving,let lit = var.geq(1);
Solving,self.shape.set_type(var, Type::Bool);
Solving,self.shape.conjunctive_scopes.set_tautology_of_scope(scope, lit);
Solving,let set = set.into();
Solving,return Lit::TRUE;
Solving,return l;
Solving,let l = self.state.new_var(0, 0).geq(1);
Solving,self.shape.set_type(l.variable(), Type::Bool);
Solving,};
Solving,let l = self.state.new_var(0, 1).geq(1);
Solving,self.shape.set_type(l.variable(), Type::Bool);
Solving,let mut clause = vec![l];
Solving,self.state.add_implication(l, v_i);
Solving,clause.push(!v_i);
Solving,self.enforce(or(clause), []);
Solving,});
Solving,self.shape.conjunctive_scopes.insert(set, l);
Solving,};
Solving,self.shape.set_label(dvar, label);
Solving,self.shape.set_type(dvar, Type::Bool);
Solving,let ivar = self.new_ivar(num_lb, num_ub, label);
Solving,let ivar = self.new_optional_ivar(num_lb, num_ub, presence, label);
Solving,};
Solving,self.shape.set_label(dvar, label);
Solving,self.shape.set_type(dvar, Type::Int { lb, ub });
Solving,let instances = self.shape.symbols.instances_of_type(tpe);
Solving,let lb = usize::from(lb) as IntCst;
Solving,let ub = usize::from(ub) as IntCst;
Solving,};
Solving,self.shape.set_label(dvar, label);
Solving,self.shape.set_type(dvar, Type::Sym(tpe));
Solving,println!("WARNING: workaround for empty domain of optional vars (Github Issue #28)");
Solving,.expect("An optional but necessarily present variable has an empty integer domain.");
Solving,panic!("Variable with empty symbolic domain.");
Solving,};
Solving,let a = a.into();
Solving,let b = b.into();
Solving,let (l1, u1) = self.int_bounds(a);
Solving,let (l2, u2) = self.int_bounds(b);
Solving,let disjoint = u1 < l2 || u2 < l1;
Solving,let a = (*a).into();
Solving,let b = (*b).into();
Solving,return false;
Solving,let decomposed = expr.decompose(self);
Solving,};
Solving,let negated = |lit: Lit| entailed(!lit);
Solving,disjuncts.retain(|l| !negated(l));
Solving,conjuncts.retain(|l| !entailed(l));
Solving,std::mem::swap(v1, v2);
Solving,let (lb1, ub1) = self.state.bounds(*v1);
Solving,let (lb2, ub2) = self.state.bounds(*v2);
Solving,*expr = ReifExpr::Lit(Lit::FALSE);
Solving,*expr = ReifExpr::Lit(Lit::TRUE);
Solving,let (lb, ub) = self.state.bounds(*v1);
Solving,self.simplify(&mut expr);
Solving,let scope = self.scope_lit_of(&expr);
Solving,let var = self.state.new_optional_var(0, 1, scope);
Solving,self.shape.set_type(var, Type::Bool);
Solving,};
Solving,self.shape.expressions.intern_full_as(expr.clone(), lit);
Solving,self.shape.add_reification_constraint(lit, expr);
Solving,self.simplify(&mut expr);
Solving,let scope = self.scope_lit_of(&expr);
Solving,let var = self.state.new_optional_var(0, 1, scope);
Solving,self.shape.set_type(var, Type::Bool);
Solving,let lit = var.geq(1);
Solving,self.shape.expressions.intern_half_as(expr.clone(), lit);
Solving,self.shape.add_half_reification_constraint(lit, expr);
Solving,let scope = expr.scope(|var| self.state.presence(var));
Solving,);
Solving,let decomposed = &mut expr.decompose(self);
Solving,self.simplify(decomposed);
Solving,self.simplify(decomposed);
Solving,let decomposed = &mut expr.decompose(self);
Solving,self.simplify(decomposed);
Solving,debug_assert_eq!(self.state.current_decision_level(), DecLvl::ROOT);
Solving,let mut expr = expr.decompose(self);
Solving,self.simplify(&mut expr);
Solving,let scope = self.new_conjunctive_presence_variable(scope);
Solving,let expr_scope = expr.scope(|var| self.state.presence(var));
Solving,);
Solving,let expr_scope = self.new_conjunctive_presence_variable(expr_scope);
Solving,);
Solving,let tauto = self.get_tautology_of_scope(scope);
Solving,self.shape.add_half_reification_constraint(tauto, expr);
Solving,self.enforce(b, scope.clone());
Solving,let mut expr = expr.decompose(self);
Solving,self.simplify(&mut expr);
Solving,self.shape.add_half_reification_constraint(enabler, expr);
Solving,let mut expr = expr.decompose(self);
Solving,self.simplify(&mut expr);
Solving,let expression_scope = expr.scope(|var| self.state.presence(var));
Solving,);
Solving,let expression_scope = self.new_conjunctive_presence_variable(expression_scope);
Solving,);
Solving,self.shape.expressions.intern_full_as(expr.clone(), value);
Solving,self.shape.add_reification_constraint(value, expr);
Solving,let use_tautology = self.entails(value) && matches!(expr, ReifExpr::Linear(_));
Solving,let reified = self.reify_core(expr, use_tautology);
Solving,self.bind_literals(value, reified);
Solving,let atom = atom.into();
Solving,let prez = format!("[{:?}]", self.presence_literal(v));
Solving,let v_str = format!("{v:?}");
Solving,print!("{prez:<6}  {v_str:<6} <- {:?}", self.state.domain(v));
Solving,println!("    {lbl:?}");
Solving,self.state.restore_last();
Solving,self.state.restore(saved_id);
Solving,use crate::core::literals::{LitSet, StableLitSet};
Solving,use crate::core::Lit;
Solving,let mut set = LitSet::new();
Solving,set.insert(l);
Solving,use num_integer::lcm;
Solving,use crate::core::{IntCst, Lit, VarRef};
Solving,use crate::model::lang::{IAtom, IVar, ValidityScope};
Solving,use crate::reif::ReifExpr;
Solving,use std::collections::BTreeMap;
Solving,write!(f, "-")?;
Solving,write!(f, "{}", self.factor)?;
Solving,write!(f, "*")?;
Solving,write!(f, "{:?}", self.var)?;
Solving,write!(f, "1")?;
Solving,type Output = LinearTerm;
Solving,write!(f, " - ")?;
Solving,write!(f, "-")?;
Solving,write!(f, " + ")?;
Solving,write!(f, "{}", e.factor.abs())?;
Solving,write!(f, "*")?;
Solving,write!(f, "{:?}", e.var)?;
Solving,write!(f, "1")?;
Solving,write!(f, " + ")?;
Solving,write!(f, "{}", self.constant)?;
Solving,let mut res = LinearSum::zero();
Solving,debug_assert_eq!(new_denom % self.denom, 0);
Solving,let scaling_factor = new_denom / self.denom;
Solving,debug_assert_eq!(term.denom, self.denom);
Solving,term.factor *= scaling_factor;
Solving,term.denom = new_denom;
Solving,self.constant *= scaling_factor;
Solving,self.denom = new_denom;
Solving,let new_denom = lcm(self.denom, added.denom);
Solving,self.set_denom(new_denom);
Solving,added.factor *= new_denom / added.denom;
Solving,added.denom = new_denom;
Solving,self.terms.push(added);
Solving,let new_denom = lcm(self.denom, denom);
Solving,self.set_denom(new_denom);
Solving,let scaled_num = num * new_denom / denom;
Solving,self.constant += scaled_num;
Solving,let mut term_map = BTreeMap::new();
Solving,let mut constant = self.constant;
Solving,debug_assert_eq!(term.denom, self.denom);
Solving,.or_insert(term.factor);
Solving,constant += term.factor;
Solving,};
Solving,sum += LinearTerm::constant_rational(value.num.shift, value.denom);
Solving,};
Solving,sum += LinearTerm::constant_int(value.shift);
Solving,type Error = ConversionError;
Solving,type Output = LinearSum;
Solving,let mut new = self.clone();
Solving,new += rhs;
Solving,type Output = LinearSum;
Solving,type Output = LinearSum;
Solving,let mut new = self.clone();
Solving,new *= rhs;
Solving,let rhs: LinearSum = rhs.into();
Solving,self.add_term(term);
Solving,self.add_rational(rhs.constant, rhs.denom);
Solving,let sum: LinearSum = -rhs.into();
Solving,*self += sum;
Solving,let rhs = rhs.into();
Solving,self.constant *= rhs;
Solving,term.factor *= rhs;
Solving,type Output = LinearSum;
Solving,self.constant = -self.constant;
Solving,use crate::transitive_conversion;
Solving,use super::{Atom, ConversionError, FAtom};
Solving,transitive_conversion!(LinearSum, LinearTerm, IVar);
Solving,let mut vars = BTreeMap::new();
Solving,let var = VarRef::from(e.var);
Solving,let key = var;
Solving,.or_insert(e.factor);
Solving,write!(f, "-")?;
Solving,write!(f, "{}", self.factor)?;
Solving,write!(f, "*")?;
Solving,write!(f, "{:?}", self.var)?;
Solving,write!(f, "1")?;
Solving,type Output = NFLinearSumItem;
Solving,write!(f, " - ")?;
Solving,write!(f, "-")?;
Solving,write!(f, " + ")?;
Solving,write!(f, "{}", e.factor.abs())?;
Solving,write!(f, "*")?;
Solving,write!(f, "{:?}", e.var)?;
Solving,write!(f, "1")?;
Solving,let required_presence: Vec<Lit> = self.sum.iter().map(|item| presence(item.var)).collect();
Solving,let mut sum_map = BTreeMap::new();
Solving,let mut upper_bound = self.upper_bound;
Solving,.or_insert(term.factor);
Solving,upper_bound -= term.factor;
Solving,type Output = Self;
Solving,self.sum.iter_mut().for_each(|i| *i = -*i);
Solving,use crate::model::lang::FAtom;
Solving,use super::*;
Solving,let var1 = IVar::new(VarRef::from_u32(5));
Solving,let var2 = IVar::new(VarRef::from_u32(15));
Solving,let term = LinearTerm::new(ff * f, v, d);
Solving,assert_eq!(term.factor, ff * f);
Solving,assert_eq!(term.var, v);
Solving,assert_eq!(term.denom, d);
Solving,let var1 = IVar::new(VarRef::from_u32(5));
Solving,let var2 = IVar::new(VarRef::from_u32(15));
Solving,let term = LinearTerm::int(ff * f, v);
Solving,assert_eq!(term.factor, ff * f);
Solving,assert_eq!(term.var, v);
Solving,assert_eq!(term.denom, 1);
Solving,let var1 = IVar::new(VarRef::from_u32(5));
Solving,let var2 = IVar::new(VarRef::from_u32(15));
Solving,let term = LinearTerm::rational(ff * f, v, d);
Solving,assert_eq!(term.factor, ff * f);
Solving,assert_eq!(term.var, v);
Solving,assert_eq!(term.denom, d);
Solving,let term = LinearTerm::constant_int(ff * f);
Solving,assert_eq!(term.factor, ff * f);
Solving,assert_eq!(term.var, IVar::ONE);
Solving,assert_eq!(term.denom, 1);
Solving,let term = LinearTerm::constant_rational(ff * f, d);
Solving,assert_eq!(term.factor, ff * f);
Solving,assert_eq!(term.var, IVar::ONE);
Solving,assert_eq!(term.denom, d);
Solving,let var0 = IVar::ZERO;
Solving,let var1 = IVar::ONE;
Solving,let var2 = IVar::new(VarRef::from_u32(5));
Solving,let var3 = IVar::new(VarRef::from_u32(15));
Solving,let term = LinearTerm::from(v);
Solving,let expected = LinearTerm::int(1, v);
Solving,assert_eq!(term, expected);
Solving,let term = LinearTerm::from(i);
Solving,let expected = LinearTerm::constant_int(i);
Solving,assert_eq!(term, expected);
Solving,let mut terms: Vec<LinearTerm> = vec![];
Solving,let var1 = IVar::new(VarRef::from_u32(5));
Solving,let var2 = IVar::new(VarRef::from_u32(15));
Solving,let term = LinearTerm::new(ff * f, v, d);
Solving,terms.push(term);
Solving,assert_eq!(i == j, t1 == t2);
Solving,let var1 = IVar::new(VarRef::from_u32(5));
Solving,let var2 = IVar::new(VarRef::from_u32(15));
Solving,let term = -LinearTerm::new(ff * f, v, d);
Solving,let expected = LinearTerm::new(-ff * f, v, d);
Solving,assert_eq!(term, expected);
Solving,let var1 = IVar::new(VarRef::from_u32(5));
Solving,let var2 = IVar::new(VarRef::from_u32(15));
Solving,let term = LinearTerm::new(ff * f, v, d);
Solving,assert_eq!(term.factor, term.factor());
Solving,assert_eq!(term.var, term.var());
Solving,assert_eq!(term.denom, term.denom());
Solving,let var = IVar::new(VarRef::from_u32(5));
Solving,assert_eq!(format!("{}", LinearTerm::constant_int(1)), "1");
Solving,assert_eq!(format!("{}", LinearTerm::constant_int(-1)), "-1");
Solving,assert_eq!(format!("{}", LinearTerm::constant_int(5)), "5");
Solving,assert_eq!(format!("{}", LinearTerm::constant_int(-5)), "-5");
Solving,assert_eq!(format!("{}", LinearTerm::constant_rational(1, 10)), "1");
Solving,assert_eq!(format!("{}", LinearTerm::constant_rational(-1, 10)), "-1");
Solving,assert_eq!(format!("{}", LinearTerm::constant_rational(5, 10)), "5");
Solving,assert_eq!(format!("{}", LinearTerm::constant_rational(-5, 10)), "-5");
Solving,assert_eq!(format!("{}", LinearTerm::int(1, IVar::ONE)), "1");
Solving,assert_eq!(format!("{}", LinearTerm::int(-1, IVar::ONE)), "-1");
Solving,assert_eq!(format!("{}", LinearTerm::int(5, IVar::ONE)), "5");
Solving,assert_eq!(format!("{}", LinearTerm::int(-5, IVar::ONE)), "-5");
Solving,assert_eq!(format!("{}", LinearTerm::rational(1, IVar::ONE, 10)), "1");
Solving,assert_eq!(format!("{}", LinearTerm::rational(-1, IVar::ONE, 10)), "-1");
Solving,assert_eq!(format!("{}", LinearTerm::rational(5, IVar::ONE, 10)), "5");
Solving,assert_eq!(format!("{}", LinearTerm::rational(-5, IVar::ONE, 10)), "-5");
Solving,assert_eq!(format!("{}", LinearTerm::int(1, var)), "var5");
Solving,assert_eq!(format!("{}", LinearTerm::int(-1, var)), "-var5");
Solving,assert_eq!(format!("{}", LinearTerm::int(5, var)), "5*var5");
Solving,assert_eq!(format!("{}", LinearTerm::int(-5, var)), "-5*var5");
Solving,assert_eq!(format!("{}", LinearTerm::rational(1, var, 10)), "var5");
Solving,assert_eq!(format!("{}", LinearTerm::rational(-1, var, 10)), "-var5");
Solving,assert_eq!(format!("{}", LinearTerm::rational(5, var, 10)), "5*var5");
Solving,assert_eq!(format!("{}", LinearTerm::rational(-5, var, 10)), "-5*var5");
Solving,let sum = LinearSum::zero();
Solving,assert_eq!(sum.terms, vec![]);
Solving,assert_eq!(sum.constant, 0);
Solving,assert_eq!(sum.denom, 1);
Solving,let sum = LinearSum::constant_int(n);
Solving,assert_eq!(sum.terms, vec![]);
Solving,assert_eq!(sum.constant, n);
Solving,assert_eq!(sum.denom, 1);
Solving,let sum = LinearSum::constant_rational(n, d);
Solving,assert_eq!(sum.terms, vec![]);
Solving,assert_eq!(sum.constant, n);
Solving,assert_eq!(sum.denom, d);
Solving,let var = IVar::new(VarRef::from_u32(5));
Solving,let terms = vec![LinearTerm::rational(1, var, 10), LinearTerm::constant_rational(5, 10)];
Solving,let sum = LinearSum::of(terms.clone());
Solving,assert_eq!(sum.constant, 0);
Solving,assert_eq!(sum.denom, 10);
Solving,assert_eq!(sum.terms, terms);
Solving,];
Solving,];
Solving,let sum = LinearSum::of(terms);
Solving,assert_eq!(sum.constant, 0);
Solving,assert_eq!(sum.denom, 308);
Solving,assert_eq!(sum.terms, expected_terms);
Solving,];
Solving,];
Solving,let mut sum = LinearSum::constant_int(3) + LinearSum::of(vec![t]);
Solving,sum.set_denom(308);
Solving,assert_eq!(sum.constant, 3 * 308);
Solving,assert_eq!(sum.denom, 308);
Solving,assert_eq!(sum.terms, vec![e]);
Solving,let mut sum = LinearSum::constant_rational(3, 77);
Solving,sum.add_term(LinearTerm::constant_rational(5, 28));
Solving,assert_eq!(sum.constant, 12);
Solving,assert_eq!(sum.denom, 308);
Solving,assert_eq!(sum.terms, vec![LinearTerm::constant_rational(55, 308)]);
Solving,let mut sum = LinearSum::of(vec![LinearTerm::constant_rational(5, 28)]);
Solving,sum.add_rational(3, 77);
Solving,assert_eq!(sum.constant, 12);
Solving,assert_eq!(sum.denom, 308);
Solving,assert_eq!(sum.terms, vec![LinearTerm::constant_rational(55, 308)]);
Solving,let sum = LinearSum::constant_rational(n, d);
Solving,let leq = sum.clone().leq(u);
Solving,assert_eq!(leq.sum, sum - u);
Solving,assert_eq!(leq.ub, 0);
Solving,let sum = LinearSum::constant_rational(n, d);
Solving,let leq = sum.clone().geq(l);
Solving,assert_eq!(leq.sum, -(sum - l));
Solving,assert_eq!(leq.ub, 0);
Solving,let sum = LinearSum::constant_rational(n, d);
Solving,assert_eq!(sum.terms(), sum.terms);
Solving,assert_eq!(sum.constant(), sum.constant);
Solving,assert_eq!(sum.denom(), sum.denom);
Solving,let var = IVar::new(VarRef::from_u32(5));
Solving,let terms = vec![LinearTerm::rational(1, var, 10), LinearTerm::constant_rational(5, 10)];
Solving,let sum = LinearSum::of(terms.clone());
Solving,assert_eq!(sum.constant(), sum.constant);
Solving,assert_eq!(sum.denom(), sum.denom);
Solving,assert_eq!(sum.terms(), sum.terms);
Solving,let denom = 100;
Solving,let var1 = IVar::new(VarRef::from_u32(5));
Solving,let var2 = IVar::new(VarRef::from_u32(6));
Solving,.simplify();
Solving,assert_eq!(sum.constant, 75);
Solving,assert_eq!(sum.denom, 100);
Solving,];
Solving,assert_eq!(sum.terms.len(), expected_terms.len());
Solving,assert!(expected_terms.contains(&term));
Solving,];
Solving,let sum = LinearSum::from(t);
Solving,assert_eq!(sum.constant, 0);
Solving,assert_eq!(sum.denom, t.denom);
Solving,assert_eq!(sum.terms, vec![t]);
Solving,let sum = LinearSum::from(i);
Solving,assert_eq!(sum.constant, i);
Solving,assert_eq!(sum.denom, 1);
Solving,assert_eq!(sum.terms, vec![]);
Solving,let var0 = IVar::ZERO;
Solving,let var1 = IVar::ONE;
Solving,let var2 = IVar::new(VarRef::from_u32(5));
Solving,let var3 = IVar::new(VarRef::from_u32(15));
Solving,let fa = FAtom::new(IAtom::new(v, s), d);
Solving,let sum = LinearSum::from(fa);
Solving,assert_eq!(sum.constant, 0);
Solving,assert_eq!(sum.denom, d);
Solving,);
Solving,let var0 = IVar::ZERO;
Solving,let var1 = IVar::ONE;
Solving,let var2 = IVar::new(VarRef::from_u32(5));
Solving,let var3 = IVar::new(VarRef::from_u32(15));
Solving,let ia = IAtom::new(v, s);
Solving,let sum = LinearSum::from(ia);
Solving,assert_eq!(sum.constant, 0);
Solving,assert_eq!(sum.denom, 1);
Solving,assert_eq!(sum.terms, vec![LinearTerm::new(1, v, 1), LinearTerm::constant_int(s),]);
Solving,let s1 = LinearSum::of(vec![FAtom::new(5.into(), 28)]);
Solving,let s2 = LinearSum::of(vec![FAtom::new(10.into(), 77)]);
Solving,let result = (s1 + s2).simplify();
Solving,assert_eq!(result.constant, 95);
Solving,assert_eq!(result.denom, 308);
Solving,assert_eq!(result.terms, vec![]);
Solving,let v = IVar::new(VarRef::from_u32(5));
Solving,let s = LinearSum::of(vec![FAtom::new(IAtom::new(v, 5), 28)]);
Solving,let result = (s * 3).simplify();
Solving,assert_eq!(result.constant, 15);
Solving,assert_eq!(result.denom, 28);
Solving,assert_eq!(result.terms, vec![LinearTerm::new(3, v, 28)]);
Solving,let s1 = LinearSum::of(vec![FAtom::new(5.into(), 28)]);
Solving,let s2 = LinearSum::of(vec![FAtom::new(10.into(), 77)]);
Solving,let result = (s1 - s2).simplify();
Solving,assert_eq!(result.constant, 15);
Solving,assert_eq!(result.denom, 308);
Solving,assert_eq!(result.terms, vec![]);
Solving,let s1 = LinearSum::of(vec![FAtom::new(5.into(), 28)]);
Solving,let s2 = LinearSum::of(vec![FAtom::new(10.into(), 77)]);
Solving,let mut result = s1.clone();
Solving,result += s2;
Solving,let result = result.simplify();
Solving,assert_eq!(result.constant, 95);
Solving,assert_eq!(result.denom, 308);
Solving,assert_eq!(result.terms, vec![]);
Solving,let s1 = LinearSum::of(vec![FAtom::new(5.into(), 28)]);
Solving,let s2 = LinearSum::of(vec![FAtom::new(10.into(), 77)]);
Solving,let mut result = s1.clone();
Solving,result -= s2;
Solving,let result = result.simplify();
Solving,assert_eq!(result.constant, 15);
Solving,assert_eq!(result.denom, 308);
Solving,assert_eq!(result.terms, vec![]);
Solving,let v = IVar::new(VarRef::from_u32(5));
Solving,let s = LinearSum::of(vec![FAtom::new(IAtom::new(v, 5), 28)]);
Solving,let mut result = s.clone();
Solving,result *= 3;
Solving,let result = result.simplify();
Solving,assert_eq!(result.constant, 15);
Solving,assert_eq!(result.denom, 28);
Solving,assert_eq!(result.terms, vec![LinearTerm::new(3, v, 28)]);
Solving,let s1 = LinearSum::of(vec![FAtom::new(5.into(), 28)]);
Solving,let s2 = LinearSum::of(vec![FAtom::new(10.into(), 77)]);
Solving,let n = -s.clone();
Solving,assert_eq!(n.constant, -s.constant);
Solving,assert_eq!(n.denom, n.denom);
Solving,assert_eq!(nt, -st);
Solving,let var = IVar::new(VarRef::from_u32(5));
Solving,]);
Solving,assert_eq!(format!("{}", sum), "var5 + 5 + 5*var5 + 1");
Solving,]);
Solving,assert_eq!(format!("{}", sum), "var5 - 5 - 5*var5 - 1");
Solving,]);
Solving,assert_eq!(format!("{}", sum), "-var5 - 5");
Solving,assert_eq!(lcm(30, 36), 180);
Solving,assert_eq!(lcm(1, 10), 10);
Solving,assert_eq!(lcm(33, 12), 132);
Solving,assert_eq!(lcm(27, 48), 432);
Solving,assert_eq!(lcm(17, 510), 510);
Solving,assert_eq!(lcm(14, 18), 126);
Solving,assert_eq!(lcm(39, 45), 585);
Solving,assert_eq!(lcm(39, 130), 390);
Solving,assert_eq!(lcm(28, 77), 308);
Solving,let var0 = VarRef::ZERO;
Solving,let var1 = VarRef::from_u32(5);
Solving,let var2 = VarRef::from_u32(6);
Solving,let item = |factor: IntCst, var: VarRef| NFLinearSumItem { var, factor };
Solving,.simplify();
Solving,assert_eq!(obj.upper_bound, -65);
Solving,];
Solving,assert_eq!(obj.sum.len(), expected_sum.len());
Solving,assert!(expected_sum.contains(&term));
Solving,use crate::core::literals::{Disjunction, Lits};
Solving,use crate::core::*;
Solving,use crate::model::lang::alternative::Alternative;
Solving,use crate::model::lang::{Atom, FAtom, IAtom, SAtom};
Solving,use crate::model::{Label, Model};
Solving,use crate::reif::{DifferenceExpression, ReifExpr, Reifiable};
Solving,use env_param::EnvParam;
Solving,use std::ops::Not;
Solving,use super::mul::EqMul;
Solving,use super::IVar;
Solving,static USE_EQUALITY_LOGIC: EnvParam<bool> = EnvParam::new("ARIES_USE_EQ_LOGIC", "false");
Solving,let lhs = lhs.into();
Solving,let rhs = rhs.into();
Solving,assert_eq!(lhs.denom, rhs.denom);
Solving,let lhs = lhs.into();
Solving,let rhs = rhs.into();
Solving,assert_eq!(lhs.denom, rhs.denom);
Solving,let lhs = lhs.into();
Solving,let rhs = rhs.into();
Solving,assert_eq!(lhs.denom, rhs.denom);
Solving,let lhs = lhs.into();
Solving,let rhs = rhs.into();
Solving,assert_eq!(lhs.kind(), rhs.kind());
Solving,let lhs = lhs.into();
Solving,let rhs = rhs.into();
Solving,assert_eq!(lhs.kind(), rhs.kind());
Solving,pub type Or = Disjunction;
Solving,pub struct And(Box<[Lit]>);
Solving,let negated_literals: Lits = value.0.iter().copied().map(|l| !l).collect();
Solving,let not_reified = ReifExpr::from(Disjunction::new(negated_literals));
Solving,pub struct Leq(IAtom, IAtom);
Solving,type Output = Leq;
Solving,let lhs = value.0;
Solving,let rhs = value.1;
Solving,let rhs_add = rhs.shift - lhs.shift;
Solving,let lhs: VarRef = lhs.var.into();
Solving,let rhs: VarRef = rhs.var.into();
Solving,pub struct Eq(Atom, Atom);
Solving,let a = self.0;
Solving,let b = self.1;
Solving,panic!("Attempting to build an equality between expression with incompatible types.");
Solving,use Atom::*;
Solving,let lr = model.reify(implies(a, b));
Solving,let rl = model.reify(implies(b, a));
Solving,let l = if a == b { Lit::TRUE } else { Lit::FALSE };
Solving,let var = x.var;
Solving,let value = v.sym.int_value();
Solving,let (lb, ub) = model.state.bounds(var);
Solving,let lr = model.reify(leq(a, b));
Solving,let rl = model.reify(leq(b, a));
Solving,pub struct Neq(Atom, Atom);
Solving,use crate::core::{IntCst, VarRef};
Solving,use crate::model::lang::{ConversionError, IAtom, IVar};
Solving,use num_rational::Ratio;
Solving,use std::cmp::Ordering;
Solving,use std::convert::{TryFrom, TryInto};
Solving,use std::fmt::Debug;
Solving,pub type Rational = Ratio<IntCst>;
Solving,assert_ne!(denom, 0);
Solving,type Output = FAtom;
Solving,type Output = FAtom;
Solving,write!(f, "?f{:?}", VarRef::from(self.num.var).to_u32(),)?;
Solving,write!(f, " + {}", self.num.shift as f32 / self.denom as f32)?;
Solving,pub struct Epsilon;
Solving,pub const EPSILON: Epsilon = Epsilon;
Solving,assert_ne!(denom, 0);
Solving,let num = IAtom::from(*value.numer());
Solving,type Error = ConversionError;
Solving,let num = IntCst::try_from(value.num)?;
Solving,type Error = ConversionError;
Solving,type Output = FAtom;
Solving,type Output = FAtom;
Solving,type Output = FAtom;
Solving,type Output = FAtom;
Solving,use crate::core::*;
Solving,use crate::model::lang::linear::LinearTerm;
Solving,use crate::model::lang::ConversionError;
Solving,use std::cmp::Ordering;
Solving,use std::convert::TryFrom;
Solving,use std::fmt::Debug;
Solving,pub struct IVar(VarRef);
Solving,pub const ZERO: IVar = IVar(VarRef::ZERO);
Solving,pub const ONE: IVar = IVar(VarRef::ONE);
Solving,};
Solving,let rhs = value - self.shift;
Solving,let rhs = value - self.shift;
Solving,type Error = ConversionError;
Solving,type Error = ConversionError;
Solving,type Output = IAtom;
Solving,type Output = IAtom;
Solving,type Output = IAtom;
Solving,type Output = IAtom;
Solving,type Output = LinearTerm;
Solving,use crate::core::*;
Solving,use crate::model::lang::{ConversionError, IAtom, IVar};
Solving,use crate::model::symbols::{SymId, TypedSym};
Solving,use crate::model::types::TypeId;
Solving,use std::convert::TryFrom;
Solving,use std::fmt::Debug;
Solving,type Error = ConversionError;
Solving,type Error = ConversionError;
Solving,type Error = ConversionError;
Solving,use crate::core::state::Term;
Solving,use crate::core::{IntCst, VarRef};
Solving,use crate::model::lang::{Atom, ConversionError, IAtom};
Solving,use crate::reif::ReifExpr;
Solving,use itertools::Itertools;
Solving,type Error = ConversionError;
Solving,.collect::<Result<Vec<_>, _>>()?;
Solving,.collect_vec();
Solving,use crate::core::state::Term;
Solving,use crate::core::*;
Solving,use crate::model::lang::IVar;
Solving,pub struct BVar(VarRef);
Solving,type Output = Lit;
Solving,use super::*;
Solving,use crate::core::*;
Solving,use crate::model::symbols::TypedSym;
Solving,pub const TRUE: Atom = Atom::Bool(Lit::TRUE);
Solving,pub const FALSE: Atom = Atom::Bool(Lit::FALSE);
Solving,type Error = ConversionError;
Solving,type Error = ConversionError;
Solving,type Error = ConversionError;
Solving,type Error = ConversionError;
Solving,type Error = ConversionError;
Solving,type Error = ConversionError;
Solving,use crate::transitive_conversions;
Solving,use fixed::Rational;
Solving,};
Solving,transitive_conversions!(Atom, IAtom, IVar);
Solving,transitive_conversions!(Atom, IAtom, IntCst);
Solving,transitive_conversions!(Atom, SAtom, SVar);
Solving,transitive_conversions!(Atom, SAtom, TypedSym);
Solving,transitive_conversions!(Atom, FAtom, Rational);
Solving,use crate::core::*;
Solving,use crate::reif::ReifExpr;
Solving,use std::collections::HashMap;
Solving,assert!(!self.full_map.contains_key(&e));
Solving,self.full_map.insert(e.clone(), lit);
Solving,self.full_inv.insert(lit, e.clone());
Solving,debug_assert!(e.negatable(), "Full reification of non-negatable expression");
Solving,self.full_map.insert(!e.clone(), !lit);
Solving,self.full_inv.insert(!lit, !e.clone());
Solving,assert!(!self.half_map.contains_key(&e));
Solving,self.half_map.insert(e.clone(), lit);
Solving,self.half_inv.insert(lit, e.clone());
Solving,use super::*;
Solving,use crate::model::lang::expr::{geq, leq};
Solving,use crate::model::lang::IVar;
Solving,const A: IVar = IVar::new(VarRef::from_u32(1));
Solving,const B: IVar = IVar::new(VarRef::from_u32(2));
Solving,const C: IVar = IVar::new(VarRef::from_u32(3));
Solving,let t = Lit::TRUE;
Solving,let f = Lit::FALSE;
Solving,let l1: ReifExpr = leq(A, B + 3).into();
Solving,let l2: ReifExpr = leq(A, C).into();
Solving,let mut reif = Reification::default();
Solving,reif.intern_full_as(l1.clone(), t);
Solving,reif.intern_full_as(l2.clone(), f);
Solving,assert_eq!(reif.interned_full(&l1), Some(t));
Solving,assert_eq!(reif.interned_full(&l2), Some(f));
Solving,let l1_prime = geq(B + 3, A).into();
Solving,assert_eq!(reif.interned_full(&l1_prime), Some(t));
Solving,assert_eq!(reif.interned_full(&(!l1.clone())), Some(f));
Solving,};
Solving,use std::fmt::{Debug, Formatter};
Solving,let factor1 = factor1.into();
Solving,let factor2 = factor2.into();
Solving,};
Solving,let lhs = lhs.into();
Solving,let rhs = rhs.into();
Solving,let lit = lit.into();
Solving,use crate::core::*;
Solving,use crate::model::lang::variables::Variable::*;
Solving,use crate::model::lang::{BVar, ConversionError, FVar, IVar, Kind, SVar};
Solving,use std::convert::TryFrom;
Solving,type Error = ConversionError;
Solving,type Error = ConversionError;
Solving,type Error = ConversionError;
Solving,use crate::core::state::Term;
Solving,use crate::core::{IntCst, SignedVar};
Solving,use crate::model::lang::IAtom;
Solving,use crate::reif::ReifExpr;
Solving,use itertools::Itertools;
Solving,use std::fmt::{Debug, Formatter};
Solving,let lhs_var = SignedVar::plus(em.lhs.var.variable());
Solving,let lhs_cst = em.lhs.shift;
Solving,.collect_vec();
Solving,let lhs_var = em.lhs.var.variable();
Solving,let lhs = SignedVar::minus(lhs_var);
Solving,let lhs_cst = em.lhs.shift;
Solving,.collect_vec();
Solving,write!(f, "{:?} = max ", self.lhs)?;
Solving,write!(f, "{:?}", self.var)?;
Solving,write!(f, " + {}", self.cst)?;
Solving,write!(f, " - {}", -self.cst)?;
Solving,use crate::core::IntCst;
Solving,use crate::model::lang::{Atom, ConversionError};
Solving,use crate::model::symbols::TypedSym;
Solving,use super::fixed::Rational;
Solving,type Error = ConversionError;
Solving,use crate::core::*;
Solving,use crate::model::extensions::PartialBoolAssignment;
Solving,fn entails(&self, literal: Lit) -> bool;
Solving,fn value(&self, literal: Lit) -> Option<bool>;
Solving,fn presence(&self, literal: Lit) -> Lit;
Solving,let mut found_undef = false;
Solving,let mut disjuncts = disjuncts.into_iter();
Solving,return false;
Solving,return disjuncts.all(|lit| !self.entails(lit));
Solving,let mut disjuncts = disjuncts.into_iter();
Solving,return false;
Solving,let pending = lit;
Solving,let mut count = 0;
Solving,count += 1;
Solving,return false;
Solving,return false;
Solving,return true;
Solving,use crate::core::state::{FixedDomain, IntDomain, OptDomain};
Solving,use crate::core::*;
Solving,use crate::model::extensions::SavedAssignment;
Solving,use crate::model::lang::linear::LinearSum;
Solving,use crate::model::lang::{Atom, Cst, IAtom, IVar, Rational, SAtom};
Solving,use crate::model::symbols::SymId;
Solving,use crate::model::symbols::{ContiguousSymbols, TypedSym};
Solving,use state::Term;
Solving,fn entails(&self, literal: Lit) -> bool;
Solving,fn var_domain(&self, var: impl Into<IAtom>) -> IntDomain;
Solving,fn presence_literal(&self, variable: impl Term) -> Lit;
Solving,let atom = atom.into();
Solving,let var = atom.variable();
Solving,let atom = atom.into();
Solving,let sum: LinearSum = sum.into();
Solving,let (l, u) = self.domain_of(t.var());
Solving,});
Solving,let atom = atom.into();
Solving,let base = self.var_domain(atom.var);
Solving,let atom = atom.into();
Solving,let (lb, ub) = self.domain_of(atom);
Solving,let prez = self.presence_literal(atom.var);
Solving,fn to_owned_assignment(&self) -> SavedAssignment;
Solving,let atom = atom.into();
Solving,let (lb, ub) = self.int_bounds(atom);
Solving,let lb = lb as usize;
Solving,let ub = ub as usize;
Solving,let atom = atom.into();
Solving,use crate::core::state::Term;
Solving,use crate::core::{IntCst, Lit, SignedVar, VarRef};
Solving,use crate::model::lang::{Atom, Cst, FAtom, IAtom, Rational, SAtom};
Solving,use crate::model::symbols::{SymId, TypedSym};
Solving,use std::collections::HashMap;
Solving,fn val(&self, var: VarRef) -> Option<IntCst>;
Solving,let svar = svar.into();
Solving,let mut res = Vec::with_capacity(atoms.len());
Solving,res.push(self.evaluate(*a)?);
Solving,pub struct InvalidAssignment;
Solving,};
Solving,s.add_var(VarRef::ZERO, 0).unwrap();
Solving,s.add_var(VarRef::ONE, 1).unwrap();
Solving,self.values.insert(var, val);
Solving,let atom = atom.into();
Solving,let value = value.into();
Solving,let var = ai.var.variable();
Solving,let value = i - ai.shift;
Solving,let ub = e.ub_value();
Solving,let int_value = v * e.denom;
Solving,return Err(InvalidAssignment);
Solving,let int_value = int_value.to_integer();
Solving,use crate::model::extensions::partial_assignment::{PartialAssignment, PartialAssignmentBuilder};
Solving,use crate::model::lang::{Atom, Cst};
Solving,use crate::model::Model;
Solving,assert_eq!(ass.evaluate(a.into()), Some(val.into()));
Solving,assert_eq!(ass.evaluate(a.into()), None);
Solving,let mut m: Model<&'static str> = Model::new();
Solving,let a = m.new_ivar(0, 10, "a");
Solving,let b = m.new_ivar(0, 10, "b");
Solving,let ass = &mut PartialAssignmentBuilder::new();
Solving,undef(ass, a);
Solving,undef(ass, b);
Solving,ass.add(a, 3).unwrap();
Solving,val(ass, a, 3);
Solving,val(ass, a + 1, 4);
Solving,val(ass, a - 2, 1);
Solving,undef(ass, b);
Solving,assert!(ass.add(a, 3).is_ok());
Solving,assert!(ass.add(a, 0).is_err());
Solving,mod assignments;
Solving,mod disjunction;
Solving,mod format;
Solving,pub mod partial_assignment;
Solving,pub use assignments::*;
Solving,pub use disjunction::*;
Solving,pub use format::*;
Solving,use state::Term;
Solving,use crate::core::state::{Domains, IntDomain};
Solving,use crate::core::*;
Solving,use crate::model::lang::IAtom;
Solving,fn entails(&self, literal: Lit) -> bool;
Solving,fn presence_literal(&self, variable: VarRef) -> Lit;
Solving,pub type SavedAssignment = Domains;
Solving,let int = int.into();
Solving,let (lb, ub) = self.bounds(int.var.into());
Solving,use crate::core::*;
Solving,use crate::model::label::Label;
Solving,use crate::model::lang::{Atom, FAtom, IAtom, IVar, Kind, SAtom, Type};
Solving,use crate::model::symbols::{SymId, SymbolTable};
Solving,use crate::model::types::TypeId;
Solving,use crate::model::ModelShape;
Solving,use crate::reif::{DifferenceExpression, ReifExpr};
Solving,use crate::utils::input::Sym;
Solving,use crate::utils::Fmt;
Solving,fn get_shape(&self) -> &ModelShape<Lbl>;
Solving,/// use aries::model::Model;
Solving,/// use aries::model::extensions::fmt;
Solving,/// let mut i = Model::<&'static str>::default();
Solving,/// let x = i.new_ivar(0, 10, "X");
Solving,/// let y = x + 10;
Solving,/// println!("x: {}", fmt(x, &i));
Solving,/// println!("y: {}", fmt(y, &i));
Solving,let atom = atom.into();
Solving,let tpe = ctx.get_type(b.variable());
Solving,let t = b.variable().geq(1);
Solving,debug_assert_eq!(b, !t);
Solving,write!(f, "!")?;
Solving,// let tpe = tpe.unwrap_or(Type::Int);
Solving,let kind = tpe.map(Kind::from).unwrap_or(Kind::Int);
Solving,format_impl_var(ctx, b.variable(), kind, f)?;
Solving,write!(f, "(+ ")?;
Solving,write!(f, "(- ")?;
Solving,format_impl_var(ctx, v.into(), Kind::Int, f)?;
Solving,write!(f, " {})", i.shift.abs())?;
Solving,write!(f, "(/ ")?;
Solving,format_impl_int(ctx, i.num, f)?;
Solving,};
Solving,format_impl_var(ctx, *b, Kind::Sym, f)?;
Solving,write!(f, " - ")?;
Solving,format_impl_var(ctx, *a, Kind::Sym, f)?;
Solving,format_impl_var(ctx, *v1, Kind::Sym, f)?;
Solving,write!(f, " = ")?;
Solving,format_impl_var(ctx, *v1, Kind::Sym, f)?;
Solving,write!(f, " != ")?;
Solving,format_impl_var(ctx, *v1, Kind::Sym, f)?;
Solving,let sym_id = SymId::from_u32(*v2 as u32);
Solving,let sym = ctx.get_symbol(sym_id);
Solving,format_impl_var(ctx, *v1, Kind::Sym, f)?;
Solving,let sym_id = SymId::from_u32(*v2 as u32);
Solving,let sym = ctx.get_symbol(sym_id);
Solving,pub mod alternative;
Solving,mod atom;
Solving,mod boolean;
Solving,mod cst;
Solving,pub mod expr;
Solving,mod fixed;
Solving,mod int;
Solving,pub mod linear;
Solving,pub mod max;
Solving,pub mod mul;
Solving,pub mod reification;
Solving,mod sym;
Solving,mod validity_scope;
Solving,mod variables;
Solving,pub use atom::Atom;
Solving,pub use boolean::BVar;
Solving,pub use cst::Cst;
Solving,pub use fixed::{FAtom, FVar, Rational};
Solving,pub use int::{IAtom, IVar};
Solving,pub use validity_scope::*;
Solving,use crate::core::{IntCst, INT_CST_MAX, INT_CST_MIN};
Solving,use crate::model::types::TypeId;
Solving,pub use sym::{SAtom, SVar};
Solving,pub use variables::Variable;
Solving,};
Solving,type Error = ConversionError;
Solving,};
Solving,};
Solving,use super::*;
Solving,type Model = crate::model::Model<&'static str>;
Solving,assert_eq!(m.fmt(x).to_string(), result);
Solving,let mut m = Model::new();
Solving,let a = m.new_ivar(0, 10, "a");
Solving,check(&m, a, "a");
Solving,let b = m.new_ivar(0, 10, "b");
Solving,let x = b + 1;
Solving,check(&m, x, "(+ b 1)");
Solving,let x = b - 1;
Solving,check(&m, x, "(- b 1)");
Solving,let x = x + 1;
Solving,check(&m, x, "b");
Solving,// let x = m.leq(a + 1, 6);
Solving,// check(&m, x, "(<= (+ a 1) 6)");
Solving,// let x = m.eq(a - 3, b);
Solving,// check(&m, x, "(= (- a 3) b)");
Solving,// let x = m.implies(true, x);
Solving,mod label;
Solving,mod model_impl;
Solving,pub use label::Label;
Solving,pub use model_impl::*;
Solving,pub mod extensions;
Solving,pub mod lang;
Solving,pub mod symbols;
Solving,pub mod types;
Solving,use crate::collections::ref_store::RefMap;
Solving,use crate::core::*;
Solving,use std::collections::HashMap;
Solving,use std::fmt::{Debug, Display};
Solving,use std::hash::Hash;
Solving,use std::sync::Arc;
Solving,let label = label.into();
Solving,self.labels.insert(var, label.clone());
Solving,.or_insert_with(|| Vec::with_capacity(1));
Solving,vars.push(var);
Solving,pub mod backtrack;
Solving,pub mod collections;
Solving,pub mod core;
Solving,pub mod model;
Solving,pub mod reasoners;
Solving,pub mod reif;
Solving,pub mod solver;
Solving,pub mod utils;
Solving,use crate::backtrack::EventIndex;
Solving,use crate::core::state::{DirectOrigin, Origin, ValueCause};
Solving,use crate::core::*;
Solving,pub type ChangeIndex = Option<EventIndex>;
Solving,debug_assert_eq!(self.affected_bound, lit.svar());
Solving,use crate::backtrack::{Backtrack, BacktrackWith, DecLvl, EventIndex, ObsTrail};
Solving,use crate::collections::ref_store::RefVec;
Solving,use crate::core::state::cause::Origin;
Solving,use crate::core::state::event::{ChangeIndex, Event};
Solving,use crate::core::state::InvalidUpdate;
Solving,use crate::core::*;
Solving,};
Solving,let zero = uninitialized.new_var(0, 0);
Solving,let one = uninitialized.new_var(1, 1);
Solving,debug_assert_eq!(zero, VarRef::ZERO);
Solving,debug_assert_eq!(one, VarRef::ONE);
Solving,debug_assert!(uninitialized.entails(Lit::TRUE));
Solving,debug_assert!(!uninitialized.entails(Lit::FALSE));
Solving,);
Solving,let var_lb = self.bounds.push(ValueCause::new(-lb, None));
Solving,let var_ub = self.bounds.push(ValueCause::new(ub, None));
Solving,debug_assert_eq!(var_lb.variable(), var_ub.variable());
Solving,debug_assert!(var_lb.is_minus());
Solving,debug_assert!(var_ub.is_plus());
Solving,let var = var_lb.variable();
Solving,self.events.push(Event::initial_upper_bound(var, ub));
Solving,self.events.push(Event::initial_lower_bound(var, lb));
Solving,debug_assert_eq!(self.lb(var), lb);
Solving,debug_assert_eq!(self.ub(var), ub);
Solving,let current = self.bounds[affected];
Solving,let lit = affected.leq(new_ub);
Solving,self.bounds[affected] = ValueCause::new(new_ub, Some(self.events.next_slot()));
Solving,};
Solving,// println!("UPDATE: {lit:?} {cause:?}");
Solving,self.events.push(event);
Solving,// println!("INVALID UPDATE: {lit:?} {cause:?}");
Solving,debug_assert!(self.bounds.len().is_multiple_of(2));
Solving,let lb = self.lb(v);
Solving,let ub = self.ub(v);
Solving,debug_assert!(self.entails(lit));
Solving,let mut cur = self.bounds[lit.svar()].cause;
Solving,let ev = self.events.get_event(loc);
Solving,break;
Solving,type Item = (IntCst, Option<EventIndex>);
Solving,let ev = self.doms.events.get_event(loc);
Solving,self.next = Next::None;
Solving,};
Solving,bounds[ev.affected_bound] = ev.previous;
Solving,let ev = self.events.pop().unwrap();
Solving,let bounds = &mut self.bounds;
Solving,Self::undo_event(bounds, &ev);
Solving,let bounds = &mut self.bounds;
Solving,Self::undo_event(bounds, ev);
Solving,use super::*;
Solving,let mut m = IntDomains::default();
Solving,let a = m.new_var(0, 10);
Solving,assert_eq!(m.lb(a), 0);
Solving,assert_eq!(m.ub(a), 10);
Solving,assert!(m.entails(a.geq(-2)));
Solving,assert!(m.entails(a.geq(-1)));
Solving,assert!(m.entails(a.geq(0)));
Solving,assert!(!m.entails(a.geq(1)));
Solving,assert!(!m.entails(a.geq(2)));
Solving,assert!(!m.entails(a.geq(10)));
Solving,assert!(m.entails(a.leq(12)));
Solving,assert!(m.entails(a.leq(11)));
Solving,assert!(m.entails(a.leq(10)));
Solving,assert!(!m.entails(a.leq(9)));
Solving,assert!(!m.entails(a.leq(8)));
Solving,assert!(!m.entails(a.leq(0)));
Solving,let mut m = IntDomains::default();
Solving,let a = m.new_var(0, 10);
Solving,let b = m.new_var(1, 1);
Solving,let c = m.new_var(3, 7);
Solving,let vars: Vec<VarRef> = m.variables().collect();
Solving,assert_eq!(vars, vec![VarRef::ZERO, VarRef::ONE, a, b, c]);
Solving,use crate::backtrack::{DecLvl, EventIndex};
Solving,use crate::core::state::{Domains, Event, Term};
Solving,use crate::core::{IntCst, Lit, SignedVar};
Solving,let next_event = domains.implying_event(lit).unwrap();
Solving,let var = var.into();
Solving,/// Returns true if the given literal is entailed by the current state;
Solving,let curr_ub = self.ub(lit.svar());
Solving,debug_assert!(self.entails(l));
Solving,use super::*;
Solving,use crate::backtrack::Backtrack;
Solving,use crate::core::state::{Cause, InferenceCause};
Solving,use crate::reasoners::ReasonerId;
Solving,});
Solving,let max = 77;
Solving,let doms = &mut Domains::new();
Solving,let va = doms.new_var(0, max);
Solving,let vb = doms.new_var(0, max);
Solving,let view = DomainsSnapshot::current(doms);
Solving,assert_eq!(view.ub(va), max);
Solving,assert_eq!(view.ub(vb), max);
Solving,assert_eq!(view.lb(va), 0);
Solving,assert_eq!(view.lb(vb), 0);
Solving,doms.save_state();
Solving,doms.set_lb(va, i, Cause::Decision).unwrap();
Solving,doms.set_ub(va, max - 2 * i, INFERENCE).unwrap();
Solving,doms.save_state();
Solving,doms.set_lb(vb, 5 * i, Cause::Decision).unwrap();
Solving,doms.restore_last();
Solving,doms.save_state();
Solving,doms.set_lb(vb, 2 * i, Cause::Decision).unwrap();
Solving,doms.set_ub(vb, max - i, INFERENCE).unwrap();
Solving,let view = DomainsSnapshot::current(doms);
Solving,assert_eq!(view.lb(va), i);
Solving,assert_eq!(view.ub(vb), max - i);
Solving,let view = DomainsSnapshot::preceding(doms, Lit::geq(va, j));
Solving,assert_eq!(view.lb(va), j - 1);
Solving,assert_eq!(view.ub(vb), max - j + 1);
Solving,let view = DomainsSnapshot::preceding(doms, Lit::leq(vb, max - j));
Solving,assert_eq!(view.lb(va), j);
Solving,assert_eq!(view.ub(vb), max - j + 1);
Solving,use itertools::Itertools;
Solving,use crate::backtrack::{Backtrack, DecLvl, DecisionLevelClass, EventIndex, ObsTrail};
Solving,use crate::collections::ref_store::RefMap;
Solving,use crate::core::literals::{Disjunction, DisjunctionBuilder, ImplicationGraph, LitSet};
Solving,use crate::core::state::cause::{DirectOrigin, Origin};
Solving,use crate::core::state::event::Event;
Solving,use crate::core::state::int_domains::IntDomains;
Solving,use crate::core::state::{Cause, DomainsSnapshot, Explainer, Explanation, ExplanationQueue, InvalidUpdate, OptDomain};
Solving,use crate::core::*;
Solving,use std::fmt::{Debug, Formatter};
Solving,use super::IntDomain;
Solving,pub mod witness;
Solving,mod minimize;
Solving,};
Solving,debug_assert!(domains.entails(Lit::TRUE));
Solving,debug_assert!(!domains.entails(Lit::FALSE));
Solving,assert_eq!(self.presence(from.variable()), Lit::TRUE, "Implication only supported between non-optional variables");
Solving,assert_eq!(self.presence(to.variable()), Lit::TRUE, "Implication only supported between non-optional variables");
Solving,self.implications.add_implication(from, to);
Solving,let prop_result = self.set_impl(to, DirectOrigin::ImplicationPropagation(from));
Solving,assert!(prop_result.is_ok(), "{}", "Inconsistency on the addition of implies({from:?}, {to:?}");
Solving,let prop_result = self.set_impl(!from, DirectOrigin::ImplicationPropagation(!to));
Solving,assert!(prop_result.is_ok(), "{}", "Inconsistency on the addition of implies({from:?}, {to:?}");
Solving,let lit = self.new_var(0, 1).geq(1);
Solving,self.add_implication(lit, scope);
Solving,);
Solving,let var = self.new_var(lb, ub);
Solving,self.presence.insert(var, presence);
Solving,let prez_a = self.presence(a);
Solving,let prez_b = self.presence(b);
Solving,return true;
Solving,let presence = self.presence(term.variable());
Solving,let var = var.into();
Solving,let (lb, ub) = self.bounds(var);
Solving,let prez = self.presence(var);
Solving,let (lb, ub) = self.bounds(var.into());
Solving,debug_assert!(!self.doms.entails(lit) || !self.doms.entails(!lit));
Solving,let prez = self.presence(affected.variable());
Solving,debug_assert_ne!(prez, Lit::TRUE);
Solving,.is_none());
Solving,let new_bound = affected.leq(new_ub);
Solving,let res = self.doms.set_upper_bound(affected, new_ub, cause);
Solving,debug_assert!(res.is_ok());
Solving,};
Solving,let not_prez = !prez;
Solving,let mut cursor = self.trail().reader();
Solving,cursor.move_to_end(self.trail());
Solving,debug_assert_eq!(self.presence(affected.variable()), Lit::TRUE);
Solving,let res = self.doms.set_upper_bound(affected, new_ub, cause);
Solving,debug_assert_eq!(cursor.num_pending(self.trail()), 1);
Solving,let lit = ev.new_literal();
Solving,debug_assert_eq!(self.presence(lit.variable()), Lit::TRUE);
Solving,)?;
Solving,debug_assert_eq!(lit, affected.leq(new_ub));
Solving,debug_assert_eq!(fail_cause, cause);
Solving,let res = self.set(literal, cause);
Solving,debug_assert!(res.is_ok());
Solving,let res = self.set_upper_bound(affected, new_ub, cause);
Solving,debug_assert!(res.is_ok());
Solving,debug_assert!(self.entails(lit));
Solving,let InvalidUpdate(literal, cause) = failed;
Solving,);
Solving,debug_assert!(!self.entails(literal));
Solving,debug_assert!(self.entails(!literal));
Solving,debug_assert!(self.entails(self.presence(literal.variable())));
Solving,let mut explanation = Explanation::with_capacity(2);
Solving,explanation.push(!literal);
Solving,explanation.push(self.presence(literal));
Solving,self.add_implying_literals_to_explanation(literal, cause, &mut explanation, explainer);
Solving,debug_assert!(explanation.literals().iter().all(|&l| self.entails(l)));
Solving,debug_assert!(explanation.literals().iter().all(|&l| self.entails(l)));
Solving,let mut explanation = explanation;
Solving,self.queue.clear();
Solving,let mut result: DisjunctionBuilder = DisjunctionBuilder::with_capacity(32);
Solving,let decision_level = self.current_decision_level();
Solving,let mut resolved = LitSet::new();
Solving,debug_assert!(self.entails(l));
Solving,debug_assert!(explanation.lits.is_empty());
Solving,debug_assert!(decision_level != DecLvl::ROOT || result.is_empty());
Solving,break result.into();
Solving,debug_assert!(!self.queue.is_empty());
Solving,let (l, l_cause) = self.queue.pop().unwrap();
Solving,debug_assert!(self.queue.is_empty());
Solving,result.push(!l);
Solving,break result.build();
Solving,debug_assert!(l_cause < self.trail().next_slot());
Solving,debug_assert!(self.entails(l));
Solving,let mut cause = None;
Solving,debug_assert_ne!(self.last_event().unwrap().cause, Origin::DECISION);
Solving,let x = self.undo_last_event();
Solving,cause = Some(x);
Solving,let cause = cause.unwrap();
Solving,resolved.insert(l);
Solving,self.add_implying_literals_to_explanation(l, cause, &mut explanation, explainer);
Solving,};
Solving,let clause = minimize::minimize_clause(clause, self, explainer);
Solving,debug_assert!(!witness::pruned_by_clause(&clause), "Post minimization: {clause:?}");
Solving,debug_assert!(explanation.literals().iter().all(|&l| self.entails(l)));
Solving,let mut result = LitSet::new();
Solving,self.queue.clear();
Solving,let ev = self.trail().get_event(loc);
Solving,result.insert(ev.new_literal());
Solving,panic!("Unexpected decision in trail, when trying to extract an unsat core");
Solving,debug_assert_eq!(self.entailing_level(l), DecLvl::ROOT);
Solving,debug_assert!(self.entails(l));
Solving,self.queue.push(loc, l);
Solving,debug_assert!(explanation.lits.is_empty());
Solving,break;
Solving,let (lit, _) = self.queue.pop().unwrap();
Solving,let implying_lits = self.implying_literals(lit, explainer).expect("Encountered ");
Solving,explanation.extend(implying_lits);
Solving,let InvalidUpdate(literal, cause) = failed;
Solving,);
Solving,let mut base_unsat_core = None;
Solving,let mut base_conflict = Explanation::from(vec![!literal, self.presence(literal)]);
Solving,base_unsat_core = Some(literal);
Solving,self.add_implying_literals_to_explanation(literal, cause, &mut base_conflict, explainer);
Solving,let mut unsat_core = self.extract_assumptions_implying(base_conflict, explainer);
Solving,unsat_core.push(base_literal);
Solving,let explanation = Explanation::from(conflict.clause.literals().iter().map(|&l| !l).collect_vec());
Solving,let mut decs = Vec::new();
Solving,let mut lvl = DecLvl::ROOT + 1;
Solving,decs.push((lvl, e.new_literal()));
Solving,lvl += 1;
Solving,let mut assumptions = Vec::new();
Solving,let mut lvl = DecLvl::ROOT + 1;
Solving,assumptions.push(e.new_literal());
Solving,lvl += 1;
Solving,let state = DomainsSnapshot::current(self);
Solving,debug_assert!(!state.entails(literal));
Solving,explainer.explain(cause, literal, state, explanation);
Solving,debug_assert!(state.entails(!invalid_lit));
Solving,explanation.push(!invalid_lit);
Solving,explanation.push(invalid_lit);
Solving,explainer.explain(cause, invalid_lit, state, explanation);
Solving,explanation.push(causing_literal);
Solving,debug_assert!(self.entails(literal));
Solving,return Some(Vec::new());
Solving,};
Solving,let event = self.get_event(event);
Solving,let mut explanation = Explanation::new();
Solving,let state = &DomainsSnapshot::preceding(self, literal);
Solving,);
Solving,fn variable(self) -> VarRef;
Solving,use crate::backtrack::Backtrack;
Solving,use crate::core::state::domains::Domains;
Solving,use crate::core::state::*;
Solving,use crate::core::*;
Solving,use crate::reasoners::ReasonerId;
Solving,use std::collections::HashSet;
Solving,let mut domains = Domains::default();
Solving,let p1 = domains.new_presence_literal(Lit::TRUE);
Solving,let p2 = domains.new_presence_literal(p1);
Solving,let i = domains.new_optional_var(0, 10, p2);
Solving,assert_eq!(domains.bounds(p1.variable()), (lp1, up1));
Solving,assert_eq!(domains.bounds(p2.variable()), (lp2, up2));
Solving,assert_eq!(domains.bounds(i), (li, ui));
Solving,};
Solving,check_doms(&domains, 0, 1, 0, 1, 0, 10);
Solving,assert_eq!(domains.set_lb(i, 5, Cause::Decision), Ok(true));
Solving,check_doms(&domains, 0, 1, 0, 1, 5, 10);
Solving,assert_eq!(domains.set_ub(i, 5, Cause::Decision), Ok(true));
Solving,check_doms(&domains, 0, 1, 0, 1, 5, 5);
Solving,assert_eq!(domains.set_lb(i, 6, Cause::Decision), Ok(true));
Solving,check_doms(&domains, 0, 1, 0, 0, 5, 5);
Solving,assert_eq!(domains.set(p1, Cause::Decision), Ok(true));
Solving,check_doms(&domains, 1, 1, 0, 0, 5, 5);
Solving,assert!(matches!(domains.set(p2, Cause::Decision), Err(InvalidUpdate(_, _))));
Solving,let mut domains = Domains::new();
Solving,let p = domains.new_var(0, 1);
Solving,let p1 = domains.new_optional_var(0, 1, p.geq(1));
Solving,let p2 = domains.new_optional_var(0, 1, p.geq(1));
Solving,assert!(domains.always_present_together(p1, p2));
Solving,assert!(!domains.always_present_together(p, p1));
Solving,assert!(!domains.always_present_together(p, p2));
Solving,assert!(domains.always_present_together(p, p));
Solving,assert!(domains.only_present_with(p, p));
Solving,assert!(domains.always_present_together(p1, p1));
Solving,assert!(domains.only_present_with(p1, p1));
Solving,assert!(domains.only_present_with(p1, p));
Solving,assert!(domains.only_present_with(p2, p));
Solving,assert!(domains.only_present_with(p1, p2));
Solving,assert!(domains.only_present_with(p2, p1));
Solving,assert!(!domains.only_present_with(p, p1));
Solving,assert!(!domains.only_present_with(p, p2));
Solving,let x = domains.new_var(0, 1);
Solving,let x1 = domains.new_optional_var(0, 1, x.geq(1));
Solving,assert!(domains.only_present_with(x1, x));
Solving,assert!(!domains.only_present_with(x, x1));
Solving,assert!(domains.always_present_together(p, x));
Solving,assert!(domains.only_present_with(p1, x));
Solving,assert!(domains.only_present_with(x1, p));
Solving,assert!(!domains.only_present_with(p1, x1));
Solving,assert!(!domains.only_present_with(x1, p1));
Solving,let mut model = Domains::new();
Solving,let a = model.new_var(0, 10);
Solving,assert_eq!(model.set_lb(a, -1, Cause::Decision), Ok(false));
Solving,assert_eq!(model.set_lb(a, 0, Cause::Decision), Ok(false));
Solving,assert_eq!(model.set_lb(a, 1, Cause::Decision), Ok(true));
Solving,assert_eq!(model.set_ub(a, 11, Cause::Decision), Ok(false));
Solving,assert_eq!(model.set_ub(a, 10, Cause::Decision), Ok(false));
Solving,assert_eq!(model.set_ub(a, 9, Cause::Decision), Ok(true));
Solving,assert_eq!(model.bounds(a), (1, 9));
Solving,model.save_state();
Solving,assert_eq!(model.set_lb(a, 9, Cause::Decision), Ok(true));
Solving,);
Solving,model.restore_last();
Solving,assert_eq!(model.bounds(a), (1, 9));
Solving,assert_eq!(model.set_ub(a, 1, Cause::Decision), Ok(true));
Solving,);
Solving,let mut model = Domains::new();
Solving,let a = Lit::geq(model.new_var(0, 1), 1);
Solving,let b = Lit::geq(model.new_var(0, 1), 1);
Solving,let n = model.new_var(0, 10);
Solving,let writer = ReasonerId::Sat;
Solving,let cause_a = Cause::inference(writer, 0u32);
Solving,let cause_b = Cause::inference(writer, 1u32);
Solving,model.set_ub(n, 4, cause_a)?;
Solving,model.set_lb(n, 5, cause_b)?;
Solving,};
Solving,assert_eq!(cause.writer, ReasonerId::Sat);
Solving,assert_eq!(literal, Lit::leq(self.n, 4));
Solving,explanation.push(self.a);
Solving,assert_eq!(literal, Lit::geq(self.n, 5));
Solving,explanation.push(self.b);
Solving,let mut network = Expl { a, b, n };
Solving,propagate(&mut model).unwrap();
Solving,model.save_state();
Solving,model.decide(a).unwrap();
Solving,assert_eq!(model.bounds(a.variable()), (1, 1));
Solving,propagate(&mut model).unwrap();
Solving,assert_eq!(model.domain(n), OptDomain::Present(0, 4));
Solving,model.save_state();
Solving,model.set_lb(n, 1, Cause::Decision).unwrap();
Solving,model.save_state();
Solving,model.decide(b).unwrap();
Solving,};
Solving,let clause = model.clause_for_invalid_inferrence(err, &mut network);
Solving,let clause: HashSet<_> = clause.literals().iter().copied().collect();
Solving,let mut expected = HashSet::new();
Solving,expected.insert(!b);
Solving,expected.insert(Lit::gt(n, 4));
Solving,assert_eq!(clause, expected);
Solving,let mut model = Domains::new();
Solving,let p = model.new_var(0, 1);
Solving,let i = model.new_optional_var(0, 10, p.geq(1));
Solving,let x = model.new_var(0, 10);
Solving,model.save_state();
Solving,assert_eq!(model.set_lb(p, 1, Cause::Decision), Ok(true));
Solving,model.save_state();
Solving,assert_eq!(model.set_ub(i, 5, Cause::Decision), Ok(true));
Solving,model.save_state();
Solving,assert_eq!(model.set_ub(x, 5, Cause::Decision), Ok(true));
Solving,model.save_state();
Solving,assert!(model.set_lb(i, 6, Cause::Decision).is_err());
Solving,let mut model = Domains::new();
Solving,let a = Lit::geq(model.new_var(0, 1), 1);
Solving,let b = Lit::geq(model.new_var(0, 1), 1);
Solving,let c = Lit::geq(model.new_var(0, 1), 1);
Solving,let d = Lit::geq(model.new_var(0, 1), 1);
Solving,let e = Lit::geq(model.new_var(0, 1), 1);
Solving,let f = Lit::geq(model.new_var(0, 1), 1);
Solving,let g = Lit::geq(model.new_var(0, 1), 1);
Solving,let h = Lit::geq(model.new_var(0, 1), 1);
Solving,let writer = ReasonerId::Sat;
Solving,let cause_a = Cause::inference(writer, 0u32);
Solving,let cause_bc = Cause::inference(writer, 1u32);
Solving,let cause_f = Cause::inference(writer, 2u32);
Solving,let cause_e = Cause::inference(writer, 3u32);
Solving,let cause_g = Cause::inference(writer, 4u32);
Solving,model.set(c, cause_a)?;
Solving,model.set(f, cause_bc)?;
Solving,model.set(h.not(), cause_f)?;
Solving,model.set(e, cause_e)?;
Solving,model.set(h, cause_g)?;
Solving,};
Solving,assert_eq!(cause.writer, ReasonerId::Sat);
Solving,assert_eq!(literal, self.c);
Solving,explanation.push(self.a);
Solving,assert_eq!(literal, self.f);
Solving,explanation.push(self.b);
Solving,explanation.push(self.c);
Solving,assert_eq!(literal, self.h.not());
Solving,explanation.push(self.f);
Solving,assert_eq!(literal, self.e);
Solving,explanation.push(self.d);
Solving,assert_eq!(literal, self.h);
Solving,explanation.push(self.g);
Solving,let mut network = Expl { a, b, c, d, e, f, g, h };
Solving,propagate(&mut model).unwrap();
Solving,model.save_state();
Solving,assert!(model.assume(a).unwrap());
Solving,assert_eq!(model.bounds(a.variable()), (1, 1));
Solving,propagate(&mut model).unwrap();
Solving,assert_eq!(model.bounds(c.variable()), (1, 1));
Solving,model.save_state();
Solving,assert!(model.assume(b).unwrap());
Solving,assert_eq!(model.bounds(b.variable()), (1, 1));
Solving,propagate(&mut model).unwrap();
Solving,assert_eq!(model.bounds(f.variable()), (1, 1));
Solving,assert_eq!(model.bounds(h.variable()), (0, 0));
Solving,model.save_state();
Solving,assert!(model.assume(d).unwrap());
Solving,assert_eq!(model.bounds(d.variable()), (1, 1));
Solving,propagate(&mut model).unwrap();
Solving,assert_eq!(model.bounds(e.variable()), (1, 1));
Solving,model.save_state();
Solving,model.assume(g).unwrap();
Solving,assert_eq!(model.bounds(g.variable()), (1, 1));
Solving,};
Solving,.lits;
Solving,let unsat_core_set: HashSet<Lit> = unsat_core.iter().copied().collect();
Solving,let mut expected = HashSet::new();
Solving,expected.insert(a);
Solving,expected.insert(b);
Solving,expected.insert(g);
Solving,assert_eq!(unsat_core_set, expected);
Solving,let mut model = Domains::new();
Solving,let x = model.new_var(0, 10);
Solving,let y = model.new_var(0, 10);
Solving,let writer = ReasonerId::Sat;
Solving,let cause_xleq5 = Cause::inference(writer, 0u32);
Solving,model.set(y.geq(6), cause_xleq5)?;
Solving,};
Solving,assert_eq!(cause.writer, ReasonerId::Sat);
Solving,explanation.push(self.x.leq(5));
Solving,let mut network = Expl { x, y };
Solving,propagate(&mut model).unwrap();
Solving,model.save_state();
Solving,assert!(model.assume(x.leq(3)).unwrap());
Solving,assert_eq!(model.bounds(x.variable()), (0, 3));
Solving,propagate(&mut model).unwrap();
Solving,assert_eq!(model.bounds(y.variable()), (6, 10));
Solving,model.save_state();
Solving,let err = model.assume(y.leq(4)).unwrap_err();
Solving,.lits;
Solving,let unsat_core_set: HashSet<Lit> = unsat_core.iter().copied().collect();
Solving,let mut expected = HashSet::new();
Solving,expected.insert(y.leq(4));
Solving,assert_eq!(unsat_core_set, expected);
Solving,};
Solving,use std::fmt::{Display, Formatter};
Solving,type Output = IntDomain;
Solving,];
Solving,let ub = max(&potential_extrema).clamp(INT_CST_MIN, INT_CST_MAX);
Solving,let lb = min(&potential_extrema).clamp(INT_CST_MIN, INT_CST_MAX);
Solving,use crate::core::state::Domains;
Solving,use std::cell::RefCell;
Solving,use crate::core::literals::Disjunction;
Solving,static SOLUTION_WITNESS: RefCell<Option<Domains>> = const { RefCell::new(None) };
Solving,SOLUTION_WITNESS.with(|w| *w.borrow_mut() = Some(sol.clone()));
Solving,SOLUTION_WITNESS.with(|w| *w.borrow_mut() = None);
Solving,pub struct WitnessCleaner;
Solving,return false;
Solving,use itertools::Itertools;
Solving,use crate::backtrack::{DecLvl, EventIndex};
Solving,use crate::core::literals::LitSet;
Solving,use crate::core::state::{Domains, Explainer, Explanation, Origin};
Solving,use crate::core::Lit;
Solving,use std::collections::HashSet;
Solving,use super::literals::Disjunction;
Solving,use super::state::ExplanationQueue;
Solving,.collect_vec();
Solving,let decision_levels: HashSet<_> = elems.iter().map(|e| e.dl).collect();
Solving,let mut res = State::default();
Solving,let mut next = 0;
Solving,let first_on_level = elems[next];
Solving,let level = first_on_level.dl;
Solving,let mut last_on_level = next;
Solving,last_on_level += 1;
Solving,let on_level = &elems[next..=last_on_level];
Solving,res.mark_redundant(e.lit);
Solving,res.add(uip);
Solving,let l = e.lit;
Solving,res.add(l);
Solving,let redundant = res.check_redundant(l, doms, explainer, &decision_levels);
Solving,res.add(l);
Solving,next = last_on_level + 1;
Solving,self.clause.push(!l);
Solving,self.mark_redundant(l);
Solving,self.not_redundant_negs.insert(!l);
Solving,return known_result;
Solving,let mut depth = 1;
Solving,self.queue.clear();
Solving,self.queue.push((1, l));
Solving,self.mark_redundant(l);
Solving,depth -= 1;
Solving,self.queue.pop();
Solving,debug_assert_eq!(d, depth);
Solving,let dec_lvl = doms.entailing_level(cur);
Solving,self.mark_redundant(cur);
Solving,self.mark_not_redundant(cur);
Solving,};
Solving,let event = doms.get_event(event);
Solving,self.mark_not_redundant(cur);
Solving,});
Solving,self.queue.pop();
Solving,self.mark_not_redundant(l);
Solving,depth = d;
Solving,break false;
Solving,self.queue.push((depth + 1, antecedant));
Solving,depth += 1;
Solving,break true;
Solving,return Some(lits[0].lit);
Solving,debug_assert!(lits.len() > 1);
Solving,debug_assert!(lits.iter().all(|l| doms.entails(l.lit)));
Solving,let decision_level = lits[0].dl;
Solving,debug_assert!(lits.iter().all(|e| e.dl == decision_level));
Solving,let mut explanation = Explanation::with_capacity(64);
Solving,explanation.push(e.lit);
Solving,self.uip_queue.clear();
Solving,debug_assert!(doms.entails(l));
Solving,self.uip_queue.push(loc, l);
Solving,debug_assert!(doms.trail().decision_level(loc) < decision_level);
Solving,let redundant = self.check_redundant(l, doms, explainer, decision_levels);
Solving,return None;
Solving,debug_assert!(explanation.lits.is_empty());
Solving,debug_assert!(!self.uip_queue.is_empty());
Solving,let (l, _) = self.uip_queue.pop().unwrap();
Solving,return Some(l);
Solving,let antecedants = doms.implying_literals(l, explainer).unwrap();
Solving,use crate::core::Lit;
Solving,use crate::reasoners::ReasonerId;
Solving,pub const DECISION: Origin = Origin::Direct(DirectOrigin::Decision);
Solving,pub const ASSUMPTION: Origin = Origin::Direct(DirectOrigin::Assumption);
Solving,use crate::backtrack::EventIndex;
Solving,use crate::core::state::{DomainsSnapshot, InferenceCause};
Solving,use crate::core::Lit;
Solving,use std::collections::BinaryHeap;
Solving,self.lits.extend(additional_lits);
Solving,self.lits.clear();
Solving,fn explain(&mut self, cause: InferenceCause, literal: Lit, model: &DomainsSnapshot, explanation: &mut Explanation);
Solving,pub struct SingleTheoryExplainer<'a, T: crate::reasoners::Theory>(pub &'a mut T);
Solving,assert_eq!(cause.writer, self.0.identity());
Solving,return None;
Solving,let mut l = self.heap.pop().unwrap();
Solving,let l2 = self.heap.pop().unwrap();
Solving,l = l2;
Solving,debug_assert!(l.lit.entails(l2.lit));
Solving,break;
Solving,use crate::core::literals::Lits;
Solving,use crate::core::*;
Solving,use std::borrow::Borrow;
Solving,use std::cmp::Reverse;
Solving,use std::fmt::{Debug, Formatter};
Solving,use std::ops::Deref;
Solving,literals.simplify_disjunctive();
Solving,let disj = Disjunction::new(literals);
Solving,return false;
Solving,return true;
Solving,let l1 = self.literals[i + 1];
Solving,let l2 = self.literals[i];
Solving,debug_assert!(l1 < l2, "clause is not sorted");
Solving,debug_assert!(l1.svar().is_minus());
Solving,debug_assert!(l2.svar().is_plus());
Solving,return true;
Solving,self.literals.retain(f);
Solving,type Item = Lit;
Solving,type IntoIter = <&'a Lits as IntoIterator>::IntoIter;
Solving,type Item = Lit;
Solving,type IntoIter = <Lits as IntoIterator>::IntoIter;
Solving,type Target = [Lit];
Solving,return;
Solving,return;
Solving,self.lits.elems.resize(1, Lit::TRUE);
Solving,self.lits[0] = Lit::TRUE;
Solving,self.lits.push(lit);
Solving,use std::collections::BTreeSet;
Solving,use super::*;
Solving,use rand::seq::SliceRandom;
Solving,use rand::thread_rng;
Solving,const A: VarRef = VarRef::from_u32(1u32);
Solving,const B: VarRef = VarRef::from_u32(2u32);
Solving,let clause = Disjunction::from_vec(input);
Solving,assert_eq!(unordered(&clause), unordered(&output));
Solving,check(vec![geq(A, 0), geq(A, 1)], vec![geq(A, 0)]);
Solving,check(vec![leq(A, 0), leq(A, 1)], vec![leq(A, 1)]);
Solving,check(vec![leq(A, 1), leq(A, 0)], vec![leq(A, 1)]);
Solving,check(vec![leq(A, 0), leq(A, 0)], vec![leq(A, 0)]);
Solving,check(vec![leq(A, 0), leq(A, 1), leq(A, 1), leq(A, 0)], vec![leq(A, 1)]);
Solving,check(vec![leq(A, 0), !leq(A, 0)], vec![leq(A, 0), !leq(A, 0)]);
Solving,);
Solving,);
Solving,);
Solving,check(vec![Lit::FALSE, geq(A, 0), geq(A, 1)], vec![geq(A, 0)]);
Solving,check(vec![Lit::TRUE, geq(A, 0), geq(A, 1)], vec![Lit::TRUE]);
Solving,check(vec![Lit::FALSE, Lit::TRUE, geq(A, 0), geq(A, 1)], vec![Lit::TRUE]);
Solving,assert!(Disjunction::from_vec(vec![leq(A, 0), !leq(A, 0)]).is_tautology());
Solving,assert!(Disjunction::from([leq(A, 0), geq(A, 0)]).is_tautology());
Solving,assert!(Disjunction::from([leq(A, 0), geq(A, 1)]).is_tautology());
Solving,assert!(Disjunction::from([leq(A, 0), leq(B, 0), geq(B, 2), !leq(A, 0)]).is_tautology());
Solving,let vars = (0..=100).map(VarRef::from_u32);
Solving,let vals = -5..5;
Solving,let mut lits = Vec::new();
Solving,lits.push(Lit::geq(var, val));
Solving,lits.push(Lit::leq(var, val));
Solving,lits.shuffle(&mut thread_rng());
Solving,let subset = &lits[0..30];
Solving,let disj = Disjunction::from_slice(subset);
Solving,assert!(Disjunction::is_simplified(&disj));
Solving,let vars = (1..=10).map(VarRef::from_u32);
Solving,let vals = 0..10;
Solving,let mut lits = Vec::new();
Solving,lits.push(Lit::geq(var, val));
Solving,lits.push(Lit::leq(var, val));
Solving,lits.shuffle(&mut thread_rng());
Solving,let subset = &lits[0..30];
Solving,let disj = Disjunction::from_slice(subset);
Solving,let mut builder = DisjunctionBuilder::new();
Solving,builder.push(*l);
Solving,let built: Disjunction = builder.into();
Solving,assert_eq!(disj, built);
Solving,use crate::core::*;
Solving,use std::array::TryFromSliceError;
Solving,use std::collections::HashMap;
Solving,use std::convert::{TryFrom, TryInto};
Solving,use std::fmt::{Debug, Formatter};
Solving,/// use aries::core::literals::LitSet;
Solving,/// use aries::core::VarRef;
Solving,/// let mut set = LitSet::new();
Solving,/// assert!(!set.contains(var.leq(0)));
Solving,/// set.insert(var.leq(0));
Solving,/// assert!(set.contains(var.leq(0)));
Solving,let val = self.elements.entry(lit.svar()).or_insert(lit.ub_value());
Solving,debug_assert!(self.contains(rm));
Solving,let weaker = rm.svar().leq(rm.ub_value() + 1);
Solving,self.elements.remove(&rm.svar());
Solving,self.elements.insert(rm.svar(), weaker.ub_value());
Solving,let mut set = LitSet::new();
Solving,set.insert(l);
Solving,pub const EMPTY: Self = Self { elements: vec![] };
Solving,let mut elements: Vec<Lit> = set.literals().collect();
Solving,elements.sort();
Solving,let mut elements: Vec<Lit> = iter.collect();
Solving,simplify_conjunction(&mut elements);
Solving,conjuncts.sort();
Solving,let mut prev = Lit::TRUE;
Solving,prev = x;
Solving,});
Solving,type Error = TryFromSliceError;
Solving,use std::collections::BTreeSet;
Solving,use super::*;
Solving,const A: VarRef = VarRef::from_u32(1);
Solving,const B: VarRef = VarRef::from_u32(2);
Solving,const C: VarRef = VarRef::from_u32(3);
Solving,let mut set = LitSet::new();
Solving,assert!(!set.contains(A.leq(1)));
Solving,assert!(!set.contains(A.geq(1)));
Solving,assert_eq!(set.elements.len(), 0);
Solving,set.insert(A.leq(1));
Solving,assert_eq!(set.elements.len(), 1);
Solving,assert!(set.contains(A.leq(1)));
Solving,assert!(set.contains(A.leq(2)));
Solving,assert!(!set.contains(A.leq(0)));
Solving,set.insert(A.leq(2));
Solving,assert_eq!(set.elements.len(), 1);
Solving,assert!(set.contains(A.leq(1)));
Solving,assert!(set.contains(A.leq(2)));
Solving,assert!(!set.contains(A.leq(0)));
Solving,assert!(!set.contains(B.leq(10)));
Solving,assert!(!set.contains(C.leq(10)));
Solving,set.insert(A.leq(0));
Solving,assert_eq!(set.elements.len(), 1);
Solving,assert!(set.contains(A.leq(1)));
Solving,assert!(set.contains(A.leq(2)));
Solving,assert!(set.contains(A.leq(0)));
Solving,assert!(!set.contains(A.leq(-1)));
Solving,assert!(!set.contains(B.leq(10)));
Solving,assert!(!set.contains(C.leq(10)));
Solving,set.insert(B.geq(5));
Solving,assert_eq!(set.elements.len(), 2);
Solving,set.insert(C.geq(5));
Solving,assert_eq!(set.elements.len(), 3);
Solving,set.insert(C.geq(3));
Solving,assert!(set.contains(A.leq(0)));
Solving,assert!(!set.contains(A.leq(-1)));
Solving,assert!(set.contains(B.geq(5)));
Solving,assert!(!set.contains(B.geq(6)));
Solving,assert!(set.contains(C.geq(5)));
Solving,assert!(!set.contains(C.geq(6)));
Solving,assert!(!set.contains(B.leq(10)));
Solving,assert!(!set.contains(C.leq(10)));
Solving,let mut set = LitSet::new();
Solving,let tauto = |l| A.leq(4).entails(l);
Solving,assert!(!set.contains(A.leq(1)));
Solving,assert!(!set.contains(A.geq(1)));
Solving,assert_eq!(set.elements.len(), 0);
Solving,set.insert(A.leq(1));
Solving,assert_eq!(set.elements.len(), 1);
Solving,assert!(set.contains(A.leq(1)));
Solving,assert!(set.contains(A.leq(2)));
Solving,assert!(!set.contains(A.leq(0)));
Solving,set.remove(A.leq(1), tauto);
Solving,assert_eq!(set.elements.len(), 1);
Solving,assert!(!set.contains(A.leq(1)));
Solving,assert!(set.contains(A.leq(2)));
Solving,assert!(!set.contains(A.leq(0)));
Solving,set.remove(A.leq(3), tauto);
Solving,assert_eq!(set.elements.len(), 0);
Solving,let mut buf: Vec<Lit> = Vec::from(input);
Solving,simplify_conjunction(&mut buf);
Solving,test_equi(&[A.leq(4), A.leq(5)], &[A.leq(4)]);
Solving,test_equi(&[A.leq(5), A.leq(4)], &[A.leq(4)]);
Solving,test_equi(&[Lit::TRUE, A.leq(5), A.leq(4)], &[A.leq(4)]);
Solving,test_equi(&[Lit::FALSE, Lit::TRUE, A.leq(5), A.leq(4)], &[Lit::FALSE, A.leq(4)]);
Solving,use crate::collections::ref_store::RefVec;
Solving,use crate::core::*;
Solving,self.watches.clear();
Solving,let index = self.watches.iter().position(|w| w.watcher == watcher).unwrap();
Solving,self.watches.swap_remove(index);
Solving,debug_assert!(self.watches.iter().all(|w| w.watcher != watcher));
Solving,let mut i = 0;
Solving,let w = self.watches.swap_remove(i);
Solving,out.watches.push(w);
Solving,self.watches.push(WatchSet::new());
Solving,self.ensure_capacity(literal.svar());
Solving,self.watches[literal.svar()].add_watch(watcher, literal);
Solving,self.ensure_capacity(literal.svar());
Solving,self.watches[literal.svar()].remove_watch(watcher);
Solving,use super::*;
Solving,use crate::core::Lit;
Solving,let a = VarRef::from_u32(1);
Solving,let b = VarRef::from_u32(2);
Solving,let watches = &mut Watches::new();
Solving,watches.add_watch(1, Lit::leq(a, 1));
Solving,watches.add_watch(2, Lit::leq(a, 2));
Solving,watches.add_watch(3, Lit::leq(a, 3));
Solving,watches.add_watch(1, Lit::geq(a, 1));
Solving,watches.add_watch(2, Lit::geq(a, 2));
Solving,watches.add_watch(3, Lit::geq(a, 3));
Solving,let mut res: Vec<_> = watches.watches_on(bound).collect();
Solving,res.sort_unstable();
Solving,expected.sort_unstable();
Solving,assert_eq!(res, expected);
Solving,};
Solving,check_watches_on(watches, Lit::leq(a, 0), vec![1, 2, 3]);
Solving,check_watches_on(watches, Lit::leq(a, 1), vec![1, 2, 3]);
Solving,check_watches_on(watches, Lit::leq(a, 2), vec![2, 3]);
Solving,check_watches_on(watches, Lit::leq(a, 3), vec![3]);
Solving,check_watches_on(watches, Lit::leq(a, 4), vec![]);
Solving,check_watches_on(watches, Lit::geq(a, 0), vec![]);
Solving,check_watches_on(watches, Lit::geq(a, 1), vec![1]);
Solving,check_watches_on(watches, Lit::geq(a, 2), vec![1, 2]);
Solving,check_watches_on(watches, Lit::geq(a, 3), vec![1, 2, 3]);
Solving,check_watches_on(watches, Lit::geq(a, 4), vec![1, 2, 3]);
Solving,watches.remove_watch(2, Lit::leq(a, 2));
Solving,watches.remove_watch(3, Lit::geq(a, 3));
Solving,check_watches_on(watches, Lit::leq(a, 0), vec![1, 3]);
Solving,check_watches_on(watches, Lit::leq(a, 1), vec![1, 3]);
Solving,check_watches_on(watches, Lit::leq(a, 2), vec![3]);
Solving,check_watches_on(watches, Lit::leq(a, 3), vec![3]);
Solving,check_watches_on(watches, Lit::leq(a, 4), vec![]);
Solving,check_watches_on(watches, Lit::geq(a, 0), vec![]);
Solving,check_watches_on(watches, Lit::geq(a, 1), vec![1]);
Solving,check_watches_on(watches, Lit::geq(a, 2), vec![1, 2]);
Solving,check_watches_on(watches, Lit::geq(a, 3), vec![1, 2]);
Solving,check_watches_on(watches, Lit::geq(a, 4), vec![1, 2]);
Solving,watches.add_watch(2, Lit::leq(a, 2));
Solving,watches.add_watch(3, Lit::geq(a, 3));
Solving,check_watches_on(watches, Lit::leq(a, 0), vec![1, 2, 3]);
Solving,check_watches_on(watches, Lit::leq(a, 1), vec![1, 2, 3]);
Solving,check_watches_on(watches, Lit::leq(a, 2), vec![2, 3]);
Solving,check_watches_on(watches, Lit::leq(a, 3), vec![3]);
Solving,check_watches_on(watches, Lit::leq(a, 4), vec![]);
Solving,check_watches_on(watches, Lit::geq(a, 0), vec![]);
Solving,check_watches_on(watches, Lit::geq(a, 1), vec![1]);
Solving,check_watches_on(watches, Lit::geq(a, 2), vec![1, 2]);
Solving,check_watches_on(watches, Lit::geq(a, 3), vec![1, 2, 3]);
Solving,check_watches_on(watches, Lit::geq(a, 4), vec![1, 2, 3]);
Solving,check_watches_on(watches, Lit::leq(b, 0), vec![]);
Solving,check_watches_on(watches, Lit::leq(b, 1), vec![]);
Solving,check_watches_on(watches, Lit::leq(b, 2), vec![]);
Solving,check_watches_on(watches, Lit::leq(b, 3), vec![]);
Solving,check_watches_on(watches, Lit::leq(b, 4), vec![]);
Solving,check_watches_on(watches, Lit::geq(b, 0), vec![]);
Solving,check_watches_on(watches, Lit::geq(b, 1), vec![]);
Solving,check_watches_on(watches, Lit::geq(b, 2), vec![]);
Solving,check_watches_on(watches, Lit::geq(b, 3), vec![]);
Solving,check_watches_on(watches, Lit::geq(b, 4), vec![]);
Solving,use crate::core::literals::{LitSet, Watches};
Solving,use crate::core::*;
Solving,use std::num::NonZeroUsize;
Solving,use std::sync::Mutex;
Solving,/// use aries::core::*;
Solving,/// use aries::core::literals::ImplicationGraph;
Solving,/// let mut set = ImplicationGraph::empty();
Solving,/// assert!(!set.implies(v1.leq(0), v2.leq(0)));
Solving,/// set.add_implication(v1.leq(0), v2.leq(0));
Solving,/// assert!(set.implies(v1.leq(0), v2.leq(0)));
Solving,/// assert!(set.implies(v1.leq(0), v2.leq(1)));
Solving,/// assert!(set.implies(v1.leq(-1), v2.leq(0)));
Solving,/// assert!(!set.implies(v1.leq(1), v2.leq(0)));
Solving,return;
Solving,self.num_edges += 1;
Solving,self.edges.add_watch(to, from);
Solving,self.edges.add_watch(!from, !to);
Solving,self.cache.clear();
Solving,debug_assert!(self.implies(from, to));
Solving,debug_assert!(self.implies(!to, !from));
Solving,return true;
Solving,return false;
Solving,};
Solving,state.queue.push(source);
Solving,return true;
Solving,self.queue.push(next);
Solving,self.visited.insert(next);
Solving,return true;
Solving,debug_assert!(self.queue.is_empty() && !self.visited.contains(target));
Solving,use crate::core::literals::ImplicationGraph;
Solving,use crate::core::*;
Solving,const A: VarRef = VarRef::from_u32(0);
Solving,const B: VarRef = VarRef::from_u32(1);
Solving,const C: VarRef = VarRef::from_u32(2);
Solving,const D: VarRef = VarRef::from_u32(3);
Solving,let mut g = ImplicationGraph::empty();
Solving,assert!(g.implies(A.leq(0), A.leq(0)));
Solving,assert!(g.implies(A.leq(0), A.leq(1)));
Solving,assert!(!g.implies(A.leq(0), B.leq(0)));
Solving,assert!(!g.implies(A.leq(0), A.leq(-1)));
Solving,g.add_implication(A.leq(1), B.leq(1));
Solving,assert!(g.implies(A.leq(1), B.leq(1)));
Solving,assert!(g.implies(A.leq(0), B.leq(1)));
Solving,assert!(g.implies(A.leq(1), B.leq(2)));
Solving,assert!(g.implies(A.leq(0), B.leq(2)));
Solving,assert!(!g.implies(A.leq(1), B.leq(0)));
Solving,assert!(!g.implies(A.leq(1), B.leq(0)));
Solving,g.add_implication(B.leq(2), C.leq(2));
Solving,assert!(g.implies(A.leq(1), B.leq(1)));
Solving,assert!(g.implies(A.leq(1), C.leq(2)));
Solving,assert!(g.implies(A.leq(1), C.leq(3)));
Solving,assert!(!g.implies(A.leq(1), C.leq(1)));
Solving,assert!(g.implies(A.leq(0), C.leq(2)));
Solving,assert!(!g.implies(A.leq(2), C.leq(2)));
Solving,let mut g = ImplicationGraph::empty();
Solving,g.add_implication(A.leq(0), B.leq(0));
Solving,g.add_implication(B.leq(0), A.leq(0));
Solving,g.add_implication(C.leq(0), D.leq(0));
Solving,g.add_implication(D.leq(0), C.leq(0));
Solving,};
Solving,pub use disjunction::*;
Solving,pub use implication_graph::*;
Solving,pub use lit_set::*;
Solving,use smallvec::SmallVec;
Solving,pub use watches::*;
Solving,use crate::core::Lit;
Solving,mod disjunction;
Solving,mod implication_graph;
Solving,mod lit_set;
Solving,mod watches;
Solving,const INLINE_SIZE: usize = 3;
Solving,};
Solving,self.elems.push(item);
Solving,self.elems.extend_from_slice(items);
Solving,self.elems.clear();
Solving,self.elems.retain(move |l| f(*l));
Solving,return;
Solving,self.elems.sort_unstable_by_key(|k| Reverse(*k));
Solving,self.elems.dedup_by(|curr, prev| (*curr).entails(*prev));
Solving,self.elems.pop();
Solving,self.elems.truncate(1);
Solving,self.elems[0] = Lit::TRUE;
Solving,return;
Solving,self.elems.pop();
Solving,debug_assert!(Disjunction::is_simplified(self), "{self:?}");
Solving,type Target = [Lit];
Solving,type Item = Lit;
Solving,type IntoIter = std::iter::Copied<std::slice::Iter<'a, Lit>>;
Solving,type Item = Lit;
Solving,type IntoIter = smallvec::IntoIter<[Lit; INLINE_SIZE]>;
Solving,use crate::core::{literals::Lits, Lit};
Solving,assert_eq!(std::mem::size_of::<Lits>(), 32);
Solving,mod cause;
Solving,mod domain;
Solving,mod domains;
Solving,mod event;
Solving,mod explanation;
Solving,mod int_domains;
Solving,mod snapshot;
Solving,pub use cause::*;
Solving,pub use domain::*;
Solving,pub use domains::*;
Solving,pub use event::*;
Solving,pub use explanation::*;
Solving,pub use int_domains::*;
Solving,pub use snapshot::DomainsSnapshot;
Solving,use crate::core::Lit;
Solving,pub struct InvalidUpdate(pub Lit, pub Origin);
Solving,use crate::core::*;
Solving,use crate::model::lang::ConversionError;
Solving,use core::convert::{From, Into};
Solving,use std::cmp::Ordering;
Solving,/// use aries::core::*;
Solving,/// use aries::core::state::IntDomains;
Solving,/// let mut state = IntDomains::new();
Solving,/// let x = state.new_var(0, 1);
Solving,/// let x_is_true: Lit = x.geq(1);
Solving,/// let x_is_false: Lit = !x_is_true;
Solving,/// let y = state.new_var(0, 10);
Solving,/// let y_geq_5 = Lit::geq(y, 5);
Solving,/// use aries::core::*;
Solving,/// use aries::core::state::IntDomains;
Solving,/// let mut state = IntDomains::new();
Solving,/// let x = state.new_var(0, 1);
Solving,/// assert_eq!(x.leq(5), SignedVar::plus(x).leq(5));
Solving,/// assert_eq!(Lit::lt(x, 5), SignedVar::plus(x).leq(4));
Solving,/// assert_eq!(Lit::geq(x, 3), SignedVar::minus(x).leq(-3));
Solving,/// assert_eq!(Lit::gt(x, 3), SignedVar::minus(x).leq(-4));
Solving,/// use aries::core::*;
Solving,/// let x = VarRef::from_u32(1);
Solving,/// let y = VarRef::from_u32(2);
Solving,/// let mut literals = vec![Lit::geq(y, 4), Lit::geq(x,1), Lit::leq(x, 3), Lit::leq(x, 4), Lit::leq(x, 6), Lit::geq(x,2)];
Solving,/// literals.sort();
Solving,/// assert_eq!(literals, vec![Lit::geq(x,2), Lit::geq(x,1), Lit::leq(x, 3), Lit::leq(x, 4), Lit::leq(x, 6), Lit::geq(y, 4)]);
Solving,pub const TRUE: Lit = Lit::new(SignedVar::plus(VarRef::ZERO), 0);
Solving,pub const FALSE: Lit = Lit::TRUE.not();
Solving,/// use aries::core::{Lit, VarRef};
Solving,/// assert_eq!(!Lit::TRUE, Lit::FALSE);
Solving,/// assert_eq!(!Lit::FALSE, Lit::TRUE);
Solving,/// let a = VarRef::from(0usize);
Solving,/// assert_eq!(!Lit::leq(a, 1), Lit::gt(a, 1));
Solving,/// use aries::core::{Lit, VarRef};
Solving,/// let a = VarRef::from(0usize);
Solving,/// assert!(Lit::leq(a, 1).entails(Lit::leq(a, 1)));
Solving,/// assert!(Lit::leq(a, 1).entails(Lit::leq(a, 2)));
Solving,/// assert!(!Lit::leq(a, 1).entails(Lit::leq(a, 0)));
Solving,/// let b = VarRef::from(1usize);
Solving,/// assert!(!Lit::leq(a, 1).entails(Lit::leq(b, 1)));
Solving,/// use aries::core::{Lit,VarRef};
Solving,/// assert!(Lit::TRUE.tautological());
Solving,/// assert!(!Lit::FALSE.tautological());
Solving,/// assert!(VarRef::ZERO.leq(10).tautological());
Solving,/// assert!(!VarRef::ZERO.geq(10).tautological());
Solving,/// assert!(VarRef::ZERO.geq(0).tautological());
Solving,/// assert!(!VarRef::ZERO.lt(0).tautological());
Solving,/// use aries::core::{Lit,VarRef};
Solving,/// assert!(Lit::FALSE.absurd());
Solving,/// assert!(VarRef::ZERO.geq(10).absurd());
Solving,/// assert!(VarRef::ZERO.lt(0).absurd());
Solving,type Output = Lit;
Solving,type Error = ConversionError;
Solving,let var = self.svar().variable();
Solving,let upper_bound = self.upper_bound;
Solving,let lb = -self.upper_bound;
Solving,use super::*;
Solving,let a = VarRef::from(0usize);
Solving,let b = VarRef::from(1usize);
Solving,assert!(leq(a, 0).entails(leq(a, 0)));
Solving,assert!(leq(a, 0).entails(leq(a, 1)));
Solving,assert!(!leq(a, 0).entails(leq(a, -1)));
Solving,assert!(!leq(a, 0).entails(leq(b, 0)));
Solving,assert!(!leq(a, 0).entails(leq(b, 1)));
Solving,assert!(!leq(a, 0).entails(leq(b, -1)));
Solving,assert!(geq(a, 0).entails(geq(a, 0)));
Solving,assert!(!geq(a, 0).entails(geq(a, 1)));
Solving,assert!(geq(a, 0).entails(geq(a, -1)));
Solving,assert!(!geq(a, 0).entails(geq(b, 0)));
Solving,assert!(!geq(a, 0).entails(geq(b, 1)));
Solving,assert!(!geq(a, 0).entails(geq(b, -1)));
Solving,//! use aries::core::*;
Solving,//! use aries::core::state::*;
Solving,//! use aries::backtrack::Backtrack;
Solving,//! let mut state = Domains::new();
Solving,//! let x: VarRef = state.new_var(0, 10);
Solving,//! assert_eq!(state.lb(x), 0);
Solving,//! assert_eq!(state.ub(x), 10);
Solving,//! let x_ge_5: Lit  = x.geq(5);
Solving,//! assert!(!state.entails(x_ge_5), "This literal should no be entailed yet.");
Solving,//! state.save_state();
Solving,//! state.set_lb(x, 6, Cause::Decision).unwrap();
Solving,//! assert_eq!(state.lb(x), 6);
Solving,//! assert_eq!(state.ub(x), 10);
Solving,//! assert!(state.entails(x_ge_5), "The (x >= 5) literal is now entailed.");
Solving,//! state.restore_last();
Solving,//! assert_eq!(state.lb(x), 0);
Solving,//! assert_eq!(state.ub(x), 10);
Solving,pub use cst::*;
Solving,pub use lit::*;
Solving,pub use signed_var::*;
Solving,pub use variable::*;
Solving,mod cst;
Solving,mod lit;
Solving,pub mod literals;
Solving,mod signed_var;
Solving,pub mod state;
Solving,mod variable;
Solving,use crate::{core::IntCst, core::Lit, create_ref_type};
Solving,use std::{fmt::Debug, hash::Hash};
Solving,create_ref_type!(VarRef);
Solving,pub const ZERO: VarRef = VarRef::from_u32(0);
Solving,pub const ONE: VarRef = VarRef::from_u32(1);
Solving,use crate::core::*;
Solving,pub struct SignedVar(u32);
Solving,/// use aries::core::*;
Solving,/// let var = VarRef::from(1u32);
Solving,/// let plus_var = SignedVar::minus(var);
Solving,/// let minus_var = SignedVar::plus(var);
Solving,/// assert_eq!(plus_var.neg(), minus_var);
Solving,/// assert_eq!(minus_var.neg(), plus_var);
Solving,type Output = Self;
Solving,write!(f, "-")?;
Solving,pub use types::*;
Solving,pub type IntCst = i32;
Solving,pub type LongCst = i64;
Solving,pub const INT_TYPE_NAME: &str = "i32";
Solving,pub type IntCst = i64;
Solving,pub type LongCst = i128;
Solving,pub const INT_TYPE_NAME: &str = "i64";
Solving,pub type IntCst = i128;
Solving,pub type LongCst = i128;
Solving,pub const INT_TYPE_NAME: &str = "i128";
Solving,pub const INT_CST_MAX: IntCst = IntCst::MAX / 4 - 1;
Solving,pub const INT_CST_MIN: IntCst = -INT_CST_MAX;
Solving,use crate::utils::Fmt;
Solving,use itertools::Itertools;
Solving,use std::convert::TryFrom;
Solving,use std::fmt::Display;
Solving,use std::sync::Arc;
Solving,let s = std::fs::read_to_string(file)?;
Solving,let mut start = None;
Solving,let mut end = None;
Solving,let mut line = 0;
Solving,let mut column = 0;
Solving,let pos = Pos { line, column };
Solving,start = Some(char);
Solving,end = Some(char);
Solving,column += 1;
Solving,line += 1;
Solving,column = 0;
Solving,let (start, end) = self.indices(span).expect("Invalid span");
Solving,.expect("Invalid span for this source");
Solving,assert!((span.start.column as usize) < l.len());
Solving,writeln!(f, "{l}")?;
Solving,let num_spaces = span.start.column as usize;
Solving,};
Solving,let output = if c == '\t' { '\t' } else { ' ' };
Solving,write!(f, "{output}")?;
Solving,write!(f, "{}", "^".repeat(length))?;
Solving,};
Solving,type Error = std::io::Error;
Solving,self.inline_err = Some(inline_message.into());
Solving,let prefix = if i > 0 { "Caused by" } else { "Error" };
Solving,writeln!(f, "{prefix}: {context}")?;
Solving,writeln!(f, "{}:{}:{}", path, span.start.line + 1, span.start.column)?;
Solving,write!(f, "{}", source.underlined(*span))?;
Solving,write!(f, " {err}")?;
Solving,fn ctx(self, error_context: impl Display) -> std::result::Result<T, ErrLoc>;
Solving,e.context.push(format!("{error_context}"));
Solving,let input = Input::from_string(&self.canonical);
Solving,};
Solving,pub use cycles::*;
Solving,use std::fmt::{Display, Formatter, Result};
Solving,pub struct StartCycleCount();
Solving,pub const SUPPORT_CPU_TIMING: bool = false;
Solving,pub struct CycleCount();
Solving,type Output = CycleCount;
Solving,type Output = CycleRatio;
Solving,pub struct CycleRatio();
Solving,use std::fmt::{Display, Formatter, Result};
Solving,use core::arch::x86_64 as arch;
Solving,pub struct StartCycleCount(u64);
Solving,pub const SUPPORT_CPU_TIMING: bool = true;
Solving,pub struct CycleCount(u64);
Solving,type Output = CycleCount;
Solving,type Output = CycleRatio;
Solving,pub struct CycleRatio(f64);
Solving,pub(crate) mod cpu_time;
Solving,pub mod input;
Solving,use std::fmt::{Display, Error, Formatter};
Solving,F: Fn(&mut std::fmt::Formatter) -> std::fmt::Result;
Solving,let mut i = iterable.iter();
Solving,write!(f, "{first}")?;
Solving,write!(f, "{sep}")?;
Solving,write!(f, "{other}")?;
Solving,pub use streaming_iterator::StreamingIterator;
Solving,let size = instances.len();
Solving,type Item = [I];
Solving,return;
Solving,self.is_first = false;
Solving,return;
Solving,self.finished = true;
Solving,return;
Solving,debug_assert!(self.sol.len() == self.gen.len());
Solving,self.sol.pop();
Solving,self.is_first = false;
Solving,let lvl = self.sol.len();
Solving,self.sol.push(i);
Solving,self.finished = true;
Solving,return;
Solving,self.sol.pop();
Solving,self.cur[lvl] = self.gen[lvl].clone();
Solving,debug_assert_eq!(self.sol.len(), self.gen.len());
Solving,use super::*;
Solving,use std::ops::Range;
Solving,let gens = vec![0..2, 1..3];
Solving,let mut generated: Vec<Vec<i32>> = Vec::new();
Solving,let mut iter = enumerate(gens.clone());
Solving,generated.push(x.to_vec());
Solving,assert_eq!(generated, vec![vec![0, 1], vec![0, 2], vec![1, 1], vec![1, 2]]);
Solving,let mut iter = enumerate(gens);
Solving,println!("{x:?}");
Solving,let xs = ["x1", "x2"];
Solving,let it = enumerate(vec![xs.iter()]);
Solving,assert_eq!(it.count(), 2);
Solving,assert_eq!(enumerate(Vec::<Range<i32>>::new()).count(), 1);
Solving,assert_eq!(enumerate(vec![1..2, 1..2, 1..2, 1..2]).count(), 1);
Solving,assert_eq!(enumerate(vec![1..3, 1..2, 1..2, 1..2]).count(), 2);
Solving,assert_eq!(enumerate(vec![1..3, 1..3, 1..2, 1..2]).count(), 4);
Solving,assert_eq!(enumerate(vec![1..3, 1..3, 1..3, 1..2]).count(), 8);
Solving,assert_eq!(enumerate(vec![1..3, 1..3, 1..3, 1..3]).count(), 16);
Solving,assert_eq!(enumerate(vec![1..2, 1..3, 1..3, 1..3]).count(), 8);
Solving,assert_eq!(enumerate(vec![1..1, 1..3, 1..3, 1..3]).count(), 0);
Solving,assert_eq!(enumerate(vec![1..3, 1..1, 1..3, 1..3]).count(), 0);
Solving,assert_eq!(enumerate(vec![1..3, 1..3, 1..1, 1..3]).count(), 0);
Solving,assert_eq!(enumerate(vec![1..3, 1..3, 1..3, 1..1]).count(), 0);
Solving,use crate::backtrack::{Backtrack, DecLvl};
Solving,use crate::core::state::{Cause, Domains, DomainsSnapshot, Explanation, InferenceCause};
Solving,use crate::core::Lit;
Solving,use crate::reasoners::{Contradiction, ReasonerId, Theory};
Solving,});
Solving,model.set(*l, cause)?;
Solving,debug_assert_eq!(context.writer, self.identity());
Solving,debug_assert_eq!(context.payload, 0);
Solving,mod clause_storage;
Solving,use crate::collections::ref_store::RefMap;
Solving,use crate::core::Lit;
Solving,use crate::create_ref_type;
Solving,use env_param::EnvParam;
Solving,use std::cmp::Ordering::Equal;
Solving,use std::collections::BTreeSet;
Solving,use std::fmt::{Display, Error, Formatter};
Solving,use std::ops::{Index, IndexMut};
Solving,pub use clause_storage::*;
Solving,pub static DEFAULT_LOCKED_LBD_LEVEL: EnvParam<u32> = EnvParam::new("ARIES_SAT_LBD_LOCK_LEVEL", "4");
Solving,create_ref_type!(ClauseId);
Solving,self.num_clauses += 1;
Solving,self.num_fixed += 1;
Solving,};
Solving,// debug_assert!((0..self.first_possibly_free).all(|i| self.is_in_db(ClauseId::from(i))));
Solving,.find(|&id| !self.metadata.contains(id));
Solving,debug_assert!(!self.metadata.contains(id));
Solving,debug_assert!(self.is_the_tautological_clause(&self.clauses[id]));
Solving,self.clauses.set(id, cl, scope);
Solving,self.metadata.insert(id, meta);
Solving,let id = self.clauses.push(cl, scope);
Solving,self.metadata.insert(id, meta);
Solving,};
Solving,self.first_possibly_free = usize::from(id) + 1;
Solving,let meta = self.metadata[cl_id];
Solving,);
Solving,debug_assert_ne!(lbd, 0);
Solving,let meta = &mut self.metadata[clause];
Solving,let lock_level = self.params.locked_lbd_level;
Solving,debug_assert_ne!(meta.lbd, 0);
Solving,self.num_learnt_lbd_locked -= 1;
Solving,meta.lbd = lbd;
Solving,let lbd = self.metadata[clause].lbd;
Solving,self.metadata[cl].activity += self.params.cla_inc;
Solving,self.params.cla_inc /= self.params.cla_decay;
Solving,self.params.cla_inc *= 1e-100_f64;
Solving,// let score = meta.activity / ((meta.lbd) as f64);
Solving,let score = meta.activity;
Solving,.collect();
Solving,clauses.sort_by(|&a, &b| a.1.partial_cmp(&b.1).unwrap_or(Equal));
Solving,let to_remove = BTreeSet::from_iter(clauses.iter().take(clauses.len() / 2).map(|(cid, _)| *cid));
Solving,let cl = &self.clauses[id];
Solving,remove_watch(id, !cl.watch1);
Solving,remove_watch(id, !cl.watch2);
Solving,self.metadata.remove(id);
Solving,self.num_clauses -= 1;
Solving,});
Solving,self.clauses = self.clauses.clone_with_subset(|cid| !to_remove.contains(&cid));
Solving,self.first_possibly_free = 0;
Solving,type Output = Clause;
Solving,debug_assert!(self.is_in_db(k));
Solving,debug_assert!(self.is_in_db(k));
Solving,};
Solving,use bumpalo::Bump;
Solving,use itertools::Itertools;
Solving,};
Solving,type Arena = Bump<8>;
Solving,self.buffer.clear();
Solving,self.buffer.extend_from_slice(clause);
Solving,self.buffer.push(!scope);
Solving,self.buffer.simplify_disjunctive();
Solving,let clause = self.create_clause(clause, scope);
Solving,let clause = self.create_clause(clause, scope);
Solving,self.clauses[clause_id] = clause;
Solving,let mut copy = Clauses::new();
Solving,};
Solving,let new_cid = copy.clauses.push(cl);
Solving,debug_assert!(cid == new_cid);
Solving,type Output = Clause;
Solving,/// use aries::reasoners::sat::clauses::Clause;
Solving,/// let cl: &Clause = todo!();
Solving,debug_assert!(Disjunction::is_simplified(lits));
Solving,debug_assert_ne!(lits[0], lits[1]);
Solving,std::mem::swap(&mut self.watch1, &mut self.watch2);
Solving,std::mem::swap(&mut self.watch1, &mut self.unwatched[unwatched_index]);
Solving,std::mem::swap(&mut self.watch2, &mut self.unwatched[unwatched_index]);
Solving,};
Solving,debug_assert!(self.len() >= 2);
Solving,let mut lvl0 = priority(self.watch1);
Solving,let mut lvl1 = priority(self.watch2);
Solving,std::mem::swap(&mut lvl0, &mut lvl1);
Solving,self.swap_watches();
Solving,let lvl = priority(self.unwatched[i]);
Solving,lvl1 = lvl;
Solving,self.set_watch2(i);
Solving,lvl1 = lvl0;
Solving,lvl0 = lvl;
Solving,self.swap_watches();
Solving,debug_assert_eq!(lvl0, priority(self.watch1));
Solving,debug_assert_eq!(lvl1, priority(self.watch2));
Solving,debug_assert!(lvl0 >= lvl1);
Solving,debug_assert!(self.unwatched.iter().all(|l| lvl1 >= priority(*l)));
Solving,return;
Solving,debug_assert_ne!(value_of(self.watch1), Some(true));
Solving,debug_assert_ne!(value_of(self.watch2), Some(true));
Solving,return;
Solving,debug_assert_eq!(self.watch2, !presence(self.watch1));
Solving,.find(|(_i, l)| value_of(*l) != Some(false));
Solving,self.set_watch2(i);
Solving,debug_assert!(priority(self.watch1) >= priority(self.watch2));
Solving,write!(f, "[")?;
Solving,write!(f, " ")?;
Solving,write!(f, "{lit:?}")?;
Solving,type Item = Lit;
Solving,self.next += 1;
Solving,type Item = Lit;
Solving,type IntoIter = Literals<'a>;
Solving,use crate::backtrack::{Backtrack, DecLvl, ObsTrailCursor, Trail};
Solving,use crate::collections::set::{IterableRefSet, RefSet};
Solving,use crate::core::literals::{WatchSet, Watches};
Solving,use crate::core::state::{Domains, DomainsSnapshot, Event, Explanation, InferenceCause};
Solving,use crate::core::*;
Solving,use crate::model::extensions::DisjunctionExt;
Solving,use crate::reasoners::sat::clauses::*;
Solving,use crate::reasoners::{Contradiction, ReasonerId, Theory};
Solving,use itertools::Itertools;
Solving,use smallvec::alloc::collections::VecDeque;
Solving,debug_assert!(!self.locked.contains(clause));
Solving,self.locked.insert(clause);
Solving,debug_assert!(self.locked.contains(clause));
Solving,self.locked.remove(clause);
Solving,self.count -= 1;
Solving,self.add_clause_impl(clause, None, true);
Solving,self.stats.conflicts += 1;
Solving,let cl_id = self.clauses.add_clause(clause, None, true);
Solving,self.pending_clauses.push_front(PendingClause { clause: cl_id });
Solving,let cl_id = self.clauses.add_clause(clause, scope, learnt);
Solving,self.pending_clauses.push_back(PendingClause { clause: cl_id });
Solving,let clause = &self.clauses[cl_id];
Solving,return self.process_violated(cl_id, model);
Solving,let l = clause.watch1;
Solving,self.watches.add_watch(cl_id, !l);
Solving,self.set_from_unit_propagation(l, cl_id, model);
Solving,};
Solving,debug_assert!(clause.len() >= 2);
Solving,self.move_watches_front(cl_id, model);
Solving,let clause = &self.clauses[cl_id];
Solving,let l0 = clause.watch1;
Solving,let l1 = clause.watch2;
Solving,self.set_watch_on_first_literals(cl_id);
Solving,debug_assert!(model.violated_clause(clause));
Solving,self.set_watch_on_first_literals(cl_id);
Solving,debug_assert!(!model.unit_clause(clause));
Solving,debug_assert!(model.value(l0).is_none());
Solving,debug_assert!(model.pending_clause(clause));
Solving,self.set_watch_on_first_literals(cl_id);
Solving,debug_assert!(model.value(l0).is_none());
Solving,debug_assert!(model.unit_clause(clause));
Solving,self.process_unit_clause(cl_id, model);
Solving,debug_assert!(model.violated_clause(&self.clauses[cl_id]));
Solving,debug_assert_eq!(model.value(l), Some(true));
Solving,);
Solving,let clause = &self.clauses[cl_id];
Solving,debug_assert!(model.unit_clause(clause));
Solving,let l = clause.watch1;
Solving,debug_assert!(model.value(l).is_none());
Solving,debug_assert!(!self.watches.is_watched_by(!l, cl_id));
Solving,self.watches.add_watch(cl_id, !l);
Solving,self.set_from_unit_propagation(l, cl_id, model);
Solving,debug_assert!(clause.len() >= 2);
Solving,self.move_watches_front(cl_id, model);
Solving,self.set_watch_on_first_literals(cl_id);
Solving,let clause = &mut self.clauses[cl_id];
Solving,debug_assert!(model.violated_clause(clause.literals().dropping(2)));
Solving,let opt = clause.watch1;
Solving,let absent = clause.watch2;
Solving,debug_assert!(absent == !model.presence(opt));
Solving,debug_assert!(!model.entails(!absent), "No unset literals in clause...");
Solving,self.set_from_unit_propagation(absent, cl_id, model);
Solving,self.set_from_unit_propagation(opt, cl_id, model);
Solving,debug_assert!(model.violated_clause(clause.literals().dropping(1)));
Solving,let l = clause.watch1;
Solving,debug_assert!(model.value(l).is_none());
Solving,self.set_from_unit_propagation(l, cl_id, model);
Solving,let clause = &self.clauses[violated];
Solving,debug_assert!(model.violated_clause(clause));
Solving,let mut explanation = Explanation::with_capacity(clause.len());
Solving,explanation.push(!b);
Solving,self.clauses.bump_activity(violated);
Solving,return Err(conflict);
Solving,self.scale_database();
Solving,);
Solving,let mut working_watches = WatchSet::new();
Solving,std::mem::swap(&mut self.working_watches, &mut working_watches);
Solving,let new_lit = ev.new_literal();
Solving,working_watches.clear();
Solving,self.watches.move_watches_to(new_lit, &mut working_watches);
Solving,);
Solving,let mut contradicting_clause = None;
Solving,let watched_literal = watch.to_lit(new_lit.svar());
Solving,let clause = watch.watcher;
Solving,debug_assert!(self.clauses[clause].literals().any(|l| l == !watched_literal));
Solving,contradicting_clause = Some(clause);
Solving,let to_restore = watch.to_lit(new_lit.svar());
Solving,self.watches.add_watch(clause, to_restore);
Solving,std::mem::swap(&mut self.working_watches, &mut working_watches);
Solving,return Err(violated);
Solving,std::mem::swap(&mut self.working_watches, &mut working_watches);
Solving,debug_assert_eq!(model.value(p), Some(true));
Solving,// self.stats.propagations += 1;
Solving,let clause = &mut self.clauses[clause_id];
Solving,debug_assert!(p.entails(!clause.watch1));
Solving,self.watches.add_watch(clause_id, p);
Solving,return self.process_violated(clause_id, model).is_none();
Solving,clause.swap_watches();
Solving,self.watches.add_watch(clause_id, !clause.watch2);
Solving,return true;
Solving,let mut replacement = Replacement::None;
Solving,let lit = clause.unwatched(i);
Solving,debug_assert_eq!(!clause.watch1, model.presence(clause.unwatched(prev_i)));
Solving,debug_assert_eq!(!clause.watch1, model.presence(clause.unwatched(i)));
Solving,replacement = Replacement::Regular(prev_i);
Solving,break;
Solving,debug_assert!(matches!(replacement, Replacement::None));
Solving,replacement = Replacement::FusableUnit(i);
Solving,replacement = Replacement::Regular(i);
Solving,break;
Solving,let lit = clause.unwatched(i);
Solving,clause.set_watch2(i);
Solving,self.watches.add_watch(clause_id, !lit);
Solving,let lit = clause.unwatched(i);
Solving,clause.set_watch2(i);
Solving,self.watches.add_watch(clause_id, !lit);
Solving,debug_assert!(model.fusable(clause.watch1, clause.watch2));
Solving,debug_assert!(clause.unwatched_lits().iter().all(|&l| model.entails(!l)));
Solving,debug_assert!(clause.watch2 == !model.presence(clause.watch1));
Solving,};
Solving,self.set_from_unit_propagation(opt, clause_id, model);
Solving,self.set_from_unit_propagation(absent, clause_id, model);
Solving,self.watches.add_watch(clause_id, !clause.watch2);
Solving,let first_lit = clause.watch1;
Solving,self.set_from_unit_propagation(first_lit, clause_id, model);
Solving,let changed_something = model.set(literal, self.identity.cause(propagating_clause)).unwrap();
Solving,self.lock(propagating_clause);
Solving,self.stats.propagations += 1;
Solving,let lbd = self.lbd(literal, propagating_clause, model);
Solving,self.clauses.set_lbd(propagating_clause, lbd);
Solving,let clause = &self.clauses[clause];
Solving,self.working_lbd_compute.clear();
Solving,self.working_lbd_compute.insert(lvl);
Solving,let lvl = model.entailing_level(!l);
Solving,self.working_lbd_compute.insert(lvl);
Solving,self.locks.lock(clause);
Solving,self.trail.push(SatEvent::Lock(clause));
Solving,let cl = &self.clauses[cl_id];
Solving,debug_assert!(cl.len() >= 2);
Solving,self.watches.add_watch(cl_id, !cl.watch1);
Solving,self.watches.add_watch(cl_id, !cl.watch2);
Solving,let cl = &self.clauses[cl_id];
Solving,let l0 = cl.watch1;
Solving,let l1 = cl.watch2;
Solving,// assert!(self.watches[!l0].contains(&cl_id));
Solving,// assert!(self.watches[!l1].contains(&cl_id));
Solving,assert!(cl.unwatched_lits().iter().all(|&l| state.entails(!l)));
Solving,let explained_presence = model.presence(explained);
Solving,let clause = ClauseId::from(cause);
Solving,self.clauses.bump_activity(clause);
Solving,let clause = &self.clauses[clause];
Solving,debug_assert!(clause.literals().any(|l| l.entails(explained)));
Solving,explanation.reserve(clause.len() - 1);
Solving,explanation.push(!l);
Solving,let initial_clauses = self.clauses.num_clauses() - self.clauses.num_learnt();
Solving,self.params.init_learnt_base + initial_clauses as f64 * self.params.init_learnt_ratio;
Solving,self.state.allowed_learnt *= self.params.db_expansion_ratio;
Solving,self.state.conflicts_at_last_db_expansion = self.stats.conflicts;
Solving,* self.params.increase_ratio_of_conflicts_before_db_expansion) as u64;
Solving,let locks = &self.locks;
Solving,let watches = &mut self.watches;
Solving,watches.remove_watch(clause, watched);
Solving,};
Solving,self.clauses.reduce_db(|cl| locks.contains(cl), &mut remove_watch);
Solving,println!("DB size              : {}", self.clauses.num_clauses());
Solving,println!("Num unit propagations: {}", self.stats.propagations);
Solving,let locks = &mut self.locks;
Solving,self.trail.restore_last_with(|SatEvent::Lock(cl)| locks.unlock(cl));
Solving,use super::*;
Solving,use crate::backtrack::Backtrack;
Solving,use crate::collections::seq::Seq;
Solving,use crate::core::state::{Cause, Explainer, InferenceCause};
Solving,use crate::model::extensions::AssignmentExt;
Solving,type Model = crate::model::Model<&'static str>;
Solving,let writer = ReasonerId::Sat;
Solving,let model = &mut Model::new();
Solving,let a = model.new_bvar("a");
Solving,let b = model.new_bvar("b");
Solving,let mut sat = SatSolver::new(writer);
Solving,let a_or_b = vec![a.true_lit(), b.true_lit()];
Solving,sat.add_clause(&a_or_b);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,assert_eq!(model.boolean_value_of(a), None);
Solving,assert_eq!(model.boolean_value_of(b), None);
Solving,model.state.set(a.false_lit(), Cause::Decision).unwrap();
Solving,assert_eq!(model.boolean_value_of(a), Some(false));
Solving,assert_eq!(model.boolean_value_of(b), None);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,assert_eq!(model.boolean_value_of(a), Some(false));
Solving,assert_eq!(model.boolean_value_of(b), Some(true));
Solving,let writer = ReasonerId::Sat;
Solving,let model = &mut Model::new();
Solving,let a = model.new_bvar("a");
Solving,let b = model.new_bvar("b");
Solving,let c = model.new_bvar("c");
Solving,let d = model.new_bvar("d");
Solving,assert_eq!(model.boolean_value_of(a), values[0]);
Solving,assert_eq!(model.boolean_value_of(b), values[1]);
Solving,assert_eq!(model.boolean_value_of(c), values[2]);
Solving,assert_eq!(model.boolean_value_of(d), values[3]);
Solving,};
Solving,check_values(model, [None, None, None, None]);
Solving,let mut sat = SatSolver::new(writer);
Solving,let clause = vec![a.true_lit(), b.true_lit(), c.true_lit(), d.true_lit()];
Solving,sat.add_clause(&clause);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,check_values(model, [None, None, None, None]);
Solving,model.save_state();
Solving,model.state.decide(a.false_lit()).unwrap();
Solving,check_values(model, [Some(false), None, None, None]);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,check_values(model, [Some(false), None, None, None]);
Solving,model.save_state();
Solving,model.state.decide(b.false_lit()).unwrap();
Solving,check_values(model, [Some(false), Some(false), None, None]);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,check_values(model, [Some(false), Some(false), None, None]);
Solving,model.save_state();
Solving,model.state.decide(c.true_lit()).unwrap();
Solving,check_values(model, [Some(false), Some(false), Some(true), None]);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,check_values(model, [Some(false), Some(false), Some(true), None]);
Solving,model.save_state();
Solving,model.state.decide(d.false_lit()).unwrap();
Solving,check_values(model, [Some(false), Some(false), Some(true), Some(false)]);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,check_values(model, [Some(false), Some(false), Some(true), Some(false)]);
Solving,model.restore_last();
Solving,check_values(model, [Some(false), Some(false), Some(true), None]);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,check_values(model, [Some(false), Some(false), Some(true), None]);
Solving,model.restore_last();
Solving,check_values(model, [Some(false), Some(false), None, None]);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,check_values(model, [Some(false), Some(false), None, None]);
Solving,model.state.decide(c.false_lit()).unwrap();
Solving,check_values(model, [Some(false), Some(false), Some(false), None]);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,check_values(model, [Some(false), Some(false), Some(false), Some(true)]);
Solving,let writer = ReasonerId::Sat;
Solving,let model = &mut Model::new();
Solving,let a = model.new_bvar("a");
Solving,let b = model.new_bvar("b");
Solving,let mut sat = SatSolver::new(writer);
Solving,let a_or_b = vec![a.true_lit(), b.true_lit()];
Solving,sat.add_clause(&a_or_b);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,assert_eq!(model.boolean_value_of(a), None);
Solving,assert_eq!(model.boolean_value_of(b), None);
Solving,model.state.set(a.false_lit(), Cause::Decision).unwrap();
Solving,model.state.set(b.false_lit(), Cause::Decision).unwrap();
Solving,assert_eq!(model.boolean_value_of(a), Some(false));
Solving,assert_eq!(model.boolean_value_of(b), Some(false));
Solving,assert!(sat.propagate(&mut model.state).is_err());
Solving,let writer = ReasonerId::Sat;
Solving,let model = &mut Model::new();
Solving,let a = model.new_bvar("a");
Solving,let b = model.new_bvar("b");
Solving,let c = model.new_bvar("c");
Solving,let d = model.new_bvar("d");
Solving,let mut sat = SatSolver::new(writer);
Solving,assert_eq!(model.boolean_value_of(a), values[0], "a");
Solving,assert_eq!(model.boolean_value_of(b), values[1], "b");
Solving,assert_eq!(model.boolean_value_of(c), values[2], "c");
Solving,assert_eq!(model.boolean_value_of(d), values[3], "d");
Solving,};
Solving,check_values(model, [None, None, None, None]);
Solving,model.state.set(a.false_lit(), Cause::Decision).unwrap();
Solving,model.state.set(b.false_lit(), Cause::Decision).unwrap();
Solving,check_values(model, [Some(false), Some(false), None, None]);
Solving,let abcd = &[a.true_lit(), b.true_lit(), c.true_lit(), d.true_lit()];
Solving,sat.add_clause(abcd);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,check_values(model, [Some(false), Some(false), None, None]);
Solving,let nota_notb = &[a.false_lit(), b.false_lit()];
Solving,sat.add_clause(nota_notb);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,check_values(model, [Some(false), Some(false), None, None]);
Solving,let nota_b = &[a.false_lit(), b.true_lit()];
Solving,sat.add_clause(nota_b);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,check_values(model, [Some(false), Some(false), None, None]);
Solving,let a_b_notc = &[a.true_lit(), b.true_lit(), c.false_lit()];
Solving,sat.add_clause(a_b_notc);
Solving,check_values(model, [Some(false), Some(false), Some(false), Some(true)]);
Solving,let violated = &[a.true_lit(), b.true_lit(), c.true_lit(), d.false_lit()];
Solving,sat.add_clause(violated);
Solving,assert!(sat.propagate(&mut model.state).is_err());
Solving,let writer = ReasonerId::Sat;
Solving,let model = &mut Model::new();
Solving,let a = model.new_ivar(0, 10, "a");
Solving,let b = model.new_ivar(0, 10, "b");
Solving,let c = model.new_ivar(0, 10, "c");
Solving,let d = model.new_ivar(0, 10, "d");
Solving,assert_eq!(model.domain_of(a), values[0]);
Solving,assert_eq!(model.domain_of(b), values[1]);
Solving,assert_eq!(model.domain_of(c), values[2]);
Solving,assert_eq!(model.domain_of(d), values[3]);
Solving,};
Solving,check_values(model, [(0, 10), (0, 10), (0, 10), (0, 10)]);
Solving,let mut sat = SatSolver::new(writer);
Solving,let clause = &[Lit::leq(a, 5), Lit::leq(b, 5)];
Solving,sat.add_clause(clause);
Solving,let clause = &[Lit::geq(c, 5), Lit::geq(d, 5)];
Solving,sat.add_clause(clause);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,check_values(model, [(0, 10), (0, 10), (0, 10), (0, 10)]);
Solving,model.state.set_lb(a, 4, Cause::Decision).unwrap();
Solving,check_values(model, [(4, 10), (0, 10), (0, 10), (0, 10)]);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,check_values(model, [(4, 10), (0, 10), (0, 10), (0, 10)]);
Solving,model.state.set_lb(a, 5, Cause::Decision).unwrap();
Solving,check_values(model, [(5, 10), (0, 10), (0, 10), (0, 10)]);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,check_values(model, [(5, 10), (0, 10), (0, 10), (0, 10)]);
Solving,model.save_state();
Solving,sat.save_state();
Solving,model.state.set_lb(a, 6, Cause::Decision).unwrap();
Solving,check_values(model, [(6, 10), (0, 10), (0, 10), (0, 10)]);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,check_values(model, [(6, 10), (0, 5), (0, 10), (0, 10)]);
Solving,model.restore_last();
Solving,sat.restore_last();
Solving,check_values(model, [(5, 10), (0, 10), (0, 10), (0, 10)]);
Solving,model.state.set_lb(a, 8, Cause::Decision).unwrap();
Solving,check_values(model, [(8, 10), (0, 10), (0, 10), (0, 10)]);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,check_values(model, [(8, 10), (0, 5), (0, 10), (0, 10)]);
Solving,model.state.set_ub(c, 6, Cause::Decision).unwrap();
Solving,check_values(model, [(8, 10), (0, 5), (0, 6), (0, 10)]);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,check_values(model, [(8, 10), (0, 5), (0, 6), (0, 10)]);
Solving,model.state.set_ub(c, 5, Cause::Decision).unwrap();
Solving,check_values(model, [(8, 10), (0, 5), (0, 5), (0, 10)]);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,check_values(model, [(8, 10), (0, 5), (0, 5), (0, 10)]);
Solving,model.save_state();
Solving,sat.save_state();
Solving,model.state.set_ub(c, 4, Cause::Decision).unwrap();
Solving,check_values(model, [(8, 10), (0, 5), (0, 4), (0, 10)]);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,check_values(model, [(8, 10), (0, 5), (0, 4), (5, 10)]);
Solving,model.restore_last();
Solving,sat.restore_last();
Solving,check_values(model, [(8, 10), (0, 5), (0, 5), (0, 10)]);
Solving,model.state.set_ub(c, 2, Cause::Decision).unwrap();
Solving,check_values(model, [(8, 10), (0, 5), (0, 2), (0, 10)]);
Solving,sat.propagate(&mut model.state).unwrap();
Solving,check_values(model, [(8, 10), (0, 5), (0, 2), (5, 10)]);
Solving,let m = &mut Model::new();
Solving,self.sat.explain(literal, cause.payload, model, explanation);
Solving,let result = m.state.implying_literals(lit, &mut Exp { sat }).unwrap();
Solving,assert_eq!(result.to_set(), expected.to_set());
Solving,let px = m.new_presence_variable(Lit::TRUE, "px").true_lit();
Solving,let x1 = m.new_optional_bvar(px, "x1").true_lit();
Solving,let x2 = m.new_optional_bvar(px, "x2").true_lit();
Solving,let py = m.new_presence_variable(Lit::TRUE, "py").true_lit();
Solving,let y1 = m.new_optional_bvar(py, "y1").true_lit();
Solving,let y2 = m.new_optional_bvar(py, "y2").true_lit();
Solving,let pz = m.get_conjunctive_scope(&[px, py]);
Solving,let z1 = m.new_optional_bvar(pz, "z1").true_lit();
Solving,let z2 = m.new_optional_bvar(pz, "z2").true_lit();
Solving,let sat = &mut SatSolver::new(ReasonerId::Sat);
Solving,m.save_state();
Solving,sat.save_state();
Solving,sat.add_clause_scoped(&[x1, x2], px);
Solving,m.state.decide(!x1).unwrap();
Solving,sat.propagate(&mut m.state).unwrap();
Solving,assert!(m.entails(x2));
Solving,assert!(m.value_of_literal(px).is_none());
Solving,check_explanation(m, sat, x2, [!x1]);
Solving,assert!(!m.entails(!py));
Solving,sat.add_clause_scoped(&[!y2, y1], py);
Solving,sat.add_clause_scoped(&[!y2, !y1], py);
Solving,m.state.decide(y2).unwrap();
Solving,sat.propagate(&mut m.state).unwrap();
Solving,assert!(m.entails(!py));
Solving,m.reset();
Solving,m.save_state();
Solving,sat.reset();
Solving,sat.save_state();
Solving,assert!(!m.entails(!py));
Solving,sat.add_clause_scoped(&[y1, y2], py);
Solving,m.state.decide(!y1).unwrap();
Solving,m.state.decide(!y2).unwrap();
Solving,sat.propagate(&mut m.state).unwrap();
Solving,assert!(m.entails(!py));
Solving,check_explanation(m, sat, !py, [!y1, !y2]);
Solving,m.reset();
Solving,m.save_state();
Solving,sat.reset();
Solving,sat.save_state();
Solving,assert!(!m.entails(!pz));
Solving,sat.add_clause_scoped(&[z1, z2], pz);
Solving,m.state.decide(pz).unwrap();
Solving,m.state.decide(!z1).unwrap();
Solving,m.state.decide(!z2).unwrap();
Solving,assert!(sat.propagate(&mut m.state).is_err());
Solving,pub mod clauses;
Solving,mod sat_solver;
Solving,pub use sat_solver::*;
Solving,use crate::backtrack::{Backtrack, DecLvl, EventIndex, ObsTrail, ObsTrailCursor};
Solving,use crate::core::literals::Watches;
Solving,use crate::core::state::{Domains, DomainsSnapshot, Explanation, InvalidUpdate};
Solving,use crate::core::{IntCst, Lit, SignedVar, VarRef, INT_CST_MIN};
Solving,use crate::model::{Label, Model};
Solving,use crate::reasoners::eq::domain;
Solving,use crate::reasoners::{Contradiction, ReasonerId, Theory};
Solving,use crate::reif::ReifExpr;
Solving,use itertools::Itertools;
Solving,use std::collections::{HashMap, HashSet};
Solving,use std::fmt::{Debug, Formatter};
Solving,use InferenceCause::*;
Solving,use InferenceCause::*;
Solving,let kind = value & 0x1;
Solving,let payload = value >> 1;
Solving,let src = src.into();
Solving,let tgt = tgt.into();
Solving,let key = DirEdgeId { src, tgt };
Solving,debug_assert!(self.labels.contains_key(&key), "Not label for {:?}", key);
Solving,let src = src.into();
Solving,let tgt = tgt.into();
Solving,let key = DirEdgeId { src, tgt };
Solving,debug_assert!(self.labels.contains_key(&key), "Not label for {:?}", key);
Solving,type DomainEvent = crate::core::state::Event;
Solving,writeln!(f, "num edge props1 {}", self.num_edge_propagations)?;
Solving,writeln!(f, "num edge props+ {}", self.num_edge_propagations_pos)?;
Solving,writeln!(f, "num edge props- {}", self.num_edge_propagations_neg)?;
Solving,writeln!(f, "num edge props1 ++  {}", self.num_edge_propagation1_pos_pos)?;
Solving,writeln!(f, "num edge props1 +-  {}", self.num_edge_propagation1_pos_neg)?;
Solving,writeln!(f, "num edge props1 -+  {}", self.num_edge_propagation1_neg_pos)?;
Solving,writeln!(f, "num edge props1 eff  {}", self.num_edge_propagation1_effective)?;
Solving,writeln!(f, "num edge props2 ++  {}", self.num_edge_propagation2_pos_pos)?;
Solving,writeln!(f, "num edge props2 +-  {}", self.num_edge_propagation2_pos_neg)?;
Solving,self.num_edge_propagations += rhs.num_edge_propagations;
Solving,self.num_edge_propagations_pos += rhs.num_edge_propagations_pos;
Solving,self.num_edge_propagations_neg += rhs.num_edge_propagations_neg;
Solving,self.num_edge_propagation1_pos_pos += rhs.num_edge_propagation1_pos_pos;
Solving,self.num_edge_propagation1_pos_neg += rhs.num_edge_propagation1_pos_neg;
Solving,self.num_edge_propagation1_neg_pos += rhs.num_edge_propagation1_neg_pos;
Solving,self.num_edge_propagation1_effective += rhs.num_edge_propagation1_effective;
Solving,self.num_edge_propagation2_pos_pos += rhs.num_edge_propagation2_pos_pos;
Solving,self.num_edge_propagation2_pos_neg += rhs.num_edge_propagation2_pos_neg;
Solving,self.num_edge_propagation2_neg_pos += rhs.num_edge_propagation2_neg_pos;
Solving,let watches = self.graph.watches.watches_on(event).collect_vec();
Solving,self.try_enable_edge(e, domains);
Solving,};
Solving,self.graph.watches.add_watch(de, label);
Solving,self.graph.watches.add_watch(de, !label);
Solving,self.graph.watches.add_watch(de, active);
Solving,.insert(DirEdgeId { src, tgt }, DirEdgeLabel { label, active });
Solving,let (lb, ub) = model.domain(Node::Var(var));
Solving,self.graph.domains.add_value(var, val, label);
Solving,self.try_enable_edge(de, model.domains());
Solving,let v = v.into();
Solving,return;
Solving,let (lb, ub) = model.domain(v);
Solving,self.add_node(val, model);
Solving,self.graph.succs_pos.insert(v, Vec::new());
Solving,self.graph.preds_pos.insert(v, Vec::new());
Solving,self.graph.succs_neg.insert(v, Vec::new());
Solving,self.graph.preds_neg.insert(v, Vec::new());
Solving,let label = model.reify_eq(v, other);
Solving,let out_active = model.n_presence_implication(other, v);
Solving,self.add_dir_edge(v, other, label, out_active, model);
Solving,let in_active = model.n_presence_implication(v, other);
Solving,self.add_dir_edge(other, v, label, in_active, model);
Solving,self.graph.nodes.insert(v);
Solving,self.graph.nodes_ordered.push(v);
Solving,// println!("  try add: {e:?}");
Solving,debug_assert!(!self.graph.succs_pos[&e.src].iter().any(|ee| ee.succ == e.tgt));
Solving,debug_assert!(!self.graph.succs_neg[&e.src].iter().any(|ee| ee.succ == e.tgt));
Solving,.push(OutEdge::new(e.tgt, e.label, e.active));
Solving,.push(InEdge::new(e.src, e.label, e.active));
Solving,self.trail.push(Event::EdgeEnabledPos(e));
Solving,.push(OutEdge::new(e.tgt, e.label, e.active));
Solving,.push(InEdge::new(e.src, e.label, e.active));
Solving,self.trail.push(Event::EdgeEnabledNeg(e));
Solving,self.graph.enabled.insert(e.id());
Solving,let mut in_to_check: Vec<Node> = Vec::with_capacity(64);
Solving,let mut out_to_check: Vec<Node> = Vec::with_capacity(64);
Solving,self.stats.num_edge_propagations += 1;
Solving,let src = e.src;
Solving,let tgt = e.tgt;
Solving,debug_assert!(domains.entails(e.active));
Solving,debug_assert!(domains.value(e.label).is_some());
Solving,self.stats.num_edge_propagations_pos += 1;
Solving,let p_outs = self.graph.succs_pos.remove(&tgt).unwrap();
Solving,continue;
Solving,self.stats.num_edge_propagation1_pos_pos += 1;
Solving,debug_assert!(domains.entails(out.active));
Solving,debug_assert!(domains.entails(out.label));
Solving,return Err(e);
Solving,out_to_check.push(out.succ);
Solving,self.stats.num_edge_propagation1_effective += 1;
Solving,let n_outs = self.graph.succs_neg.remove(&tgt).unwrap();
Solving,continue;
Solving,self.stats.num_edge_propagation1_pos_neg += 1;
Solving,debug_assert!(domains.entails(out.active));
Solving,debug_assert!(domains.entails(!out.label));
Solving,return Err(e);
Solving,out_to_check.push(out.succ);
Solving,self.stats.num_edge_propagation1_effective += 1;
Solving,self.graph.succs_neg.insert(tgt, n_outs).map(|_| unreachable!());
Solving,let p_ins = self.graph.preds_pos.remove(&src).unwrap();
Solving,continue;
Solving,self.stats.num_edge_propagation1_pos_pos += 1;
Solving,debug_assert!(domains.entails(inc.active));
Solving,debug_assert!(domains.entails(inc.label));
Solving,return Err(e);
Solving,in_to_check.push(inc.pred);
Solving,self.stats.num_edge_propagation1_effective += 1;
Solving,self.graph.preds_pos.insert(src, p_ins).map(|_| unreachable!());
Solving,let n_ins = self.graph.preds_neg.remove(&src).unwrap();
Solving,continue;
Solving,self.stats.num_edge_propagation1_pos_neg += 1;
Solving,debug_assert!(domains.entails(inc.active));
Solving,debug_assert!(!domains.entails(inc.label));
Solving,return Err(e);
Solving,in_to_check.push(inc.pred);
Solving,self.stats.num_edge_propagation1_effective += 1;
Solving,self.graph.preds_neg.insert(src, n_ins).map(|_| unreachable!());
Solving,debug_assert!(domains.entails(!e.label));
Solving,self.stats.num_edge_propagations_neg += 1;
Solving,let p_outs = self.graph.succs_pos.remove(&tgt).unwrap();
Solving,self.stats.num_edge_propagation1_neg_pos += 1;
Solving,debug_assert!(domains.entails(out.active));
Solving,debug_assert!(domains.entails(out.label));
Solving,return Err(e);
Solving,out_to_check.push(out.succ);
Solving,self.stats.num_edge_propagation1_effective += 1;
Solving,self.graph.succs_pos.insert(tgt, p_outs).map(|_| unreachable!());
Solving,let p_ins = self.graph.preds_pos.remove(&src).unwrap();
Solving,self.stats.num_edge_propagation1_neg_pos += 1;
Solving,debug_assert!(domains.entails(inc.active));
Solving,debug_assert!(domains.entails(inc.label));
Solving,return Err(e);
Solving,in_to_check.push(inc.pred);
Solving,self.stats.num_edge_propagation1_effective += 1;
Solving,self.graph.preds_pos.insert(src, p_ins).map(|_| unreachable!());
Solving,let y = tgt;
Solving,let mut xys_pos = Vec::with_capacity(64);
Solving,let mut xys_neg = Vec::with_capacity(64);
Solving,continue;
Solving,let e = self.graph.labels[&DirEdgeId { src: x, tgt: y }];
Solving,debug_assert!(domains.entails(e.active));
Solving,let mut yzs_pos = Vec::with_capacity(64);
Solving,let mut yzs_neg = Vec::with_capacity(64);
Solving,continue;
Solving,let e = self.graph.labels[&DirEdgeId { src: y, tgt: z }];
Solving,debug_assert!(domains.entails(e.active));
Solving,continue;
Solving,self.stats.num_edge_propagation2_pos_pos += 1;
Solving,self.set_edge_label(true, x, y, z, domains)?;
Solving,continue;
Solving,self.stats.num_edge_propagation2_pos_neg += 1;
Solving,self.set_edge_label(false, x, y, z, domains)?;
Solving,continue;
Solving,self.set_edge_label(false, x, y, z, domains)?;
Solving,self.stats.num_edge_propagation2_neg_pos += 1;
Solving,let label = self.graph.label(x, z);
Solving,let label = if value { label } else { !label };
Solving,);
Solving,let event = Event::EdgePropagation { x, y, z };
Solving,let id = self.trail.push(event);
Solving,let cause = self.identity().cause(InferenceCause::EdgePropagation(id));
Solving,let id = DirEdgeId { src: x, tgt: z };
Solving,let lbl = self.graph.labels[&id];
Solving,};
Solving,let new_literal = v.leq(new_ub);
Solving,let val_rep = self.graph.domains.value(var, value);
Solving,debug_assert_eq!(val_rep, Some(new_literal));
Solving,debug_assert!(domains.entails(new_literal));
Solving,let cause = self.identity().cause(InferenceCause::DomEq);
Solving,domains.set_lb(var, value, cause)?;
Solving,domains.set_ub(var, value, cause)?;
Solving,let cause = self.identity().cause(InferenceCause::DomNeq);
Solving,domains.set_lb(var, value + 1, cause)?;
Solving,domains.set_ub(var, value - 1, cause)?;
Solving,// dbg!(invalid, v, new_ub + 1, previous_ub);
Solving,};
Solving,domains.set(!invalid, cause)?;
Solving,let mut updated_ub = new_ub;
Solving,updated_ub -= 1;
Solving,let cause = self.identity().cause(InferenceCause::DomNeq);
Solving,domains.set(v.leq(updated_ub), cause)?;
Solving,break;
Solving,let v = v.variable();
Solving,let cause = self.identity().cause(InferenceCause::DomSingleton);
Solving,domains.set(l, cause)?;
Solving,let a = a.into();
Solving,let b = b.into();
Solving,return Lit::TRUE;
Solving,self.add_node(a, model);
Solving,self.add_node(b, model);
Solving,use crate::backtrack::BacktrackWith;
Solving,self.graph.succs_pos.get_mut(&e.src).unwrap().pop().unwrap();
Solving,self.graph.preds_pos.get_mut(&e.tgt).unwrap().pop().unwrap();
Solving,assert!(self.graph.enabled.remove(&e.id()));
Solving,self.graph.succs_neg.get_mut(&e.src).unwrap().pop().unwrap();
Solving,self.graph.preds_neg.get_mut(&e.tgt).unwrap().pop().unwrap();
Solving,assert!(self.graph.enabled.remove(&e.id()));
Solving,let mut new_event_treated = false;
Solving,self.propagate_new_edge(*e, domains)?;
Solving,self.propagate_new_edge(*e, domains)?;
Solving,new_event_treated = true;
Solving,self.update_graph(ev.new_literal(), domains);
Solving,self.propagate_domain_event(ev.affected_bound, ev.new_upper_bound, ev.previous.upper_bound, domains)?;
Solving,new_event_treated = true;
Solving,break;
Solving,debug_assert_eq!(context.writer, self.identity());
Solving,let signed_var = l.svar();
Solving,let variable = signed_var.variable();
Solving,let value = l.ub_value();
Solving,let cause = InferenceCause::from(context.payload);
Solving,let event = self.trail.get_event(event_index);
Solving,};
Solving,let ab_act = self.graph.active(a, b);
Solving,debug_assert!(domains.entails(ab_act), "Propagation occurred on inactive edges.");
Solving,out_explanation.push(ab_act);
Solving,let ab_lbl = self.graph.label(a, b);
Solving,};
Solving,push_causes(x, y);
Solving,push_causes(y, z);
Solving,let val_eqs = self.graph.domains.values(signed_var, INT_CST_MIN, value).iter().rev();
Solving,out_explanation.push(l);
Solving,break;
Solving,let previous = value + 1;
Solving,let neq = !self.graph.domains.value(variable, previous).unwrap_or(Lit::FALSE);
Solving,debug_assert!(domains.entails(neq));
Solving,out_explanation.push(neq);
Solving,let previous_bound = Lit::leq(variable, previous);
Solving,debug_assert!(domains.entails(previous_bound));
Solving,out_explanation.push(previous_bound);
Solving,debug_assert!(signed_var.is_minus());
Solving,let value = -value;
Solving,let previous = value - 1;
Solving,let neq = !self.graph.domains.value(variable, previous).unwrap_or(Lit::FALSE);
Solving,debug_assert!(domains.entails(neq));
Solving,debug_assert!(domains.entails(previous_bound));
Solving,out_explanation.push(previous_bound);
Solving,let (var, value) = self.graph.domains.neq_watches(l).next().unwrap();
Solving,let (var, value) = self.graph.domains.neq_watches(l).next().unwrap();
Solving,let (var, value) = self.graph.domains.eq_watches(l).next().unwrap();
Solving,out_explanation.push(Lit::geq(var, value));
Solving,out_explanation.push(Lit::leq(var, value));
Solving,println!("num nodes: {}", self.graph.nodes_ordered.len());
Solving,println!("num edge props1 {}", self.stats.num_edge_propagations);
Solving,println!("num edge props+ {}", self.stats.num_edge_propagations_pos);
Solving,println!("num edge props- {}", self.stats.num_edge_propagations_neg);
Solving,println!("num edge props1 ++  {}", self.stats.num_edge_propagation1_pos_pos);
Solving,println!("num edge props1 +-  {}", self.stats.num_edge_propagation1_pos_neg);
Solving,println!("num edge props1 -+  {}", self.stats.num_edge_propagation1_neg_pos);
Solving,println!("num edge props1 eff  {}", self.stats.num_edge_propagation1_effective);
Solving,println!("num edge props2 ++  {}", self.stats.num_edge_propagation2_pos_pos);
Solving,println!("num edge props2 +-  {}", self.stats.num_edge_propagation2_pos_neg);
Solving,println!("num edge props2 -+  {}", self.stats.num_edge_propagation2_neg_pos);
Solving,fn domains(&self) -> &Domains;
Solving,fn domain(&self, a: Node) -> (IntCst, IntCst);
Solving,fn reify_eq(&mut self, a: Node, b: Node) -> Lit;
Solving,fn presence_implication(&self, a: VarRef, b: VarRef) -> Lit;
Solving,use Node::*;
Solving,let e = if a < b { ReifExpr::Eq(a, b) } else { ReifExpr::Eq(b, a) };
Solving,let e = ReifExpr::EqVal(a, b);
Solving,let pa = self.state.presence(a);
Solving,let pb = self.state.presence(b);
Solving,use crate::backtrack::{Backtrack, EventIndex};
Solving,use crate::core::state::{Cause, Domains, SingleTheoryExplainer};
Solving,use crate::core::{IntCst, Lit, VarRef};
Solving,use crate::model::lang::expr::eq;
Solving,use crate::model::symbols::SymbolTable;
Solving,use crate::model::types::TypeHierarchy;
Solving,use crate::model::{Label, Model};
Solving,use crate::reasoners::eq::dense::InferenceCause;
Solving,use crate::reasoners::eq::{DenseEqTheory, Node, ReifyEq};
Solving,use crate::reasoners::{Contradiction, Theory};
Solving,use crate::solver::search::random::RandomChoice;
Solving,use crate::solver::Solver;
Solving,use crate::utils::input::Sym;
Solving,use itertools::Itertools;
Solving,use rand::prelude::SmallRng;
Solving,use rand::{Rng, SeedableRng};
Solving,use std::collections::{HashMap, HashSet};
Solving,use std::sync::Arc;
Solving,let a = a.into();
Solving,let b = b.into();
Solving,let mut map = HashMap::new();
Solving,let key = Pair::new(vars[i], vars[j]);
Solving,map.insert(key, domains.new_var(0, 1).geq(1));
Solving,let key = Pair::new(vars[i], Node::Val(v));
Solving,map.insert(key, domains.new_var(0, 1).geq(1));
Solving,let a = a.into();
Solving,let b = b.into();
Solving,use Node::*;
Solving,assert_ne!(a, b);
Solving,let domains = &mut Domains::new();
Solving,let x = domains.new_var(0, 10);
Solving,let a = domains.new_var(0, 10);
Solving,let b = domains.new_var(0, 10);
Solving,let b1 = domains.new_var(0, 10);
Solving,let b2 = domains.new_var(0, 10);
Solving,let d = domains.new_var(0, 10);
Solving,let d2 = domains.new_var(0, 10);
Solving,let vars = [x, a, b, b1, b2, d, d2];
Solving,let mut eqs = Eqs::init(&vars, domains);
Solving,let mut theory = DenseEqTheory::new(0);
Solving,domains.set(label, Cause::Decision).expect("Decision error");
Solving,theory.propagate(domains).expect("Propagation error");
Solving,};
Solving,println!("Check {:?}  !=  {:?}", eq1, eq2);
Solving,assert_eq!(domains.value(eqs.get(x, y)), Some(true), "{x:?} = {y:?}");
Solving,assert_eq!(domains.value(eqs.get(x, z)), Some(false), "{x:?} = {z:?}");
Solving,assert_eq!(domains.value(eqs.get(x, y)), Some(true), "{x:?} = {y:?}");
Solving,};
Solving,set(eqs.get(x, a), domains);
Solving,set(eqs.get(b2, b1), domains);
Solving,set(eqs.get(d2, d), domains);
Solving,set(eqs.get(b, b1), domains);
Solving,println!("SETTING !=");
Solving,set(!eqs.get(b, d), domains);
Solving,assert_eq!(domains.value(eqs.get(b, b1)), Some(true));
Solving,assert_eq!(domains.value(eqs.get(b, b2)), Some(true));
Solving,assert_eq!(domains.value(eqs.get(b, d)), Some(false));
Solving,assert_eq!(domains.value(eqs.get(b, d2)), Some(false));
Solving,assert_eq!(domains.value(eqs.get(a, b)), None);
Solving,set(eqs.get(a, b), domains);
Solving,check(&[a, b, b1, b2, x], &[d, d2], domains);
Solving,theory.print_stats();
Solving,let domains = &mut Domains::new();
Solving,let a = domains.new_var(0, 10);
Solving,let b = domains.new_var(0, 10);
Solving,let c = domains.new_var(0, 10);
Solving,let vars = [a, b, c];
Solving,let eqs = &mut Eqs::init(&vars, domains);
Solving,let mut theory = DenseEqTheory::new(0);
Solving,let ab = theory.add_edge(a, b, eqs);
Solving,let bc = theory.add_edge(b, c, eqs);
Solving,let ac = theory.add_edge(a, c, eqs);
Solving,theory.propagate(domains).unwrap();
Solving,domains.save_state();
Solving,theory.save_state();
Solving,domains.set(ab, Cause::Decision).expect("Invalid decision");
Solving,theory.propagate(domains).unwrap();
Solving,domains.save_state();
Solving,theory.save_state();
Solving,domains.set(bc, Cause::Decision).expect("Invalid decision");
Solving,theory.propagate(domains).unwrap();
Solving,assert_eq!(domains.value(ac), Some(true));
Solving,domains.restore_last();
Solving,theory.restore_last();
Solving,domains.save_state();
Solving,theory.save_state();
Solving,domains.set(!bc, Cause::Decision).expect("Invalid decision");
Solving,theory.propagate(domains).unwrap();
Solving,assert_eq!(domains.value(!ac), Some(true));
Solving,domains.restore_last();
Solving,theory.restore_last();
Solving,domains.save_state();
Solving,theory.save_state();
Solving,domains.set(ac, Cause::Decision).expect("Invalid decision");
Solving,domains.save_state();
Solving,theory.save_state();
Solving,domains.set(!bc, Cause::Decision).expect("Invalid decision");
Solving,};
Solving,let explainer = &mut SingleTheoryExplainer(&mut theory);
Solving,};
Solving,println!("ab: {ab:?}, bc: {bc:?}, ac: {ac:?}");
Solving,println!("Clause: {:?}", clause);
Solving,);
Solving,type S = &'static str;
Solving,let types = value.iter().map(|e| (Sym::new(e.0), None)).collect_vec();
Solving,let types = TypeHierarchy::new(types).unwrap();
Solving,let mut instances = Vec::new();
Solving,let symbols = SymbolTable::from(vec![("obj", vec!["alice", "bob", "chloe"])]);
Solving,let symbols = Arc::new(symbols);
Solving,let obj = symbols.types.id_of("obj").unwrap();
Solving,let mut model: Model<S> = Model::new_with_symbols(symbols.clone());
Solving,.collect_vec();
Solving,model.reify(eq(x, y));
Solving,random_solves(&model, 10, Some(true));
Solving,let model = model.clone();
Solving,let solver = &mut Solver::new(model);
Solving,solver.set_brancher(RandomChoice::new(seed));
Solving,let solution = solver.solve().unwrap().is_some();
Solving,expected_result = Some(solution);
Solving,solver.print_stats();
Solving,let mut rng = SmallRng::seed_from_u64(seed);
Solving,let objects = ["alice", "bob", "chloe", "donald", "elon"];
Solving,let num_objects = rng.gen_range(1..5);
Solving,let objects = objects[0..num_objects].to_vec();
Solving,let symbols = SymbolTable::from(vec![("obj", objects.clone())]);
Solving,let symbols = Arc::new(symbols);
Solving,let obj = symbols.types.id_of("obj").unwrap();
Solving,let mut model: Model<String> = Model::new_with_symbols(symbols.clone());
Solving,let num_scopes = rng.gen_range(0..3);
Solving,.collect_vec();
Solving,let num_vars = rng.gen_range(0..10);
Solving,println!("Problem num_scopes: {num_scopes}, num_vars:  {num_vars}  num_values: {num_objects}");
Solving,let mut vars = Vec::with_capacity(num_vars);
Solving,let scope_id = rng.gen_range(0..scopes.len());
Solving,let scope = scopes[scope_id];
Solving,let var_name = format!("x{i}");
Solving,println!("  {var_name} [{scope_id}]  in {:?}", &objects);
Solving,let var = model.new_optional_sym_var(obj, scope, var_name);
Solving,model.reify(eq(x, y));
Solving,let model = random_model(seed);
Solving,random_solves(&model, 10, Some(true));
Solving,let serialized: u32 = c.into();
Solving,};
Solving,];
Solving,assert_eq!(t, serde(t));
Solving,use crate::core::literals::Watches;
Solving,use crate::core::{cst_int_to_long, IntCst, Lit, SignedVar, VarRef};
Solving,use std::collections::HashMap;
Solving,use std::ops::RangeInclusive;
Solving,assert!(!self.bounds().contains(&value), "duplicated inclusion");
Solving,self.first_value = value;
Solving,self.value_literals.push(lit);
Solving,assert_eq!(value, self.max() + 1);
Solving,self.value_literals.push(lit);
Solving,let first = (cst_int_to_long(first) - cst_int_to_long(self.first_value)).max(0) as usize;
Solving,let last = last.min(self.value_literals.len() - 1);
Solving,.add_value(value, lit);
Solving,self.eq_watches.add_watch((var, value), lit);
Solving,self.neq_watches.add_watch((var, value), !lit);
Solving,let dom = &self.domains[&v.variable()];
Solving,let dom = &self.domains[&v];
Solving,let dom = &self.domains[&v.variable()];
Solving,use crate::backtrack::{Backtrack, DecLvl, DecisionLevelTracker};
Solving,use crate::core::state::{Domains, DomainsSnapshot, Explanation, InferenceCause};
Solving,use crate::core::{IntCst, Lit, VarRef};
Solving,use crate::reasoners::eq::{DenseEqTheory, Node, ReifyEq};
Solving,use crate::reasoners::{Contradiction, ReasonerId, Theory};
Solving,use itertools::Itertools;
Solving,use std::collections::HashMap;
Solving,type PartId = u16;
Solving,debug_assert_eq!(self.lvl.num_saved(), 0, "Adding an edge but not at the root");
Solving,let l = model.reify_eq(Node::Var(a), Node::Var(b));
Solving,let domains = model.domains();
Solving,self.parts[pa as usize].as_mut().unwrap().add_node(b, model);
Solving,self.part_of.insert(b, pa);
Solving,self.parts[pb as usize].as_mut().unwrap().add_node(a, model);
Solving,self.part_of.insert(a, pb);
Solving,debug_assert!(self.parts.len() < u16::MAX as usize);
Solving,self.parts.push(None);
Solving,};
Solving,let mut group = DenseEqTheory::new(id);
Solving,group.add_node(a, model);
Solving,group.add_node(b, model);
Solving,group.add_edge(a, b, model);
Solving,self.part_of.insert(a, id);
Solving,self.part_of.insert(b, id);
Solving,self.parts[id as usize] = Some(group);
Solving,debug_assert!(self.parts[id as usize].as_ref().unwrap().variables().contains(&a));
Solving,debug_assert!(self.parts[id as usize].as_ref().unwrap().variables().contains(&b));
Solving,debug_assert_ne!(pa, pb);
Solving,let (first, second) = if pa < pb { (pa, pb) } else { (pb, pa) };
Solving,debug_assert!(self.parts[second as usize].is_some());
Solving,let to_delete = self.parts[second as usize].take().unwrap();
Solving,let final_group = self.parts[first as usize].as_mut().unwrap();
Solving,final_group.add_node(var, model);
Solving,self.part_of.insert(var, first);
Solving,debug_assert!(self.part_of.iter().all(|(_var, part)| *part != second));
Solving,debug_assert_eq!(self.lvl.num_saved(), 0, "Adding an edge but not at the root");
Solving,let l = model.reify_eq(Node::Var(var), Node::Val(val));
Solving,let domains = model.domains();
Solving,self.parts[*pid as usize].as_mut().unwrap().add_node(val, model);
Solving,debug_assert!(self.parts.len() < u16::MAX as usize);
Solving,self.parts.push(None);
Solving,};
Solving,let mut group = DenseEqTheory::new(id);
Solving,group.add_node(var, model);
Solving,group.add_node(val, model);
Solving,self.part_of.insert(var, id);
Solving,self.parts[id as usize] = Some(group);
Solving,part.save_state();
Solving,self.lvl.restore_last();
Solving,part.propagate(model)?;
Solving,};
Solving,.explain(literal, context, model, out_explanation);
Solving,let mut stats = crate::reasoners::eq::dense::Stats::default();
Solving,stats += part.stats.clone();
Solving,println!("{stats:?}");
Solving,mod dense;
Solving,mod domain;
Solving,mod split;
Solving,pub use dense::*;
Solving,pub use split::SplitEqTheory;
Solving,use crate::backtrack::EventIndex;
Solving,use crate::core::{IntCst, Lit, SignedVar};
Solving,use crate::reasoners::stn::theory::contraint_db::Enabler;
Solving,use crate::reasoners::stn::theory::{Timepoint, W};
Solving,pub(crate) struct PropagatorId(u32);
Solving,use state::{Domains, DomainsSnapshot};
Solving,use crate::backtrack::EventIndex;
Solving,use crate::collections::ref_store::{Ref, RefMap};
Solving,use crate::core::*;
Solving,use crate::reasoners::stn::theory::PropagatorId;
Solving,use std::cell::RefCell;
Solving,use std::cmp::{Ordering, Reverse};
Solving,use std::collections::{BinaryHeap, HashMap};
Solving,use std::hash::Hash;
Solving,use std::marker::PhantomData;
Solving,use super::contraint_db::Enabler;
Solving,use super::StnTheory;
Solving,struct Reversed<'a, V: Copy, E: Copy, G: Graph<V, E>>(&'a G, PhantomData<V>, PhantomData<E>);
Solving,let edge = self.0.edge(e);
Solving,fn vertices(&self) -> impl Iterator<Item = V> + '_;
Solving,fn outgoing(&self, v: V) -> impl Iterator<Item = Edge<V, E>> + '_;
Solving,fn incoming(&self, v: V) -> impl Iterator<Item = Edge<V, E>> + '_;
Solving,fn potential(&self, v: V) -> IntCst;
Solving,fn edge(&self, e: E) -> Edge<V, E>;
Solving,let mut relevants = Vec::new();
Solving,let mut heap: RelevantHeap<V, Label> = RelevantHeap::new();
Solving,self.relevants_no_alloc(new_edge, &mut relevants, &mut heap);
Solving,relevants.clear();
Solving,heap.clear();
Solving,let reduced_weight = new_edge.weight + self.potential(new_edge.src) - self.potential(new_edge.tgt);
Solving,let tgt_lbl = Label::new(reduced_weight as LongCst, true);
Solving,heap.insert(new_edge.tgt, tgt_lbl);
Solving,let src_lbl = Label::new(0, false);
Solving,heap.insert(new_edge.src, src_lbl);
Solving,let mut remaining_relevants: u32 = 1;
Solving,debug_assert_eq!(lbl, *heap.best(curr).unwrap());
Solving,let dist = dist - (self.potential(new_edge.src) as LongCst) + (self.potential(curr)) as LongCst;
Solving,relevants.push((curr, dist - (new_edge.weight as LongCst)));
Solving,remaining_relevants -= 1;
Solving,let reduced_cost = out.weight + self.potential(out.src) - self.potential(out.tgt);
Solving,debug_assert!(reduced_cost >= 0);
Solving,let lbl = Label::new(dist + (reduced_cost as LongCst), relevant);
Solving,debug_assert!(previous_label.dist <= lbl.dist);
Solving,remaining_relevants += 1;
Solving,remaining_relevants += 1;
Solving,heap.insert(out.tgt, lbl);
Solving,// there is no hope of finding new relevants;
Solving,break;
Solving,return false;
Solving,let mut result = Vec::with_capacity(16);
Solving,let mut last = tgt;
Solving,result.push(inc);
Solving,let edge = self.edge(inc);
Solving,last = edge.src;
Solving,let mut preds = Predecessors::default();
Solving,let mut heap = BinaryHeap::new();
Solving,heap.push((-0, src, None));
Solving,continue;
Solving,preds.set(curr, pred);
Solving,let reduced_dist = -neg_dist;
Solving,let dist = reduced_dist - self.potential(src) + self.potential(tgt);
Solving,return Some((dist, preds));
Solving,let reduced_cost = self.potential(out.src) + out.weight - self.potential(out.tgt);
Solving,debug_assert!(reduced_cost >= 0);
Solving,let lbl = neg_dist - reduced_cost;
Solving,heap.push((lbl, out.tgt, Some(out.id)));
Solving,let mut pot_updates = PotentialUpdate::new();
Solving,let mut heap = RelevantHeap::new();
Solving,self.updated_on_addition_no_alloc(source, target, weight, id, &mut pot_updates, &mut heap);
Solving,let new_edge = &Edge::new(source, target, weight, id);
Solving,pot_updates.clear();
Solving,self.relevants_no_alloc(new_edge, &mut pot_updates.postfixes, heap);
Solving,let reversed = self.reversed();
Solving,reversed.relevants_no_alloc(&new_edge.reverse(), &mut pot_updates.prefixes, heap);
Solving,pot_updates.buiild_prefix_lookup();
Solving,self.best.insert(v, lbl);
Solving,self.heap.push((Reverse(lbl), v));
Solving,self.elements.push(v);
Solving,self.best.insert(v, lbl);
Solving,self.heap.push((Reverse(lbl), v));
Solving,};
Solving,let lbl = rev_lbl.0;
Solving,return Some((v, lbl));
Solving,self.heap.clear();
Solving,self.best.remove(*e);
Solving,self.elements.clear();
Solving,type L = IntCst;
Solving,self.prefix_lookup.remove(*var);
Solving,self.prefixes.clear();
Solving,self.postfixes.clear();
Solving,debug_assert!(!self.is_set(v));
Solving,self.preds.insert(v, e);
Solving,pub type StnEdge = Edge<SignedVar, PropagatorId>;
Solving,let prop = &self.stn.constraints[e];
Solving,let c = &self.stn.constraints[prop_id];
Solving,let mut last_enabler = c.enabler?;
Solving,let mut last_weight = c.weight;
Solving,return Some((last_weight, last_enabler.0));
Solving,debug_assert_eq!(*prop, prop_id);
Solving,last_enabler = (*previous_enabler)?;
Solving,last_weight = *previous_weight;
Solving,let prop = &self.stn.constraints[e];
Solving,use super::*;
Solving,use crate::core::IntCst;
Solving,use itertools::Itertools;
Solving,use rand::prelude::SeedableRng;
Solving,use rand::prelude::SmallRng;
Solving,use rand::Rng;
Solving,use std::collections::HashMap;
Solving,use std::iter::once;
Solving,type V = usize;
Solving,let mut smaller = self.clone();
Solving,let edge = smaller.edges.pop().unwrap();
Solving,};
Solving,let mut potential = HashMap::with_capacity(32);
Solving,potential.insert(e.src, 0);
Solving,potential.insert(e.tgt, 0);
Solving,let num_vertices = potential.len();
Solving,let mut num_iters = 0;
Solving,let mut update_in_iter = true;
Solving,num_iters += 1;
Solving,return None;
Solving,update_in_iter = false;
Solving,let prev = potential[&e.tgt];
Solving,let update = potential[&e.src] + e.weight;
Solving,potential.insert(e.tgt, update);
Solving,update_in_iter = true;
Solving,);
Solving,let edge = self.edges[e];
Solving,let mut graph = Vec::new();
Solving,let mut rng = SmallRng::seed_from_u64(seed);
Solving,let num_vertices = rng.gen_range(4..10);
Solving,let num_edges = rng.gen_range(2..=15);
Solving,let src = rng.gen_range(0..num_vertices);
Solving,let tgt = rng.gen_range(0..num_vertices);
Solving,let weight = rng.gen_range(-10..=10);
Solving,let edge = TestEdge { src, tgt, weight };
Solving,graph.push(edge);
Solving,graph.pop().unwrap();
Solving,.unwrap();
Solving,assert_eq!(g.shortest_distance(1, 2), Some(1));
Solving,assert_eq!(g.shortest_distance(1, 3), Some(4));
Solving,assert_eq!(g.shortest_distance(1, 4), Some(2));
Solving,.unwrap();
Solving,assert_eq!(g.shortest_distance(1, 2), Some(-1));
Solving,assert_eq!(g.shortest_distance(1, 4), Some(-1));
Solving,assert_eq!(g.shortest_distance(1, 3), Some(0));
Solving,]));
Solving,]));
Solving,]));
Solving,]));
Solving,let graphs = (0..1000).map(gen_graph).collect_vec();
Solving,let (added_edge, original_graph) = final_graph.pop_edge();
Solving,dbg!(&original_graph.edges);
Solving,let updated = original_graph.relevants(&added_edge);
Solving,let updated: HashMap<V, LongCst> = updated.into_iter().collect();
Solving,let previous = original_graph.shortest_distance(added_edge.src, other);
Solving,let new = final_graph.shortest_distance(added_edge.src, other);
Solving,};
Solving,let present_in_updated = updated.contains_key(&other);
Solving,assert_eq!(new_sp, present_in_updated, "{:?} -> {:?}", added_edge.src, other);
Solving,);
Solving,let graphs = (0..1000).map(gen_graph).collect_vec();
Solving,let (added_edge, original_graph) = final_graph.pop_edge();
Solving,original_graph.updated_on_addition(added_edge.src, added_edge.tgt, added_edge.weight, added_edge.id);
Solving,.collect();
Solving,let previous = original_graph.shortest_distance(orig, dest);
Solving,let new = final_graph.shortest_distance(orig, dest);
Solving,};
Solving,let present_in_updated = updated_paths.contains_key(&(orig, dest));
Solving,let graphs = (0..1000).map(gen_graph).collect_vec();
Solving,let orig = 0;
Solving,let dest = 1;
Solving,let dist = graph.shortest_distance(orig, dest);
Solving,let path = graph.shortest_path(orig, dest);
Solving,let path = path.unwrap();
Solving,let path_dist = path.into_iter().map(|e| graph.edge(e).weight).sum();
Solving,assert_eq!(dist, path_dist);
Solving,assert!(path.is_none());
Solving,use std::{cell::RefCell, cmp::Reverse};
Solving,};
Solving,};
Solving,dij.clear();
Solving,);
Solving,stn.pending_bound_changes.clear();
Solving,self.potential.remove(v);
Solving,self.init.remove(v);
Solving,// debug_assert!(self.potential.is_empty() && self.init.is_empty());
Solving,self.modified_vars.clear();
Solving,self.heap.clear();
Solving,// println!("mod {v:?}  {previous_ub} -> {ub}");
Solving,let pos = self.modified_vars.iter().position(|e| *e == v).unwrap();
Solving,self.modified_vars.swap_remove(pos);
Solving,self.init.remove(v);
Solving,// println!("  pot");
Solving,debug_assert!(self.init.contains(v));
Solving,debug_assert!(self.potential[v] > previous_ub);
Solving,debug_assert!(self.init[v] > ub);
Solving,self.init.insert(v, ub);
Solving,debug_assert!(!self.init.contains(v));
Solving,self.potential.insert(v, previous_ub);
Solving,self.modified_vars.push(v);
Solving,self.init.insert(v, ub);
Solving,let mut deactivations = hashbrown::HashSet::new();
Solving,let origin_potential = INT_CST_MAX;
Solving,// println!("p {v:?}");
Solving,// println!("  absent");
Solving,continue;
Solving,debug_assert!(stn.constraints.is_vertex(v));
Solving,let ub = self.init[v];
Solving,// println!("init {v:?}  <= {ub:?}");
Solving,debug_assert_eq!(ub, doms.ub(v));
Solving,let reduced_cost = origin_potential + ub - self.potential[v];
Solving,self.heap.insert_init(v, reduced_cost);
Solving,continue;
Solving,debug_assert!(self.potential.contains(v), "potential should have been set already");
Solving,let source_potential = self.potential[v];
Solving,let new_source_ub = reduced_cost - origin_potential + self.potential[v];
Solving,// println!("pop {v:?}  <= {new_source_ub:?}");
Solving,let pred = self.heap.pred.get(v).copied().unwrap();
Solving,let prez = doms.presence(v);
Solving,stn.last_disabling_timestamp.insert(pred, stn.trail.next_event());
Solving,let cause = stn.identity.inference(ModelUpdateCause::CyclicEdgePropagation(pred));
Solving,doms.set(!prez, cause)?;
Solving,debug_assert!(doms.present(v) == Some(false),);
Solving,continue;
Solving,);
Solving,debug_assert!(stn.constraints[pred].target == v);
Solving,);
Solving,.inference(ModelUpdateCause::EdgePropagation(pred));
Solving,let changed_something = doms.set_ub(v, new_source_ub, cause)?;
Solving,"We should always change the bound except in the corner case where the literal was set as part of an edge deactivation");
Solving,stn.stats.bound_updates += 1;
Solving,let cause = &stn.constraints[pred];
Solving,debug_assert!(cause.target == v);
Solving,});
Solving,debug_assert!(self.init.contains(v));
Solving,continue;
Solving,let x = v;
Solving,let dist_o_x = new_source_ub;
Solving,let y = out.target;
Solving,let w = out.weight;
Solving,let consequence = y.leq(dist_o_x + w);
Solving,let dist_y_o = -doms.lb(y);
Solving,let cycle_length = dist_o_x + w + dist_y_o;
Solving,debug_assert!(doms.entails(!consequence));
Solving,.inference(ModelUpdateCause::TheoryPropagationBoundsDeactivation(out.id));
Solving,let change = doms.set(!out.presence, cause)?;
Solving,stn.stats.num_bound_edge_deactivation += 1;
Solving,deactivations.insert(!out.presence);
Solving,// println!("disabled: {:?}", !out.presence);
Solving,let target = outgoing.target;
Solving,continue;
Solving,let current_ub = doms.ub(target);
Solving,// println!("  out  -- {} -> target   [<= {current_ub}]", outgoing.weight);
Solving,self.potential.insert(target, current_ub);
Solving,self.modified_vars.push(target);
Solving,let target_potential = self.potential[target];
Solving,);
Solving,let new_target_ub = new_source_ub + outgoing.weight;
Solving,let target_reduced_cost = reduced_cost + outgoing.weight + source_potential - target_potential;
Solving,self.heap.clear();
Solving,self.pred.clear();
Solving,self.heap.declare_element(v, Reverse(cost));
Solving,self.heap.enqueue(v);
Solving,self.heap.declare_element(v, Reverse(cost));
Solving,debug_assert!(!self.pred.contains(v));
Solving,self.pred.insert(v, pred);
Solving,self.heap.enqueue(v);
Solving,);
Solving,self.pred.insert(v, pred);
Solving,let k = self.heap.pop();
Solving,use crate::backtrack::{Backtrack, DecLvl, Trail};
Solving,use crate::collections::ref_store::RefVec;
Solving,use crate::collections::set::RefSet;
Solving,use crate::core::literals::Watches;
Solving,use crate::core::{Lit, SignedVar};
Solving,use crate::reasoners::stn::theory::edges::*;
Solving,use std::collections::HashMap;
Solving,use std::ops::{Index, IndexMut};
Solving,self.next_new_constraint += 1;
Solving,let constraint = &self.propagators[propagator];
Solving,let x = constraint.dyn_weight.unwrap();
Solving,assert_eq!(x.valid, enabler.valid);
Solving,assert_eq!(x.var_ub, enabler.active.svar());
Solving,});
Solving,self.watches.add_watch((enabler, propagator), enabler.active);
Solving,self.watches.add_watch((enabler, propagator), enabler.active);
Solving,self.watches.add_watch((enabler, propagator), enabler.valid);
Solving,self.intermittent_propagators.fill_with(constraint.source, Vec::new);
Solving,});
Solving,self.trail.push(Event::EnablerAdded(propagator, enabler));
Solving,let optimize_layout = self.trail.current_decision_level() == DecLvl::ROOT && prop.dyn_weight.is_none();
Solving,self.propagator_indices.entry((prop.source, prop.target)).or_default();
Solving,let existing = &mut self.propagators[id];
Solving,existing.enablers.push(prop.enabler);
Solving,return (id, PropagatorIntegration::Merged(prop.enabler));
Solving,return (id, PropagatorIntegration::Noop);
Solving,e.weight = prop.weight;
Solving,break;
Solving,existing.weight = prop.weight;
Solving,return (id, PropagatorIntegration::Tightened(prop.enabler));
Solving,return (id, PropagatorIntegration::Noop);
Solving,let source = prop.source;
Solving,let target = prop.target;
Solving,let enabler = prop.enabler;
Solving,};
Solving,self.vertices.insert(prop.source);
Solving,self.vertices.insert(prop.target);
Solving,let id = self.propagators.push(prop);
Solving,self.propagator_indices.entry((source, target)).or_default().push(id);
Solving,self.trail.push(Event::PropagatorGroupAdded);
Solving,type Output = PropagatorGroup;
Solving,let prop = self.propagators.pop().unwrap();
Solving,.pop();
Solving,self.watches.remove_watch((enabler, propagator), enabler.active);
Solving,self.watches.remove_watch((enabler, propagator), enabler.valid);
Solving,let constraint = &self.propagators[propagator];
Solving,self.intermittent_propagators[constraint.source].pop();
Solving,use crate::backtrack::Backtrack;
Solving,use crate::core::literals::Disjunction;
Solving,use crate::core::state::{Cause, DomainsSnapshot, Explainer, Explanation, InferenceCause};
Solving,use crate::core::{IntCst, Lit, SignedVar};
Solving,use crate::model::Model;
Solving,use crate::reasoners::stn::theory::{StnConfig, StnTheory, Timepoint, W};
Solving,use crate::reasoners::{Contradiction, Theory};
Solving,let model = Model::new();
Solving,let stn = StnTheory::new(StnConfig::default());
Solving,let model = Model::new();
Solving,let stn = StnTheory::new(config);
Solving,self.model.state.set_lb(timepoint, lb, Cause::Decision).unwrap();
Solving,self.model.state.set_ub(timepoint, ub, Cause::Decision).unwrap();
Solving,let valid_edge = self.get_conjunctive_scope(source, target);
Solving,let active_edge = self.model.get_tautology_of_scope(valid_edge);
Solving,debug_assert!(self.model.state.entails(active_edge));
Solving,.add_dynamic_edge(source, target, ub_var, ub_factor, &self.model.state);
Solving,let valid_edge = self.get_conjunctive_scope(source, target);
Solving,.true_lit();
Solving,.add_reified_edge(active_edge, source, target, weight, &self.model.state);
Solving,self.add_edge(b.into(), a.into(), -delay);
Solving,let pa = self.model.state.presence(a);
Solving,let pb = self.model.state.presence(b);
Solving,self.model.state.decide(edge).unwrap();
Solving,self.model.save_state();
Solving,self.stn.set_backtrack_point();
Solving,self.model.restore_last();
Solving,self.stn.undo_to_last_backtrack_point();
Solving,assert!(self.propagate_all().is_ok());
Solving,assert!(self.propagate_all().is_err());
Solving,assert_eq!(cause.writer, self.stn.identity.writer_id);
Solving,self.stn.explain(literal, cause, model, explanation);
Solving,let mut explanation = Explanation::new();
Solving,explanation.push(literal);
Solving,assert_eq!(cause.writer, self.stn.identity.writer_id);
Solving,self.stn.explain(literal, cause, model, explanation);
Solving,let mut explanation = Explanation::new();
Solving,explanation.push(literal);
Solving,mod stn_impl;
Solving,pub mod theory;
Solving,pub use stn_impl::Stn;
Solving,mod bound_propagation;
Solving,mod contraint_db;
Solving,mod distances;
Solving,mod edges;
Solving,use crate::backtrack::{Backtrack, EventIndex};
Solving,use crate::backtrack::{DecLvl, ObsTrailCursor, Trail};
Solving,use crate::collections::ref_store::{RefMap, RefVec};
Solving,use crate::core::state::*;
Solving,use crate::core::*;
Solving,use crate::reasoners::stn::theory::Event::EdgeActivated;
Solving,use crate::reasoners::{Contradiction, ReasonerId, Theory};
Solving,use contraint_db::*;
Solving,use distances::{Graph, StnGraph};
Solving,use edges::*;
Solving,use env_param::EnvParam;
Solving,use itertools::Itertools;
Solving,use std::collections::VecDeque;
Solving,use std::convert::*;
Solving,use std::marker::PhantomData;
Solving,use std::str::FromStr;
Solving,type ModelEvent = crate::core::state::Event;
Solving,pub type Timepoint = VarRef;
Solving,pub type W = IntCst;
Solving,EnvParam::new("ARIES_STN_THEORY_PROPAGATION", "bounds");
Solving,pub static STN_EXTENSIVE_TESTS: EnvParam<bool> = EnvParam::new("ARIES_STN_EXTENSIVE_TESTS", "false");
Solving,type Err = String;
Solving,type BacktrackLevel = DecLvl;
Solving,let determinant = enc & 0b11;
Solving,let payload = enc >> 2;
Solving,self.active_propagators.push(Vec::new());
Solving,self.active_propagators.push(Vec::new());
Solving,self.incoming_active_propagators.push(Vec::new());
Solving,self.incoming_active_propagators.push(Vec::new());
Solving,let source = source.into();
Solving,let target = target.into();
Solving,self.reserve_timepoint();
Solving,let edge_valid = domains.presence(literal.variable());
Solving,debug_assert!(domains.implies(edge_valid, domains.presence(source)));
Solving,debug_assert!(domains.implies(edge_valid, domains.presence(target)));
Solving,};
Solving,};
Solving,];
Solving,self.record_propagator(p, domains);
Solving,let source = source.into();
Solving,let target = target.into();
Solving,self.add_half_reified_edge(literal, source, target, weight, domains);
Solving,self.add_half_reified_edge(!literal, target, source, -weight - 1, domains);
Solving,let source = src.into();
Solving,let target = tgt.into();
Solving,self.reserve_timepoint();
Solving,let edge_valid = domains.presence(ub_var);
Solving,debug_assert!(domains.implies(edge_valid, domains.presence(source)));
Solving,debug_assert!(domains.implies(edge_valid, domains.presence(target)));
Solving,let cur_var_ub = domains.ub(ub_var);
Solving,let cur_ub = cur_var_ub.saturating_mul(ub_factor).clamp(INT_CST_MIN, INT_CST_MAX);
Solving,let literal = ub_var.leq(cur_var_ub);
Solving,};
Solving,};
Solving,];
Solving,.collect_vec();
Solving,let watch_entries = self.dyn_edges.get_mut_or_insert(ub_var, || Vec::with_capacity(2));
Solving,watch_entries.push(prop_id);
Solving,let &Enabler { active, valid } = &prop.enabler;
Solving,let edge_valid = domains.presence(active.variable());
Solving,let (prop, new_enabler) = self.constraints.add_propagator(prop);
Solving,});
Solving,self.constraints.add_propagator_enabler(prop, enabler);
Solving,self.constraints[prop].enabler = None;
Solving,});
Solving,let mut expl = Explanation::with_capacity(culprits.len());
Solving,debug_assert!(self.active(edge));
Solving,let enabler = self.constraints[edge].enabler;
Solving,let enabler = enabler.expect("No established enabler for this edge").0;
Solving,debug_assert!(model.entails(enabler.active) && model.entails(enabler.valid));
Solving,expl.push(enabler.active);
Solving,expl.push(enabler.valid);
Solving,debug_assert!(self.active(propagator));
Solving,let c = &self.constraints[propagator];
Solving,let val = event.ub_value();
Solving,debug_assert_eq!(event.svar(), c.target);
Solving,debug_assert!(model.entails(l));
Solving,out_explanation.push(l);
Solving,};
Solving,let var_ub = model.ub(dyn_weight.var_ub);
Solving,let weight = var_ub.saturating_mul(dyn_weight.factor).clamp(INT_CST_MIN, INT_CST_MAX);
Solving,add_to_expl(dyn_weight.valid);
Solving,add_to_expl(dyn_weight.var_ub.leq(var_ub));
Solving,add_to_expl(c.source.leq(val - weight));
Solving,let enabler = c.enabler.expect("inactive constraint").0;
Solving,add_to_expl(enabler.active);
Solving,add_to_expl(enabler.valid);
Solving,let cause = c.source.leq(val - c.weight);
Solving,add_to_expl(cause);
Solving,let c = &self.constraints[c_id];
Solving,let new_ub = model.ub(c.source) + c.weight;
Solving,let current_lb = model.lb(c.target);
Solving,.inference(ModelUpdateCause::TheoryPropagationBoundsDeactivation(c_id));
Solving,let change = model.set(!l.active, cause)?;
Solving,self.stats.num_bound_edge_deactivation += 1;
Solving,};
Solving,let literal = ev.new_literal();
Solving,});
Solving,.push_back(ActivationEvent::ToUpdate { edge: prop_id });
Solving,});
Solving,bound_propagation::process_bound_changes(self, model, |_| false)?;
Solving,// self.assert_fully_bound_propagated(model);
Solving,// debug_assert!(StnGraph::new(self, model).is_potential_valid());
Solving,let c = &mut self.constraints[edge];
Solving,self.explanation.clear();
Solving,return Err(self.build_contradiction(&self.explanation, model));
Solving,debug_assert_ne!(c.source, c.target);
Solving,let activation_event = self.trail.push(EdgeActivated(edge));
Solving,c.enabler = Some((enabler, activation_event));
Solving,let c = &mut self.constraints[edge];
Solving,c.index_in_active = self.active_propagators[c.source].len() as u32;
Solving,});
Solving,c.index_in_incoming_active = self.incoming_active_propagators[c.target].len() as u32;
Solving,});
Solving,let redundant = -model.lb(c.source) + model.ub(c.target) <= c.weight;
Solving,let prop = &mut self.constraints[edge];
Solving,let dyn_weight = prop.dyn_weight.unwrap();
Solving,let previous_weight = prop.weight;
Solving,let previous_enabler = prop.enabler;
Solving,.clamp(INT_CST_MIN, INT_CST_MAX);
Solving,});
Solving,prop.weight = new_weight;
Solving,let activation = dyn_weight.var_ub.leq(model.ub(dyn_weight.var_ub));
Solving,));
Solving,let inlined = &mut self.active_propagators[prop.source][prop.index_in_active as usize];
Solving,debug_assert_eq!(inlined.id, edge);
Solving,debug_assert_eq!(inlined.weight, previous_weight);
Solving,inlined.weight = new_weight;
Solving,[prop.index_in_incoming_active as usize];
Solving,debug_assert_eq!(inlined.id, edge);
Solving,debug_assert_eq!(inlined.weight, previous_weight);
Solving,inlined.weight = new_weight;
Solving,};
Solving,self.propagate_new_edge(edge, model)?;
Solving,// debug_assert!(StnGraph::new(self, model).is_potential_valid());
Solving,self.theory_propagate_edge(edge, model)?;
Solving,continue;
Solving,assert!(doms.ub(prop.target) <= doms.ub(prop.source) + prop.weight);
Solving,assert!(doms.entails(e.active) || doms.present(e.active) == Some(false));
Solving,);
Solving,);
Solving,self.trail.save_state();
Solving,self.pending_activations.clear();
Solving,let c = &mut self.constraints[e];
Solving,self.active_propagators[c.source].pop();
Solving,self.incoming_active_propagators[c.target].pop();
Solving,c.enabler = None;
Solving,let c = &mut self.constraints[prop];
Solving,c.weight = previous_weight;
Solving,c.enabler = previous_enabler;
Solving,let inlined = &mut self.active_propagators[c.source][c.index_in_active as usize];
Solving,debug_assert_eq!(inlined.id, prop);
Solving,inlined.weight = previous_weight;
Solving,let inlined = &mut self.incoming_active_propagators[c.target][c.index_in_incoming_active as usize];
Solving,debug_assert_eq!(inlined.id, prop);
Solving,inlined.weight = previous_weight;
Solving,});
Solving,self.constraints.restore_last();
Solving,let c = &self.constraints[new_edge];
Solving,debug_assert_ne!(c.source, c.target, "This algorithm does not support self loops.");
Solving,let cause = self.identity.inference(ModelUpdateCause::EdgePropagation(new_edge));
Solving,let source = c.source;
Solving,let target = c.target;
Solving,let weight = c.weight;
Solving,let source_bound = model.ub(source);
Solving,let prev = model.ub(target);
Solving,let new = source_bound + weight;
Solving,debug_assert!(self.pending_bound_changes.is_empty());
Solving,});
Solving,bound_propagation::process_bound_changes(self, model, |v| v == source)?;
Solving,debug_assert!(model.entails(lit));
Solving,expl.push(lit);
Solving,};
Solving,let event_after = self.last_disabling_timestamp[propagator_id];
Solving,let graph = distances::StnSnapshotGraph::new(self, model, event_after);
Solving,let last_edge_of_cycle = &self.constraints[propagator_id];
Solving,let (last_edge_weight, last_edge_trigger) = graph.weight_enabler(propagator_id).unwrap();
Solving,add_to_explanation(last_edge_trigger.active);
Solving,add_to_explanation(last_edge_trigger.valid);
Solving,let mut curr = last_edge_of_cycle.source;
Solving,let mut cycle_length = last_edge_weight;
Solving,let ub = model.ub(curr);
Solving,let lit = Lit::leq(curr, ub);
Solving,debug_assert!(model.entails(lit));
Solving,let ev = model.implying_event(lit).unwrap();
Solving,let ev = model.get_event(ev);
Solving,};
Solving,let source = self.constraints[edge].source;
Solving,curr = source;
Solving,let (weight, trigger) = graph.weight_enabler(edge).unwrap();
Solving,cycle_length += weight;
Solving,add_to_explanation(trigger.active);
Solving,add_to_explanation(trigger.valid);
Solving,debug_assert!(cycle_length < 0, "cycle length: {cycle_length}");
Solving,break;
Solving,println!("# nodes: {}", self.num_nodes());
Solving,println!("# propagators: {}", self.constraints.num_propagator_groups());
Solving,println!("# propagations: {}", self.stats.num_propagations);
Solving,println!("# domain updates: {}", self.stats.bound_updates);
Solving,println!("# bounds deactivations: {}", self.stats.num_bound_edge_deactivation);
Solving,println!("# theory propagations: {}", self.stats.num_theory_propagations);
Solving,println!("# theory deactivations: {}", self.stats.num_theory_deactivations);
Solving,let constraint = &self.constraints[edge];
Solving,let target = constraint.target;
Solving,let source = constraint.source;
Solving,let weight = constraint.weight;
Solving,return Ok(());
Solving,self.stats.num_theory_propagations += 1;
Solving,let stn = StnGraph::new_excluding(self, model, edge);
Solving,stn.updated_on_addition_no_alloc(source, target, weight, edge, pot_updates, heap);
Solving,let orig = potential.target;
Solving,let new_path_length = dist_from_orig + (weight as LongCst) + dist_to_dest;
Solving,// let full_stn = StnGraph::new(self, model);
Solving,// let ssp = full_stn.shortest_distance(orig, dest);
Solving,);
Solving,self.stats.num_theory_deactivations += 1;
Solving,.insert(potential.id, self.trail.next_event());
Solving,res?;
Solving,debug_assert!(model.entails(l));
Solving,out_explanation.push(l);
Solving,};
Solving,debug_assert_eq!(context.writer, self.identity());
Solving,let context = context.payload;
Solving,let edge = &self.constraints[edge_id];
Solving,let src_ub = model.ub(edge.source);
Solving,let tgt_lb = model.lb(edge.target);
Solving,debug_assert!(src_ub + edge.weight < tgt_lb);
Solving,add_to_explanation(edge.source.leq(src_ub));
Solving,add_to_explanation(edge.target.geq(tgt_lb));
Solving,let edge = &self.constraints[edge_id];
Solving,let event_after = self.last_disabling_timestamp[edge_id];
Solving,let graph = distances::StnSnapshotGraph::new(self, model, event_after);
Solving,.expect("No explaining path in graph");
Solving,let mut path_length = 0;
Solving,.expect("Edge not active in the graph");
Solving,path_length += weight;
Solving,add_to_explanation(enabler.active);
Solving,debug_assert!(path_length + edge.weight < 0);
Solving,self.undo_to_last_backtrack_point();
Solving,use crate::model::extensions::AssignmentExt;
Solving,use crate::model::lang::IVar;
Solving,use crate::reasoners::stn::stn_impl::Stn;
Solving,use super::*;
Solving,let s = &mut Stn::new();
Solving,let a = s.add_timepoint(0, 10);
Solving,let b = s.add_timepoint(0, 10);
Solving,assert_eq!(stn.model.int_bounds(IVar::new(a)), (a_lb, a_ub));
Solving,assert_eq!(stn.model.int_bounds(IVar::new(b)), (b_lb, b_ub));
Solving,};
Solving,assert_bounds(s, 0, 10, 0, 10);
Solving,s.set_ub(a, 3);
Solving,s.add_edge(a, b, 5);
Solving,s.assert_consistent();
Solving,assert_bounds(s, 0, 3, 0, 8);
Solving,s.set_ub(a, 1);
Solving,s.assert_consistent();
Solving,assert_bounds(s, 0, 1, 0, 6);
Solving,let x = s.add_inactive_edge(a, b, 3);
Solving,s.mark_active(x);
Solving,s.assert_consistent();
Solving,assert_bounds(s, 0, 1, 0, 4);
Solving,let s = &mut Stn::new();
Solving,let a = s.add_timepoint(0, 10);
Solving,let b = s.add_timepoint(0, 10);
Solving,assert_eq!(stn.model.int_bounds(IVar::new(a)), (a_lb, a_ub));
Solving,assert_eq!(stn.model.int_bounds(IVar::new(b)), (b_lb, b_ub));
Solving,};
Solving,assert_bounds(s, 0, 10, 0, 10);
Solving,s.set_ub(a, 1);
Solving,s.assert_consistent();
Solving,assert_bounds(s, 0, 1, 0, 10);
Solving,s.set_backtrack_point();
Solving,let ab = s.add_edge(a, b, 5);
Solving,s.assert_consistent();
Solving,assert_bounds(s, 0, 1, 0, 6);
Solving,s.set_backtrack_point();
Solving,let ba = s.add_edge(b, a, -6);
Solving,s.assert_inconsistent(vec![ab, ba]);
Solving,s.undo_to_last_backtrack_point();
Solving,assert_bounds(s, 0, 1, 0, 6);
Solving,s.undo_to_last_backtrack_point();
Solving,assert_bounds(s, 0, 1, 0, 10);
Solving,let x = s.add_inactive_edge(a, b, 5);
Solving,s.mark_active(x);
Solving,s.assert_consistent();
Solving,assert_bounds(s, 0, 1, 0, 6);
Solving,let stn = &mut Stn::new();
Solving,let a = stn.add_timepoint(0, 10);
Solving,let b = stn.add_timepoint(0, 10);
Solving,let c = stn.add_timepoint(0, 10);
Solving,stn.propagate_all()?;
Solving,stn.set_backtrack_point();
Solving,let aa = stn.add_inactive_edge(a, a, -1);
Solving,stn.mark_active(aa);
Solving,stn.assert_inconsistent(vec![aa]);
Solving,stn.undo_to_last_backtrack_point();
Solving,stn.set_backtrack_point();
Solving,let ab = stn.add_edge(a, b, 2);
Solving,let ba = stn.add_edge(b, a, -3);
Solving,stn.assert_inconsistent(vec![ab, ba]);
Solving,stn.undo_to_last_backtrack_point();
Solving,stn.set_backtrack_point();
Solving,let ab = stn.add_edge(a, b, 2);
Solving,let _ = stn.add_edge(b, a, -2);
Solving,stn.assert_consistent();
Solving,let ba = stn.add_edge(b, a, -3);
Solving,stn.assert_inconsistent(vec![ab, ba]);
Solving,stn.undo_to_last_backtrack_point();
Solving,stn.set_backtrack_point();
Solving,let ab = stn.add_edge(a, b, 2);
Solving,let bc = stn.add_edge(b, c, 2);
Solving,let _ = stn.add_edge(c, a, -4);
Solving,stn.assert_consistent();
Solving,let ca = stn.add_edge(c, a, -5);
Solving,stn.assert_inconsistent(vec![ab, bc, ca]);
Solving,let stn = &mut Stn::new();
Solving,let prez_a = stn.model.new_bvar("prez_a").true_lit();
Solving,let a = stn.model.new_optional_ivar(0, 10, prez_a, "a");
Solving,let prez_b = stn.model.new_presence_variable(prez_a, "prez_b").true_lit();
Solving,let b = stn.model.new_optional_ivar(0, 10, prez_b, "b");
Solving,stn.add_delay(a, b, 0);
Solving,stn.propagate_all()?;
Solving,stn.model.state.set_lb(b, 1, Cause::Decision)?;
Solving,stn.model.state.set_ub(b, 9, Cause::Decision)?;
Solving,stn.propagate_all()?;
Solving,assert_eq!(stn.model.domain_of(a), (0, 10));
Solving,assert_eq!(stn.model.domain_of(b), (1, 9));
Solving,stn.model.state.set_lb(a, 2, Cause::Decision)?;
Solving,stn.propagate_all()?;
Solving,assert_eq!(stn.model.domain_of(a), (2, 10));
Solving,assert_eq!(stn.model.domain_of(b), (2, 9));
Solving,stn.model.state.set(prez_b, Cause::Decision)?;
Solving,stn.propagate_all()?;
Solving,assert_eq!(stn.model.domain_of(a), (2, 9));
Solving,assert_eq!(stn.model.domain_of(b), (2, 9));
Solving,let stn = &mut Stn::new();
Solving,let mut vars: Vec<(Lit, IVar)> = Vec::new();
Solving,let mut context = Lit::TRUE;
Solving,.true_lit();
Solving,let var = stn.model.new_optional_ivar(0, 20, prez, format!("var_{}", i));
Solving,stn.add_delay(vars[i - 1].1, var, 1);
Solving,vars.push((prez, var));
Solving,context = prez;
Solving,stn.propagate_all()?;
Solving,let i: IntCst = i.try_into().unwrap();
Solving,assert_eq!(stn.model.int_bounds(*var), (i, 20));
Solving,stn.model.state.set_ub(vars[5].1, 4, Cause::Decision)?;
Solving,stn.propagate_all()?;
Solving,let i: IntCst = i.try_into().unwrap();
Solving,assert_eq!(stn.model.int_bounds(*var), (i, 20));
Solving,});
Solving,let a = stn.model.new_ivar(10, 20, "a").into();
Solving,let prez_a1 = stn.model.new_bvar("prez_a1").true_lit();
Solving,let a1 = stn.model.new_optional_ivar(0, 30, prez_a1, "a1").into();
Solving,stn.add_delay(a, a1, 0);
Solving,stn.add_delay(a1, a, 0);
Solving,let b = stn.model.new_ivar(10, 20, "b").into();
Solving,let prez_b1 = stn.model.new_bvar("prez_b1").true_lit();
Solving,let b1 = stn.model.new_optional_ivar(0, 30, prez_b1, "b1").into();
Solving,stn.add_delay(b, b1, 0);
Solving,stn.add_delay(b1, b, 0);
Solving,let top = stn.add_inactive_edge(b, a, -1);
Solving,// let bottom = stn.add_inactive_edge(a1, b1, -1);
Solving,stn.propagate_all()?;
Solving,assert_eq!(stn.model.state.bounds(a1), (10, 20));
Solving,assert_eq!(stn.model.state.bounds(b1), (10, 20));
Solving,stn.model.state.set(top, Cause::Decision)?;
Solving,stn.propagate_all()?;
Solving,// assert!(stn.model.entails(!bottom));
Solving,//     let stn = &mut Stn::new();
Solving,//     let a = stn.add_timepoint(0, 10);
Solving,//     let b = stn.add_timepoint(0, 10);
Solving,//     let c = stn.add_timepoint(0, 10);
Solving,//     let d = stn.add_timepoint(0, 10);
Solving,//     let e = stn.add_timepoint(0, 10);
Solving,//     let f = stn.add_timepoint(0, 10);
Solving,//     stn.add_edge(a, b, 1);
Solving,//     stn.add_edge(a, c, 1);
Solving,//     stn.add_edge(c, d, 1);
Solving,//     stn.add_edge(b, e, 1);
Solving,//     stn.add_edge(d, e, 1);
Solving,//     stn.add_edge(e, f, 1);
Solving,//     stn.propagate_all()?;
Solving,//     let dists = stn.stn.forward_dist(a, &stn.model.state);
Solving,//     assert_eq!(dists.entries().count(), 6);
Solving,//     assert_eq!(dists[a], 0);
Solving,//     assert_eq!(dists[b], 1);
Solving,//     assert_eq!(dists[c], 1);
Solving,//     assert_eq!(dists[d], 2);
Solving,//     assert_eq!(dists[e], 2);
Solving,//     assert_eq!(dists[f], 3);
Solving,//     let dists = stn.stn.backward_dist(a, &stn.model.state);
Solving,//     assert_eq!(dists.entries().count(), 1);
Solving,//     assert_eq!(dists[a], 0);
Solving,//     let dists = stn.stn.backward_dist(f, &stn.model.state);
Solving,//     assert_eq!(dists.entries().count(), 6);
Solving,//     assert_eq!(dists[f], 0);
Solving,//     assert_eq!(dists[e], -1);
Solving,//     assert_eq!(dists[d], -2);
Solving,//     assert_eq!(dists[b], -2);
Solving,//     assert_eq!(dists[c], -3);
Solving,//     assert_eq!(dists[a], -3);
Solving,//     let dists = stn.stn.backward_dist(d, &stn.model.state);
Solving,//     assert_eq!(dists.entries().count(), 3);
Solving,//     assert_eq!(dists[d], 0);
Solving,//     assert_eq!(dists[c], -1);
Solving,//     assert_eq!(dists[a], -2);
Solving,let stn = &mut Stn::new();
Solving,let a = stn.add_timepoint(0, 1);
Solving,stn.add_edge(a, a, -1);
Solving,assert!(stn.propagate_all().is_err());
Solving,//     let stn = &mut Stn::new();
Solving,//     let a = stn.add_timepoint(0, 1);
Solving,//     let b = stn.add_timepoint(0, 10);
Solving,//     stn.add_edge(b, a, -1);
Solving,//     stn.propagate_all()?;
Solving,//     let dists = stn.stn.backward_dist(a, &stn.model.state);
Solving,//     assert_eq!(dists.entries().count(), 2);
Solving,//     assert_eq!(dists[a], 0);
Solving,//     assert_eq!(dists[b], 1);
Solving,});
Solving,let a = stn.add_timepoint(0, 10);
Solving,let b = stn.add_timepoint(0, 10);
Solving,// let d = stn.add_timepoint(0, 10);
Solving,// let e = stn.add_timepoint(0, 10);
Solving,// let f = stn.add_timepoint(0, 10);
Solving,stn.add_edge(a, b, 1);
Solving,let ba0 = stn.add_inactive_edge(b, a, 0);
Solving,let ba1 = stn.add_inactive_edge(b, a, -1);
Solving,let ba2 = stn.add_inactive_edge(b, a, -2);
Solving,assert_eq!(stn.model.state.value(ba0), None);
Solving,stn.propagate_all()?;
Solving,assert_eq!(stn.model.state.value(ba0), None);
Solving,assert_eq!(stn.model.state.value(ba1), None);
Solving,assert_eq!(stn.model.state.value(ba2), Some(false));
Solving,let exp = stn.explain_literal(!ba2);
Solving,assert!(exp.literals().is_empty());
Solving,// let ba3 = stn.add_inactive_edge(b, a, -3);
Solving,// stn.propagate_all();
Solving,// assert_eq!(stn.model.discrete.value(ba3), Some(false));
Solving,let c = stn.add_timepoint(0, 10);
Solving,let d = stn.add_timepoint(0, 10);
Solving,let e = stn.add_timepoint(0, 10);
Solving,let f = stn.add_timepoint(0, 10);
Solving,let g = stn.add_timepoint(0, 10);
Solving,stn.add_edge(b, c, 1);
Solving,stn.add_edge(c, d, 1);
Solving,let de = stn.add_inactive_edge(d, e, 1);
Solving,stn.add_edge(e, f, 1);
Solving,stn.add_edge(f, g, 1);
Solving,stn.propagate_all()?;
Solving,stn.set_backtrack_point();
Solving,stn.mark_active(de);
Solving,let ga0 = stn.add_inactive_edge(g, a, -5);
Solving,let ga1 = stn.add_inactive_edge(g, a, -6);
Solving,let ga2 = stn.add_inactive_edge(g, a, -7);
Solving,stn.propagate_all()?;
Solving,assert_eq!(stn.model.state.value(ga0), None);
Solving,assert_eq!(stn.model.state.value(ga1), None);
Solving,assert_eq!(stn.model.state.value(ga2), Some(false));
Solving,let exp = stn.explain_literal(!ga2);
Solving,assert_eq!(exp.len(), 1);
Solving,});
Solving,let a = stn.add_timepoint(0, 10);
Solving,let b = stn.add_timepoint(10, 20);
Solving,let edge_trigger = stn.add_inactive_edge(a, b, 0);
Solving,stn.propagate_all()?;
Solving,assert_eq!(stn.model.state.value(edge_trigger), None);
Solving,stn.set_backtrack_point();
Solving,stn.model.state.set_lb(b, 11, Cause::Decision)?;
Solving,assert_eq!(stn.model.state.value(edge_trigger), Some(false));
Solving,stn.undo_to_last_backtrack_point();
Solving,stn.set_backtrack_point();
Solving,stn.model.state.set_ub(a, 9, Cause::Decision)?;
Solving,stn.propagate_all()?;
Solving,assert_eq!(stn.model.state.value(edge_trigger), Some(false));
Solving,let max = 100;
Solving,let stn = &mut Stn::new();
Solving,let a = stn.add_timepoint(0, 0);
Solving,let b = stn.add_timepoint(0, 1000000);
Solving,let ub = stn.add_timepoint(0, max);
Solving,stn.add_dynamic_edge(a, b, SignedVar::plus(ub), 2);
Solving,stn.propagate_all()?;
Solving,stn.stn.print_stats();
Solving,println!("a:  {:?} {a:?}", stn.model.domain_of(a));
Solving,println!("b:  {:?} {b:?}", stn.model.domain_of(b));
Solving,println!("ub: {:?} {ub:?}", stn.model.domain_of(ub));
Solving,println!("dl: {:?}", stn.model.current_decision_level());
Solving,};
Solving,print(stn);
Solving,let mut implying = stn.implying_literals(Lit::leq(b, b_ub)).unwrap();
Solving,assert_eq!(implying.len(), 1);
Solving,};
Solving,stn.set_backtrack_point();
Solving,stn.model.state.set_ub(ub, max - i, Cause::Decision)?;
Solving,stn.propagate_all()?;
Solving,print(stn);
Solving,stn.stn.print_stats();
Solving,let b_ub = (max - i) * 2;
Solving,debug_assert_eq!(stn.model.domain_of(b), (0, b_ub));
Solving,//print(stn);
Solving,assert_eq!(cause_b_ub(stn, b_ub), Lit::leq(ub, max - i));
Solving,assert_eq!(cause_b_ub(stn, b_ub + 1), Lit::leq(ub, max - i));
Solving,assert_eq!(cause_b_ub(stn, 101), Lit::leq(ub, 50));
Solving,assert_eq!(cause_b_ub(stn, 100), Lit::leq(ub, 50));
Solving,assert_eq!(cause_b_ub(stn, 99), Lit::leq(ub, 49));
Solving,stn.stn.print_stats();
Solving,print(stn);
Solving,use crate::backtrack::Backtrack;
Solving,use crate::core::state::{Cause, DomainsSnapshot, Explainer, InferenceCause};
Solving,use crate::core::state::{Domains, Explanation, InvalidUpdate};
Solving,use crate::core::Lit;
Solving,use crate::reasoners::cp::Cp;
Solving,use crate::reasoners::eq::SplitEqTheory;
Solving,use crate::reasoners::sat::SatSolver;
Solving,use crate::reasoners::stn::theory::StnTheory;
Solving,use crate::reasoners::tautologies::Tautologies;
Solving,use std::fmt::{Display, Formatter};
Solving,pub mod cp;
Solving,pub mod eq;
Solving,pub mod sat;
Solving,pub mod stn;
Solving,pub mod tautologies;
Solving,use ReasonerId::*;
Solving,fn identity(&self) -> ReasonerId;
Solving,fn propagate(&mut self, model: &mut Domains) -> Result<(), Contradiction>;
Solving,);
Solving,fn print_stats(&self);
Solving,fn clone_box(&self) -> Box<dyn Theory>;
Solving,];
Solving,use crate::core::state::*;
Solving,use crate::core::*;
Solving,use crate::create_ref_type;
Solving,use crate::reasoners::Contradiction;
Solving,use super::Watches;
Solving,create_ref_type!(PropagatorId);
Solving,fn setup(&self, id: PropagatorId, context: &mut Watches);
Solving,fn propagate(&self, domains: &mut Domains, cause: Cause) -> Result<(), Contradiction>;
Solving,fn explain(&self, literal: Lit, state: &DomainsSnapshot, out_explanation: &mut Explanation);
Solving,fn clone_box(&self) -> Box<dyn Propagator>;
Solving,use super::*;
Solving,use crate::core::*;
Solving,use crate::core::state::*;
Solving,use crate::core::*;
Solving,use crate::reasoners::cp::propagator::*;
Solving,context.add_lit_watch(self.a, id);
Solving,context.add_lit_watch(!self.b, id);
Solving,domains.set(self.b, cause)?;
Solving,domains.set(!self.a, cause)?;
Solving,out_explanation.push(self.a);
Solving,out_explanation.push(!self.b);
Solving,use itertools::Itertools;
Solving,use rand::rngs::SmallRng;
Solving,use rand::seq::SliceRandom;
Solving,use rand::{Rng, SeedableRng};
Solving,let mut rng = SmallRng::seed_from_u64(0);
Solving,let mut problems = Vec::new();
Solving,let mut d = Domains::new();
Solving,let num_vars = rng.gen_range(2..=10);
Solving,let vars = (0..num_vars).map(|_| d.new_var(0, 10)).collect_vec();
Solving,let a = vars.choose(&mut rng).unwrap().leq(rng.gen_range(0..=10));
Solving,let b = vars.choose(&mut rng).unwrap().leq(rng.gen_range(0..=10));
Solving,let a = if rng.gen_bool(0.5) { a } else { !a };
Solving,let b = if rng.gen_bool(0.5) { b } else { !b };
Solving,problems.push((d, ImpliesProp { a, b }));
Solving,use crate::reasoners::cp::propagator::test::utils::*;
Solving,println!("\nConstraint: {s:?}");
Solving,test_explanations(&d, &s, true);
Solving,use itertools::Itertools;
Solving,use rand::{rngs::SmallRng, seq::SliceRandom, Rng, SeedableRng};
Solving,};
Solving,self.prop.explain(literal, model, explanation);
Solving,});
Solving,use crate::reasoners::cp::propagator::test::utils::pick_decisions;
Solving,let mut decisions_rng = SmallRng::seed_from_u64(0);
Solving,let mut rng = SmallRng::seed_from_u64(0);
Solving,println!("Warning: all variables are bound, no tests run");
Solving,return;
Solving,let decisions = pick_decisions(d, 1, 10, &mut decisions_rng);
Solving,// println!("decisions: {decisions:?}");
Solving,let mut d = d.clone();
Solving,d.save_state();
Solving,// println!("Decisions: ");
Solving,let res = d.set(dec, Cause::Decision);
Solving,// println!("  {dec:?}");
Solving,check_events(&d, propagator, check_minimality);
Solving,let mut expl = Explanation::with_capacity(16);
Solving,expl.push(!lit);
Solving,let mut explainer = explainer(propagator);
Solving,d.add_implying_literals_to_explanation(lit, cause, &mut expl, &mut explainer);
Solving,};
Solving,let mut d = d.clone();
Solving,d.reset();
Solving,let mut conjuncts = explanation.lits;
Solving,conjuncts.shuffle(&mut rng);
Solving,d.set(conjunct, Cause::Decision);
Solving,);
Solving,let num_decisions = rng.gen_range(min..=max);
Solving,let vars = d.variables().filter(|v| !d.is_bound(*v)).collect_vec();
Solving,let mut lits = Vec::with_capacity(num_decisions);
Solving,let var_id = rng.gen_range(0..vars.len());
Solving,let var = vars[var_id];
Solving,let (lb, ub) = d.bounds(var);
Solving,let below: bool = rng.gen();
Solving,let ub = rng.gen_range(lb..ub);
Solving,let lb = rng.gen_range((lb + 1)..=ub);
Solving,};
Solving,lits.push(lit);
Solving,.collect_vec();
Solving,check_event_explanation(s, ev, explainer, check_minimality);
Solving,let mut explainer = explainer(prop);
Solving,let implied = ev.new_literal();
Solving,let implicants = s.implying_literals(implied, &mut explainer).unwrap();
Solving,let clause = Disjunction::new(implicants.iter().map(|l| !*l).collect());
Solving,check_explanation_minimality(s, implied, clause, prop, check_minimality);
Solving,let mut domains = domains.clone();
Solving,// println!("=== original trail ===");
Solving,// solver.model.domains().trail().print();
Solving,domains.reset();
Solving,assert!(!domains.entails(implied));
Solving,.collect_vec();
Solving,.expect("failed prop");
Solving,let mut domains_save = domains.clone();
Solving,let mut domains = domains_save.clone();
Solving,// println!("Clause: {implied:?} <- {decisions:?}\n");
Solving,let l = decisions[i];
Solving,continue;
Solving,// println!("  Decide {l:?}");
Solving,domains.decide(l);
Solving,.expect("failed prop");
Solving,.collect_vec();
Solving,);
Solving,decisions.rotate_left(1);
Solving,use crate::backtrack::{DecLvl, EventIndex};
Solving,use crate::core::state::{Cause, Domains, DomainsSnapshot, Event, Explanation, InvalidUpdate};
Solving,};
Solving,use crate::reasoners::cp::{Propagator, PropagatorId, Watches};
Solving,use crate::reasoners::Contradiction;
Solving,use itertools::Itertools;
Solving,use num_integer::{div_ceil, div_floor, Integer};
Solving,use std::cmp::{Ordering, PartialEq};
Solving,use std::collections::BinaryHeap;
Solving,use std::fmt::{Debug, Formatter};
Solving,debug_assert!(self.factor >= 0);
Solving,write!(f, "{:?}", self.var)?;
Solving,write!(f, " * {}", self.factor)?;
Solving,debug_assert_ne!(factor, 0);
Solving,debug_assert!(self.factor > 0);
Solving,debug_assert!(self.factor > 0);
Solving,debug_assert!(self.factor > 0);
Solving,let var = self.var;
Solving,let ub = div_floor(ub, cst_int_to_long(self.factor));
Solving,let ub = cst_long_to_int(ub.clamp(cst_int_to_long(INT_CST_MIN), cst_int_to_long(INT_CST_MAX)));
Solving,let var_ub = domains.lb(elem.var);
Solving,let lit = Lit::geq(elem.var, var_ub);
Solving,let event = domains.implying_event(lit)?;
Solving,debug_assert_eq!(self.elem.var, -self.event().affected_bound);
Solving,let var_lb = -cst_int_to_long(self.event().new_upper_bound);
Solving,debug_assert_eq!(self.elem.var, -self.event().affected_bound);
Solving,let previous_var_lb = -cst_int_to_long(self.event().previous.upper_bound);
Solving,let index = self.event().previous.cause?;
Solving,};
Solving,debug_assert_eq!(previous.lb(), self.previous_lb());
Solving,debug_assert!(self > previous, "previous should have lower priority");
Solving,let prez = format!("[{:?}]", self.active);
Solving,write!(f, "{prez:<8}")?;
Solving,write!(f, " + ")?;
Solving,write!(f, "{e}")?;
Solving,println!("ub: {}", self.ub);
Solving,context.add_watch(self.active.variable(), id);
Solving,context.add_watch(self.valid.variable(), id);
Solving,context.add_lb_watch(e.var, id);
Solving,let sum_lb: LongCst = self.elements.iter().map(|e| e.get_lower_bound(domains)).sum();
Solving,let f = cst_int_to_long(self.ub) - sum_lb;
Solving,let changed_something = domains.set(!self.active, cause)?;
Solving,);
Solving,return Ok(());
Solving,let lb = e.get_lower_bound(domains);
Solving,let ub = e.get_upper_bound(domains);
Solving,debug_assert!(lb <= ub);
Solving,let new_ub = f + lb;
Solving,e.set_ub(new_ub, domains, cause)?;
Solving,// println!("\n EXPLAIN {literal:?}");
Solving,let mut culprits = BinaryHeap::new();
Solving,let mut ub = cst_int_to_long(self.ub);
Solving,ub += 1;
Solving,debug_assert!(self.elements.iter().any(|e| e.var == literal.svar()));
Solving,out_explanation.push(self.active);
Solving,out_explanation.push(self.valid);
Solving,let factor = cst_int_to_long(e.factor);
Solving,let a_ub = cst_int_to_long(literal.ub_value()).saturating_mul(factor);
Solving,let a_ub = div_floor(a_ub, factor) * factor + factor - 1;
Solving,debug_assert!(div_floor(a_ub, factor) <= cst_int_to_long(literal.ub_value()));
Solving,// println!("culprit {e:?}");
Solving,ub -= a_ub;
Solving,let elem_var_lb = cst_int_to_long(domains.lb(e.var));
Solving,);
Solving,let elem_lb = elem_var_lb.saturating_mul(cst_int_to_long(e.factor));
Solving,// println!("move left: {e:?} >= {elem_lb}");
Solving,ub -= elem_lb;
Solving,let sum_lb = |culps: &BinaryHeap<LbBoundEvent>| -> LongCst { culps.iter().map(|e| e.lb()).sum() };
Solving,println!("QUEUE:");
Solving,};
Solving,// print(&culprits);
Solving,let mut culprits_lb = sum_lb(&culprits);
Solving,// println!("BEFORE LOOP: {culprits_lb}   <= {ub}");
Solving,// let e = &elem_event;
Solving,// );
Solving,let event_idx = elem_event.event;
Solving,let lb = elem_event.lb();
Solving,let prev_lb = elem_event.previous_lb();
Solving,debug_assert_eq!(culprits_lb, sum_lb(&culprits));
Solving,debug_assert!(ub <= culprits_lb + lb);
Solving,culprits.push(previous);
Solving,culprits_lb += prev_lb;
Solving,);
Solving,ub -= prev_lb;
Solving,out_explanation.push(elem_event.literal());
Solving,ub -= lb;
Solving,use super::*;
Solving,use crate::backtrack::Backtrack;
Solving,use crate::core::literals::Disjunction;
Solving,use crate::core::state::{Explainer, InferenceCause, Origin};
Solving,use crate::core::SignedVar;
Solving,use crate::reasoners::ReasonerId;
Solving,use rand::prelude::SmallRng;
Solving,use rand::seq::SliceRandom;
Solving,use rand::{Rng, SeedableRng};
Solving,let x = dom.new_var(lb, ub);
Solving,assert_eq!(e.get_lower_bound(d), lb.into());
Solving,assert_eq!(e.get_upper_bound(d), ub.into());
Solving,assert_eq!(d.lb(v), lb);
Solving,assert_eq!(d.ub(v), ub);
Solving,let mut d = Domains::new();
Solving,let v = var(-100, 100, 2, &mut d);
Solving,let s = sum(vec![v], 10, Lit::TRUE);
Solving,check_bounds(&v, &d, -200, 200);
Solving,assert_eq!(v.set_ub(50, &mut d, Cause::Decision), Ok(true));
Solving,check_bounds(&v, &d, -200, 50);
Solving,assert_eq!(v.set_ub(50, &mut d, Cause::Decision), Ok(false));
Solving,check_bounds(&v, &d, -200, 50);
Solving,let mut d = Domains::new();
Solving,let c = var(3, 3, 1, &mut d);
Solving,let s = sum(vec![c], 10, Lit::TRUE);
Solving,check_bounds(&c, &d, 3, 3);
Solving,assert_eq!(c.set_ub(50, &mut d, Cause::Decision), Ok(false));
Solving,check_bounds(&c, &d, 3, 3);
Solving,assert_eq!(c.set_ub(3, &mut d, Cause::Decision), Ok(false));
Solving,check_bounds(&c, &d, 3, 3);
Solving,assert!(c.set_ub(0, &mut d, Cause::Decision).is_err());
Solving,check_bounds(&c, &d, 3, 3);
Solving,let mut d = Domains::new();
Solving,let x = var(-100, 100, 2, &mut d);
Solving,let c = var(3, 3, 1, &mut d);
Solving,let s = sum(vec![x, c], 10, Lit::TRUE);
Solving,check_bounds(&x, &d, -200, 200);
Solving,check_bounds(&c, &d, 3, 3);
Solving,assert!(s.propagate(&mut d, Cause::Decision).is_ok());
Solving,check_bounds(&c, &d, 3, 3);
Solving,assert_eq!(x.set_ub(5, &mut d, Cause::Decision), Ok(true));
Solving,check_bounds(&x, &d, -200, 4);
Solving,check_bounds(&c, &d, 3, 3);
Solving,assert_eq!(x.set_ub(10, &mut d, Cause::Decision), Ok(false));
Solving,check_bounds(&x, &d, -200, 4);
Solving,check_bounds(&c, &d, 3, 3);
Solving,let mut d = Domains::new();
Solving,let x = var(-100, 100, 2, &mut d);
Solving,let y = var(-100, 100, 3, &mut d);
Solving,let z = var(-100, 100, 1, &mut d);
Solving,let c = var(25, 25, 1, &mut d);
Solving,let s = sum(vec![x, y, z, c], 10, Lit::TRUE);
Solving,check_bounds(&x, &d, -200, 200);
Solving,check_bounds(&y, &d, -300, 300);
Solving,check_bounds(&z, &d, -100, 100);
Solving,check_bounds(&c, &d, 25, 25);
Solving,assert!(s.propagate(&mut d, Cause::Decision).is_ok());
Solving,check_bounds(&x, &d, -200, 200);
Solving,check_bounds(&y, &d, -300, 285);
Solving,check_bounds(&z, &d, -100, 100);
Solving,check_bounds(&c, &d, 25, 25);
Solving,let mut d = Domains::new();
Solving,let x = var(-100, 100, 2, &mut d);
Solving,let y = var(-100, 100, -3, &mut d);
Solving,let z = var(0, 0, 1, &mut d);
Solving,let c = var(25, 25, 1, &mut d);
Solving,let s = sum(vec![x, y, z, c], 10, Lit::TRUE);
Solving,check_bounds(&x, &d, -200, 200);
Solving,check_bounds(&y, &d, -300, 300);
Solving,check_bounds(&z, &d, 0, 0);
Solving,check_bounds(&c, &d, 25, 25);
Solving,assert!(s.propagate(&mut d, Cause::Decision).is_ok());
Solving,check_bounds(&x, &d, -200, 200);
Solving,check_bounds(&y, &d, -300, 183);
Solving,check_bounds(&z, &d, 0, 0);
Solving,check_bounds(&c, &d, 25, 25);
Solving,let mut d = Domains::new();
Solving,let v = d.new_var(-1, 1);
Solving,let c = var(0, 25, 1, &mut d);
Solving,let s = sum(vec![c], 10, v.lt(0));
Solving,d.save_state();
Solving,d.decide(c.var.geq(25));
Solving,assert!(s.propagate(&mut d, Cause::Decision).is_ok());
Solving,check_bounds_var(v, &d, 0, 1);
Solving,let mut expl = Explanation::new();
Solving,let d = DomainsSnapshot::current(&d);
Solving,s.explain(v.geq(0), &d, &mut expl);
Solving,assert_eq!(expl.lits, vec![c.var.geq(25)]);
Solving,let mut problems = Vec::new();
Solving,];
Solving,let mut d = Domains::new();
Solving,let vars = (0..weights.len()).map(|i| d.new_var(0, 10)).collect_vec();
Solving,.collect_vec();
Solving,let mut s = sum(elems, *ub, Lit::TRUE);
Solving,problems.push((d, s));
Solving,use crate::reasoners::cp::propagator::test::utils::*;
Solving,println!("\nConstraint: {s:?}");
Solving,test_explanations(&d, &s, true);
Solving,};
Solving,context.add_watch(self.prod, id);
Solving,context.add_watch(self.fact1, id);
Solving,context.add_watch(self.fact2, id);
Solving,context.add_lit_watch(self.active, id);
Solving,context.add_lit_watch(self.valid, id);
Solving,return Ok(());
Solving,let changed_something = domains.set(!self.active, cause)?;
Solving,);
Solving,return Ok(());
Solving,self.propagate_xyx(domains, cause)?;
Solving,};
Solving,state.explain_var(self.prod, out_explanation);
Solving,state.explain_var(self.fact1, out_explanation);
Solving,state.explain_var(self.fact2, out_explanation);
Solving,return;
Solving,out_explanation.push(self.active);
Solving,out_explanation.push(self.valid);
Solving,state.explain_var(self.fact1, out_explanation);
Solving,state.explain_var(self.fact2, out_explanation);
Solving,state.explain_var(self.prod, out_explanation);
Solving,state.explain_var(self.fact1, out_explanation);
Solving,state.explain_var(self.fact2, out_explanation);
Solving,let mut updated = self.propagate_forward(domains, cause)?;
Solving,updated |= self.propagate_signs(domains, cause)?;
Solving,updated |= self.propagate_backward(domains, cause, self.fact1, self.fact2)?;
Solving,updated |= self.propagate_backward(domains, cause, self.fact2, self.fact1)?;
Solving,let f1_dom = domains.int_domain(self.fact1);
Solving,let f2_dom = domains.int_domain(self.fact2);
Solving,let prod = f1_dom * f2_dom;
Solving,let p = domains.int_domain(self.prod);
Solving,let of = domains.int_domain(other_fact);
Solving,let abs_max = p.lb.abs().max(p.ub.abs());
Solving,let mut updated_of = false;
Solving,updated_of |= domains.set_lb(other_fact, 1, cause)?;
Solving,updated_of |= domains.set_ub(other_fact, -1, cause)?;
Solving,let (a, b, (c, d)) = (p.lb, p.ub, domains.bounds(other_fact));
Solving,let (ac_floor, ac_ceil) = div_floor_ceil(a, c);
Solving,let (ad_floor, ad_ceil) = div_floor_ceil(a, d);
Solving,let (bc_floor, bc_ceil) = div_floor_ceil(b, c);
Solving,let (bd_floor, bd_ceil) = div_floor_ceil(b, d);
Solving,let low = ac_ceil.min(ad_ceil).min(bc_ceil).min(bd_ceil);
Solving,let high = ac_floor.max(ad_floor).max(bc_floor).max(bd_floor);
Solving,// );
Solving,let p = domains.int_domain(self.prod);
Solving,let f1 = domains.int_domain(self.fact1);
Solving,let f2 = domains.int_domain(self.fact2);
Solving,return Ok(false);
Solving,domains.set_lb(self.fact1, 1, cause)?;
Solving,domains.set_lb(self.fact2, 1, cause)?;
Solving,domains.set_lb(self.fact1, 1, cause)?;
Solving,domains.set_ub(self.fact2, -1, cause)?;
Solving,domains.set_lb(self.fact2, 1, cause)?;
Solving,domains.set_ub(self.fact1, -1, cause)?;
Solving,domains.set_ub(self.fact1, -1, cause)?;
Solving,domains.set_ub(self.fact2, -1, cause)?;
Solving,return Ok(false);
Solving,let fact = self.xyx_fact().unwrap();
Solving,let prod_dom = domains.int_domain(self.prod);
Solving,let fact_dom = domains.int_domain(fact);
Solving,domains.set_bounds(self.prod, (0, 0), cause)?;
Solving,domains.set_bounds(fact, (1, 1), cause)?;
Solving,let prod = domains.int_domain(self.prod);
Solving,let f1 = domains.int_domain(self.fact1);
Solving,let f2 = domains.int_domain(self.fact2);
Solving,let rhs = f1 * f2;
Solving,out_explanation.push(self.lb_literal(v));
Solving,out_explanation.push(self.ub_literal(v));
Solving,let changed1 = self.set_lb(v, lb, cause)?;
Solving,let changed2 = self.set_ub(v, ub, cause)?;
Solving,let quotient_positive = (x >= 0) == (y >= 0);
Solving,let q = x / y;
Solving,let m = x % y;
Solving,use std::collections::HashSet;
Solving,use rand::{rngs::SmallRng, Rng, SeedableRng};
Solving,use super::*;
Solving,use crate::{core::*, reasoners::cp::test::utils::test_explanations};
Solving,assert_eq!(d.bounds(v), expected_bounds, "Unexpected bounds for {v:?}");
Solving,let (lb, ub) = d.bounds(var);
Solving,assert!(lb <= val && val <= ub, "{} <= {} <= {} failed", lb, val, ub);
Solving,let out_explanation = &mut Explanation::new();
Solving,prop.explain(lit, &DomainsSnapshot::current(d), out_explanation);
Solving,let expected_set: HashSet<&Lit> = expected.lits.iter().collect();
Solving,let res_set: HashSet<&Lit> = out_explanation.lits.iter().collect();
Solving,assert_eq!(expected_set, res_set);
Solving,println!("Problem: ");
Solving,let (prod_lb, prod_ub) = d.bounds(prop.prod);
Solving,println!("  {prod_lb} <= prod <= {prod_ub}");
Solving,let (fact1_lb, fact1_ub) = d.bounds(prop.fact1);
Solving,println!("  {fact1_lb} <= fact1 <= {fact1_ub}");
Solving,let (fact2_lb, fact2_ub) = d.bounds(prop.fact2);
Solving,println!("  {fact2_lb} <= fact2 <= {fact2_ub}\n");
Solving,let max = max as IntCst;
Solving,let mut res = vec![];
Solving,let mut rng = SmallRng::seed_from_u64(0);
Solving,let fact1_val = rng.gen_range(-max..max);
Solving,let fact2_val = rng.gen_range(-max..max);
Solving,let prod_val = fact1_val * fact2_val;
Solving,let mut d = Domains::new();
Solving,);
Solving,let fact1_bounds = (rng.gen_range(-max..=fact1_val), rng.gen_range(fact1_val..=max));
Solving,let fact2_bounds = (rng.gen_range(-max..=fact2_val), rng.gen_range(fact2_val..=max));
Solving,let prod = d.new_var(prod_bounds.0, prod_bounds.1);
Solving,let fact1 = d.new_var(fact1_bounds.0, fact1_bounds.1);
Solving,let fact2 = d.new_var(fact2_bounds.0, fact2_bounds.1);
Solving,};
Solving,res.push((d, prop, (prod_val, fact1_val, fact2_val)));
Solving,let max = max as IntCst;
Solving,let mut res = vec![];
Solving,let mut rng = SmallRng::seed_from_u64(0);
Solving,let fact_val = rng.gen_range(-max..max);
Solving,let prod_val = fact_val.pow(2);
Solving,let mut d = Domains::new();
Solving,);
Solving,let fact = d.new_var(rng.gen_range(-max..=fact_val), rng.gen_range(fact_val..=max));
Solving,};
Solving,res.push((d, prop, (prod_val, fact_val)));
Solving,let mut d = Domains::new();
Solving,let d: &mut Domains = &mut d;
Solving,let prod = d.new_var(prod_bounds.0, prod_bounds.1);
Solving,let fact1 = d.new_var(fact1_bounds.0, fact1_bounds.1);
Solving,let fact2 = d.new_var(fact2_bounds.0, fact2_bounds.1);
Solving,};
Solving,let res = prop.propagate(&mut d, Cause::Decision);
Solving,assert!(res.is_err() == should_fail, "{:?}", res.err());
Solving,check_bounds(prop.prod, &d, prop_res);
Solving,check_bounds(prop.fact1, &d, fact1_res);
Solving,check_bounds(prop.fact2, &d, fact2_res);
Solving,let mut d = Domains::new();
Solving,let prod = d.new_var(prod_bounds.0, prod_bounds.1);
Solving,let fact = d.new_var(fact_bounds.0, fact_bounds.1);
Solving,};
Solving,assert!(prop.propagate(&mut d, Cause::Decision).is_err() == should_fail);
Solving,check_bounds(prod, &d, prop_res);
Solving,check_bounds(fact, &d, fact_res);
Solving,let mut d = Domains::new();
Solving,let prod = d.new_var(prod_bounds.0, prod_bounds.1);
Solving,let fact = d.new_var(fact_bounds.0, fact_bounds.1);
Solving,};
Solving,assert!(prop.propagate(&mut d, Cause::Decision).is_err() == should_fail);
Solving,check_bounds(prod, &d, prop_res);
Solving,check_bounds(fact, &d, fact_res);
Solving,let mut d = Domains::new();
Solving,let prod = d.new_var(prod_bounds.0, prod_bounds.1);
Solving,let fact = d.new_var(fact_bounds.0, fact_bounds.1);
Solving,};
Solving,test_explanations(&d, &prop, false);
Solving,);
Solving,);
Solving,);
Solving,);
Solving,);
Solving,);
Solving,);
Solving,);
Solving,);
Solving,);
Solving,);
Solving,);
Solving,);
Solving,);
Solving,test_xyx_explanation((5, 10), (-1, 5));
Solving,test_xyx_explanation((0, 10), (-5, 5));
Solving,);
Solving,check_in_bounds(&d, prop.prod, prod_val);
Solving,check_in_bounds(&d, prop.fact1, fact1_val);
Solving,check_in_bounds(&d, prop.fact2, fact2_val);
Solving,);
Solving,check_in_bounds(&d, prop.prod, prod_val);
Solving,check_in_bounds(&d, prop.fact1, fact_val);
Solving,test_explanations(&d, &prop, false);
Solving,test_explanations(&d, &prop, false);
Solving,use crate::core::state::{Cause, Domains, DomainsSnapshot, Explanation};
Solving,use crate::core::{IntCst, Lit, SignedVar, INT_CST_MIN};
Solving,use crate::reasoners::cp::{Propagator, PropagatorId, Watches};
Solving,use crate::reasoners::Contradiction;
Solving,context.add_watch(self.scope.variable(), id);
Solving,context.add_watch(self.lhs.variable(), id);
Solving,context.add_watch(e.var.variable(), id);
Solving,context.add_watch(e.presence.variable(), id);
Solving,let ub = |svar: SignedVar| domains.ub(svar);
Solving,let lb = |svar: SignedVar| domains.lb(svar);
Solving,let mut candidates = Candidates::Empty;
Solving,let lhs_ub = ub(self.lhs);
Solving,let lhs_lb = lb(self.lhs);
Solving,let mut rhs_max = INT_CST_MIN - 1;
Solving,let elem_ub = ub(elem.var) + elem.cst;
Solving,rhs_max = rhs_max.max(elem_ub);
Solving,let max_presence = domains.presence(self.lhs.variable());
Solving,let elem = &self.elements[idx];
Solving,debug_assert_eq!(self.scope, domains.presence(self.lhs.variable()));
Solving,let max_lb = domains.lb(self.lhs);
Solving,out_explanation.push(!e.presence);
Solving,let lit = Lit::lt(e.var, max_lb - e.cst);
Solving,debug_assert!(domains.entails(lit));
Solving,out_explanation.push(lit);
Solving,let max_ub = literal.ub_value();
Solving,out_explanation.push(!e.presence);
Solving,let lit = e.var.leq(max_ub - e.cst);
Solving,debug_assert!(domains.entails(lit));
Solving,out_explanation.push(lit);
Solving,.unwrap();
Solving,let max_lb = domains.lb(self.lhs);
Solving,out_explanation.push(!e.presence);
Solving,let lit = Lit::lt(e.var, max_lb - e.cst);
Solving,debug_assert!(domains.entails(lit));
Solving,out_explanation.push(lit);
Solving,let inferrable = Lit::geq(elem.var, max_lb - elem.cst);
Solving,debug_assert!(inferrable.entails(literal));
Solving,out_explanation.push(Lit::geq(self.lhs, max_lb));
Solving,use crate::core::state::{Cause, Domains};
Solving,use crate::core::{IntCst, Lit, SignedVar, VarRef};
Solving,use crate::reasoners::cp::max::{AtLeastOneGeq, MaxElem};
Solving,use crate::reasoners::cp::Propagator;
Solving,assert_eq!(d.lb(v), lb);
Solving,assert_eq!(d.ub(v), ub);
Solving,pub static CAUSE: Cause = Cause::Decision;
Solving,let d = &mut Domains::new();
Solving,let m = d.new_var(0, 20);
Solving,let a = d.new_var(0, 10);
Solving,let b = d.new_var(0, 12);
Solving,};
Solving,c.propagate(d, CAUSE).unwrap();
Solving,check_bounds(d, m, 0, 13);
Solving,d.set_ub(a, 9, CAUSE);
Solving,c.propagate(d, CAUSE).unwrap();
Solving,check_bounds(d, m, 0, 13);
Solving,d.set_ub(b, 9, CAUSE);
Solving,c.propagate(d, CAUSE).unwrap();
Solving,check_bounds(d, m, 0, 10);
Solving,d.set_ub(a, 5, CAUSE);
Solving,c.propagate(d, CAUSE).unwrap();
Solving,check_bounds(d, m, 0, 10);
Solving,d.set_ub(b, 3, CAUSE);
Solving,c.propagate(d, CAUSE).unwrap();
Solving,check_bounds(d, m, 0, 6);
Solving,pub mod linear;
Solving,pub mod max;
Solving,pub mod mul;
Solving,pub mod mul_lit;
Solving,mod propagator;
Solving,pub use propagator::*;
Solving,use crate::backtrack::{Backtrack, DecLvl, ObsTrailCursor};
Solving,use crate::collections::ref_store::{RefMap, RefVec};
Solving,use crate::collections::set::RefSet;
Solving,use crate::collections::*;
Solving,};
Solving,use crate::core::{IntCst, Lit, SignedVar, VarRef, INT_CST_MAX, INT_CST_MIN};
Solving,use crate::create_ref_type;
Solving,use crate::model::extensions::{AssignmentExt, DisjunctionExt};
Solving,use crate::model::lang::linear::NFLinearLeq;
Solving,use crate::model::lang::mul::{EqMul, NFEqVarMulLit};
Solving,use crate::reasoners::cp::linear::{LinearSumLeq, SumElem};
Solving,use crate::reasoners::cp::max::AtLeastOneGeq;
Solving,use crate::reasoners::{Contradiction, ReasonerId, Theory};
Solving,use anyhow::Context;
Solving,use mul_lit::VarEqVarMulLit;
Solving,use set::IterableRefSet;
Solving,use std::cmp::Ordering;
Solving,use std::collections::{HashMap, HashSet};
Solving,self.add_ub_watch(watched, propagator_id);
Solving,self.add_lb_watch(watched, propagator_id);
Solving,let watched = watched.into();
Solving,let watched = watched.into();
Solving,let watched = watched.into();
Solving,self.add_ub_watch(watched.svar(), propagator_id);
Solving,let var = var.into();
Solving,let valid = doms.presence(active);
Solving,debug_assert!(leq.sum.iter().all(|e| doms.implies(valid, doms.presence(e.var))));
Solving,let elements = leq.sum.iter().map(|e| SumElem::new(e.factor, e.var)).collect();
Solving,};
Solving,self.add_propagator(propagator);
Solving,let valid = doms.presence(active);
Solving,.all(|e| doms.implies(valid, doms.presence(*e))));
Solving,};
Solving,self.add_propagator(propagator);
Solving,};
Solving,self.add_propagator(propagator);
Solving,let propagator = propagator.into();
Solving,let propagator_id = self.constraints.next_key();
Solving,propagator.constraint.setup(propagator_id, &mut self.watches);
Solving,self.constraints.set_next(propagator_id, propagator);
Solving,self.pending_propagators.push(propagator_id);
Solving,self.pending_propagations.clear();
Solving,);
Solving,let watchers = self.watches.get_ub_watches(event.affected_bound);
Solving,self.pending_propagations.insert(watcher);
Solving,let constraint = self.constraints[propagator].constraint.as_ref();
Solving,let cause = self.id.cause(propagator);
Solving,self.stats.num_propagations += 1;
Solving,constraint.propagate(domains, cause)?;
Solving,let constraint_id = PropagatorId::from(context.payload);
Solving,let constraint = self.constraints[constraint_id].constraint.as_ref();
Solving,constraint.explain(literal, state, out_explanation);
Solving,println!("# constraints: {}", self.constraints.len());
Solving,println!("# propagations: {}", self.stats.num_propagations);
Solving,self.saved += 1;
Solving,self.saved -= 1;
Solving,use std::cmp::{max, min};
Solving,};
Solving,use super::Propagator;
Solving,context.add_watch(self.reified, id);
Solving,context.add_watch(self.original, id);
Solving,context.add_watch(self.lit.variable(), id);
Solving,let n = domains.trail().len();
Solving,let orig_prez = domains.presence_literal(self.original);
Solving,debug_assert!(domains.implies(self.lit, orig_prez));
Solving,let (orig_lb, orig_ub) = domains.bounds(self.original);
Solving,let (reif_lb, reif_ub) = domains.bounds(self.reified);
Solving,domains.set_lb(self.reified, orig_lb, cause)?;
Solving,domains.set_ub(self.reified, orig_ub, cause)?;
Solving,domains.set_lb(self.original, reif_lb, cause)?;
Solving,domains.set_ub(self.original, reif_ub, cause)?;
Solving,domains.set_lb(self.reified, 0, cause)?;
Solving,domains.set_ub(self.reified, 0, cause)?;
Solving,let (orig_lb, orig_ub) = domains.bounds(self.original);
Solving,let (reif_lb, reif_ub) = domains.bounds(self.reified);
Solving,domains.set(!self.lit, cause)?;
Solving,domains.set_lb(self.reified, 0, cause)?;
Solving,domains.set_ub(self.reified, 0, cause)?;
Solving,domains.set(self.lit, cause)?;
Solving,domains.set_lb(self.reified, min(0, orig_lb), cause)?;
Solving,domains.set_ub(self.reified, max(0, orig_ub), cause)?;
Solving,.any(|&v| v == literal.variable()));
Solving,let (reif_lb, reif_ub) = state.bounds(self.reified);
Solving,let (orig_lb, orig_ub) = state.bounds(self.original);
Solving,let orig_prez = state.presence(self.original);
Solving,out_explanation.push(self.reified.geq(reif_lb));
Solving,out_explanation.push(self.reified.leq(reif_ub));
Solving,out_explanation.push(self.original.lt(reif_lb));
Solving,out_explanation.push(self.reified.geq(reif_lb));
Solving,out_explanation.push(self.original.gt(reif_ub));
Solving,out_explanation.push(self.reified.leq(reif_ub));
Solving,let (var, rel, val) = literal.unpack();
Solving,out_explanation.push(!orig_prez);
Solving,out_explanation.push(!self.lit);
Solving,out_explanation.push(orig_prez);
Solving,out_explanation.push(self.original.gt(val));
Solving,out_explanation.push(self.lit);
Solving,out_explanation.push(self.original.gt(val));
Solving,out_explanation.push(!orig_prez);
Solving,out_explanation.push(!self.lit);
Solving,out_explanation.push(orig_prez);
Solving,out_explanation.push(self.original.leq(val));
Solving,out_explanation.push(self.lit);
Solving,out_explanation.push(self.original.leq(val));
Solving,};
Solving,out_explanation.push(self.lit);
Solving,};
Solving,use itertools::Itertools;
Solving,use rand::prelude::SmallRng;
Solving,use rand::seq::SliceRandom;
Solving,use rand::{Rng, SeedableRng};
Solving,use crate::backtrack::Backtrack;
Solving,use crate::core::literals::Disjunction;
Solving,use crate::core::state::{Event, Origin};
Solving,use crate::core::{IntCst, Relation};
Solving,};
Solving,use super::*;
Solving,assert_eq!(d.lb(v), lb);
Solving,assert_eq!(d.ub(v), ub);
Solving,let mut d = Domains::new();
Solving,let r = d.new_var(-5, 10);
Solving,let o = d.new_var(-10, 5);
Solving,let c = mul(r, o, Lit::TRUE);
Solving,check_bounds(r, &d, -5, 10);
Solving,check_bounds(o, &d, -10, 5);
Solving,assert!(c.propagate(&mut d, Cause::Decision).is_ok());
Solving,check_bounds(r, &d, -5, 5);
Solving,check_bounds(o, &d, -5, 5);
Solving,let mut d = Domains::new();
Solving,let r = d.new_var(-5, 10);
Solving,let o = d.new_var(-10, 5);
Solving,let c = mul(r, o, Lit::FALSE);
Solving,check_bounds(r, &d, -5, 10);
Solving,check_bounds(o, &d, -10, 5);
Solving,assert!(c.propagate(&mut d, Cause::Decision).is_ok());
Solving,check_bounds(r, &d, 0, 0);
Solving,check_bounds(o, &d, -10, 5);
Solving,let mut d = Domains::new();
Solving,let p = d.new_presence_literal(Lit::TRUE);
Solving,let r = d.new_var(1, 10);
Solving,let o = d.new_optional_var(-10, 5, p);
Solving,let l = d.new_presence_literal(p);
Solving,let c = mul(r, o, l);
Solving,check_bounds(r, &d, 1, 10);
Solving,check_bounds(o, &d, -10, 5);
Solving,check_bounds(l.variable(), &d, 0, 1);
Solving,assert!(c.propagate(&mut d, Cause::Decision).is_ok());
Solving,check_bounds(r, &d, 1, 5);
Solving,check_bounds(o, &d, 1, 5);
Solving,check_bounds(l.variable(), &d, 1, 1);
Solving,let mut d = Domains::new();
Solving,let p = d.new_presence_literal(Lit::TRUE);
Solving,let r = d.new_var(-5, 0);
Solving,let o = d.new_optional_var(1, 5, p);
Solving,let l = d.new_presence_literal(p);
Solving,let c = mul(r, o, l);
Solving,check_bounds(r, &d, -5, 0);
Solving,check_bounds(o, &d, 1, 5);
Solving,check_bounds(l.variable(), &d, 0, 1);
Solving,assert!(c.propagate(&mut d, Cause::Decision).is_ok());
Solving,check_bounds(r, &d, 0, 0);
Solving,check_bounds(o, &d, 1, 5);
Solving,check_bounds(l.variable(), &d, 0, 0);
Solving,});
Solving,let mut problems = Vec::new();
Solving,let mut rng = SmallRng::seed_from_u64(0);
Solving,let mut d = Domains::new();
Solving,let prez = d.new_presence_literal(Lit::TRUE);
Solving,let lit = d.new_presence_literal(prez);
Solving,let reif_lb = rng.gen_range(-20..=20);
Solving,let reif_ub = rng.gen_range(-20..=20).max(reif_lb);
Solving,let reified = d.new_var(reif_lb, reif_ub);
Solving,let orig_prez = d.new_presence_literal(prez);
Solving,let orig_lb = rng.gen_range(-20..=20);
Solving,let orig_ub = rng.gen_range(-20..=20).max(orig_lb);
Solving,let original = d.new_optional_var(orig_lb, orig_ub, orig_prez);
Solving,d.add_implication(lit, orig_prez);
Solving,let c = VarEqVarMulLit { reified, original, lit };
Solving,problems.push((d, c));
Solving,use crate::reasoners::cp::propagator::test::utils::*;
Solving,println!("\nConstraint: {c:?}");
Solving,test_explanations(&d, &c, true);
Solving,use std::collections::HashSet;
Solving,use std::hash::Hash;
Solving,/// use aries::collections::seq::Seq;
Solving,///     println!("{:?}", items.to_vec());
Solving,/// print([1, 3, 4]);
Solving,/// print(vec![3, 4, 5]);
Solving,fn to_vec(self) -> Vec<T>;
Solving,T: Hash + Eq;
Solving,use crate::collections::ref_store::{Ref, RefMap};
Solving,use super::ref_store::IterableRefMap;
Solving,self.set.insert(k, ());
Solving,self.set.remove(k);
Solving,self.set.insert(k, ());
Solving,use itertools::Itertools;
Solving,use std::borrow::Borrow;
Solving,use std::collections::HashMap;
Solving,use std::fmt::{Debug, Error, Formatter};
Solving,use std::hash::Hash;
Solving,use std::iter::FromIterator;
Solving,use std::marker::PhantomData;
Solving,use std::ops::{Index, IndexMut};
Solving,pub struct $type_name(std::num::NonZeroU32);
Solving,type Output = V;
Solving,};
Solving,assert!(!self.rev.contains_key(&v), "Duplicated value: {:?}", &v);
Solving,let id: K = self.internal.len().into();
Solving,self.rev.insert(v.clone(), id);
Solving,self.internal.push(v);
Solving,type Output = V;
Solving,let id: K = self.internal.len().into();
Solving,self.internal.push(v);
Solving,type Output = V;
Solving,let to_index: usize = to_key.into();
Solving,self.push(value_gen());
Solving,self.values.push(value);
Solving,let actual_key = self.push(value);
Solving,assert!(expected_key == actual_key);
Solving,type Output = V;
Solving,let index = k.into();
Solving,self.entries.push(None);
Solving,self.entries[index] = Some(v);
Solving,let index = k.into();
Solving,self.entries[k.into()] = None;
Solving,let index = k.into();
Solving,let index = k.into();
Solving,let index = k.into();
Solving,type Output = V;
Solving,let mut m = RefMap::default();
Solving,m.insert(k, v);
Solving,write!(f, "[")?;
Solving,write!(f, "{k:?} -> {v:?}, ")?;
Solving,type Output = V;
Solving,let mut m = IterableRefMap::default();
Solving,m.insert(k, v);
Solving,use crate::collections::heap::Entry::{In, Out};
Solving,use crate::collections::ref_store::{Ref, RefMap};
Solving,use core::ptr;
Solving,use std::cmp::Ordering;
Solving,use std::mem::ManuallyDrop;
Solving,type PlaceInHeap = usize;
Solving,debug_assert!(i > 0);
Solving,self.heap.clear();
Solving,// debug_assert!(self.index.is_empty());
Solving,self.keys.clear();
Solving,debug_assert!(!self.index.contains(key));
Solving,self.index.insert(key, Out(priority));
Solving,self.keys.push(key);
Solving,debug_assert!(self.is_declared(key), "Variable is not declared");
Solving,self.index[first.key] = Out(first.prio);
Solving,let initial_len = self.heap.len();
Solving,let last = self.heap.pop().unwrap();
Solving,debug_assert!(initial_len >= 2);
Solving,let hole = Hole::new_with_element(&mut self.heap, &mut self.index.entries, 0, last);
Solving,Self::sift_hole_down(hole);
Solving,debug_assert!(self.is_declared(key), "Key not declared");
Solving,let place = self.free();
Solving,self.heap.push(HeapEntry::new(key, *prio));
Solving,self.sift_up(place);
Solving,let loc = *loc;
Solving,f(&mut self.heap[loc].prio);
Solving,self.sift_after_priority_change(loc);
Solving,self.change_priority(key, |p| *p = new_priority);
Solving,self.sift_down(place);
Solving,self.sift_up(place);
Solving,let hole = self.make_hole(i);
Solving,Self::sift_hole_up(hole);
Solving,let parent = above(hole.pos);
Solving,hole.move_to(parent);
Solving,break;
Solving,let len = hole.data.len();
Solving,let mut child = below_left(hole.pos);
Solving,debug_assert_eq!(child, below_left(hole.pos));
Solving,child += (hole.get(child) < hole.get(child + 1)) as usize;
Solving,debug_assert!(child == below_left(hole.pos) || child == below_right(hole.pos));
Solving,return;
Solving,hole.move_to(child);
Solving,debug_assert_eq!(child, hole.pos);
Solving,child = below_left(child);
Solving,hole.move_to(child);
Solving,let len = hole.data.len();
Solving,let mut child = below_left(hole.pos);
Solving,debug_assert_eq!(child, below_left(hole.pos));
Solving,child += (hole.get(child) <= hole.get(child + 1)) as usize;
Solving,debug_assert!(child == below_left(hole.pos) || child == below_right(hole.pos));
Solving,hole.move_to(child);
Solving,debug_assert_eq!(child, hole.pos);
Solving,child = below_left(child);
Solving,hole.move_to(child);
Solving,Self::sift_hole_up(hole);
Solving,debug_assert!(pos < data.len());
Solving,let elt = unsafe { ptr::read(data.get_unchecked(pos)) };
Solving,let removed = unsafe { ptr::read(data.get_unchecked(pos)) };
Solving,debug_assert!(matches!(index[removed.key.into()], Some(Out(_))));
Solving,debug_assert!(index != self.pos);
Solving,debug_assert!(index < self.data.len());
Solving,debug_assert!(index != self.pos);
Solving,debug_assert!(index < self.data.len());
Solving,let ptr = self.data.as_mut_ptr();
Solving,let index_ptr: *const _ = ptr.add(index);
Solving,let moved_key = (*index_ptr).key;
Solving,let hole_ptr = ptr.add(self.pos);
Solving,ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);
Solving,let i = self.index.as_mut_ptr();
Solving,let i = i.add(moved_key.into());
Solving,ptr::write(i, Some(In(self.pos)));
Solving,self.pos = index;
Solving,let pos = self.pos;
Solving,let key = self.elt.key;
Solving,ptr::copy_nonoverlapping(&*self.elt, self.data.get_unchecked_mut(pos), 1);
Solving,let i = self.index.as_mut_ptr();
Solving,let i = i.add(key.into());
Solving,ptr::write(i, Some(In(pos)));
Solving,use super::*;
Solving,use rand::prelude::StdRng;
Solving,use rand::{Rng, SeedableRng};
Solving,const N: usize = 100;
Solving,let mut rng = StdRng::seed_from_u64(79837224973);
Solving,let mut heap = IdxHeap::new();
Solving,let mut priorities = Vec::new();
Solving,let prio = rng.gen_range(-100..100) as f64;
Solving,priorities.push(prio);
Solving,heap.declare_element(i, prio);
Solving,assert!(eq(heap.priority(i), prio));
Solving,);
Solving,};
Solving,let mut removed = Vec::new();
Solving,let first = heap.pop().unwrap();
Solving,removed.push(first);
Solving,let mut previous_best = heap.priority(first);
Solving,assert!(eq(previous_best, priorities[first]));
Solving,println!("Removed: {first}");
Solving,let next = heap.pop().unwrap();
Solving,let p = heap.priority(next);
Solving,assert!(eq(p, priorities[next]));
Solving,assert!(p <= previous_best, "{}", "p: {p}   prev:{previous_best}");
Solving,previous_best = p;
Solving,removed.push(next);
Solving,println!("Removed: {next}");
Solving,check_all_priorities(heap);
Solving,};
Solving,heap.enqueue(*elt);
Solving,println!("Inserted: {}, priority: {}", elt, priorities[*elt]);
Solving,check_all_priorities(heap);
Solving,};
Solving,let entries: Vec<usize> = (0..N).collect();
Solving,insert_all(&mut heap, &entries);
Solving,let out = remove_n(&mut heap, N / 2);
Solving,assert_eq!(heap.is_enqueued(elt), !out.contains(&elt));
Solving,insert_all(&mut heap, &out);
Solving,remove_n(&mut heap, N);
Solving,assert!(heap.pop().is_none());
Solving,assert!(heap.is_empty());
Solving,pub mod heap;
Solving,pub mod id_map;
Solving,pub mod ref_store;
Solving,pub mod seq;
Solving,pub mod set;
Solving,fn next_n(self, n: usize) -> Self;
Solving,let start = Self::min_value();
Solving,fn min_value() -> Self;
Solving,type Item = A;
Solving,let prev = self.first;
Solving,self.first = prev.next();
Solving,use std::convert::TryFrom;
Solving,use std::ops::Index;
Solving,use vec_map::VecMap;
Solving,self.internal.insert(k.into(), v);
Solving,let mut map2 = IdMap::new();
Solving,let v = self.internal.get(k).unwrap();
Solving,map2.internal.insert(k, f(v));
Solving,let mut v = Vec::with_capacity(self.internal.len());
Solving,.expect("Could not reconstruct a key from its usize representation");
Solving,v.push(k);
Solving,let mut v = Vec::with_capacity(self.internal.len());
Solving,.expect("Could not reconstruct a key from its usize representation");
Solving,v.push((k, self.internal.get(ki).unwrap()));
Solving,type Output = V;
Solving,use crate::backtrack::DecLvl;
Solving,fn save_state(&mut self) -> DecLvl;
Solving,fn num_saved(&self) -> u32;
Solving,fn restore_last(&mut self);
Solving,self.restore_last();
Solving,self.restore(DecLvl::ROOT);
Solving,type Event;
Solving,fn restore_last_with<F: FnMut(&Self::Event)>(&mut self, callback: F);
Solving,self.restore_last_with(&mut callback);
Solving,pub struct DecisionLevelTracker(DecLvl);
Solving,self.0 += 1;
Solving,use crate::backtrack::{Backtrack, BacktrackWith};
Solving,use std::cmp::Ordering;
Solving,use std::fmt::Debug;
Solving,use std::marker::PhantomData;
Solving,use std::num::NonZeroU32;
Solving,pub struct DecLvl(NonZeroU32);
Solving,pub const ROOT: DecLvl = Self::new(0);
Solving,type Output = DecLvl;
Solving,type Output = DecLvl;
Solving,/// use aries::backtrack::DecLvl;
Solving,/// let a = DecLvl::ROOT +1;
Solving,/// let b = DecLvl::ROOT +9;
Solving,/// //assert_ne!(a, b);
Solving,/// //assert_ne!(a, DecLvl::ROOT);
Solving,/// let c = b - 8;
Solving,/// assert_eq!(c, a);
Solving,type Output = EventIndex;
Solving,pub struct EventIndex(NonZeroU32);
Solving,type Output = T;
Solving,type Output = EventIndex;
Solving,let base = u32::from(self) as i32;
Solving,let id = self.next_slot();
Solving,self.events.push(value);
Solving,self.events.extend(values);
Solving,let after_last = self.backtrack_points.pop().expect("No backup points left.");
Solving,let id = usize::from(after_last);
Solving,let to_undo = &self.events[id..];
Solving,self.events.drain(id..);
Solving,let bt_id = self.last_backtrack.as_ref().map_or(0, |bt| bt.id + 1);
Solving,});
Solving,let idx = self.backtrack_points.partition_point(|ev| *ev <= id);
Solving,let dl = DecLvl::from(idx);
Solving,debug_assert!(dl == DecLvl::ROOT || self.backtrack_points[dl] <= id);
Solving,debug_assert!(dl == self.current_decision_level() || id < self.backtrack_points[dl + 1]);
Solving,let last = self.backtrack_points[dec_lvl + 1];
Solving,let last = usize::from(last);
Solving,/// use aries::backtrack::*;
Solving,/// let mut q = ObsTrail::new();
Solving,/// q.save_state();
Solving,/// let te = q.last_event_matching(|n| *n <= 1, |_, _| true).unwrap();
Solving,/// assert_eq!(te.loc.decision_level, DecLvl::ROOT);
Solving,/// assert_eq!(te.loc.event_index, EventIndex::new(1));
Solving,/// assert_eq!(*te.event, 1);
Solving,/// let te = q.last_event_matching(|n| *n <= 1, |dl, _| dl > DecLvl::ROOT);
Solving,/// assert!(te.is_none());
Solving,let mut decision_level = self.current_decision_level();
Solving,let event_index = EventIndex::new(event_index);
Solving,// let event_index = event_index as EventIndex;
Solving,return None;
Solving,let e = &self.events[event_index];
Solving,});
Solving,println!("  before: {decision_level:?}");
Solving,decision_level -= 1;
Solving,println!("  after: {decision_level:?}");
Solving,let mut dl = 0;
Solving,print!("id: {i:<4} ");
Solving,let i = EventIndex::from(i);
Solving,dl += 1;
Solving,print!("dl: {dl:<4} ");
Solving,print!("         ");
Solving,println!("{:?}", self.events[i]);
Solving,self.backtrack_points.push(EventIndex::from(self.events.len()));
Solving,type Event = V;
Solving,self.next_read = x.next_read;
Solving,self.last_backtrack = Some(x.id);
Solving,debug_assert!(self.next_read <= queue.next_slot());
Solving,self.sync_backtrack(queue);
Solving,let size = queue.events.len();
Solving,let n = usize::from(self.next_read);
Solving,println!("oups");
Solving,self.mark_used();
Solving,self.sync_backtrack(queue);
Solving,let next = self.next_read;
Solving,self.next_read += 1;
Solving,self.mark_used();
Solving,self.sync_backtrack(queue);
Solving,self.next_read = queue.next_slot();
Solving,use super::*;
Solving,let mut q = ObsTrail::new();
Solving,q.push(0);
Solving,q.push(1);
Solving,q.push(5);
Solving,let mut r1 = q.reader();
Solving,assert_eq!(r1.pop(&q), Some(&0));
Solving,assert_eq!(r1.pop(&q), Some(&1));
Solving,assert_eq!(r1.pop(&q), Some(&5));
Solving,assert_eq!(r1.pop(&q), None);
Solving,let mut r2 = q.reader();
Solving,assert_eq!(r2.pop(&q), Some(&0));
Solving,assert_eq!(r2.pop(&q), Some(&1));
Solving,assert_eq!(r2.pop(&q), Some(&5));
Solving,assert_eq!(r2.pop(&q), None);
Solving,q.push(2);
Solving,assert_eq!(r1.pop(&q), Some(&2));
Solving,assert_eq!(r2.pop(&q), Some(&2));
Solving,assert_eq!(r1.pop(&q), None);
Solving,assert_eq!(r2.pop(&q), None);
Solving,let mut q = ObsTrail::new();
Solving,q.push(1);
Solving,q.push(2);
Solving,q.save_state();
Solving,q.push(3);
Solving,let mut r = q.reader();
Solving,assert_eq!(r.pop(&q), Some(&1));
Solving,assert_eq!(r.pop(&q), Some(&2));
Solving,assert_eq!(r.pop(&q), Some(&3));
Solving,let mut r1 = q.reader();
Solving,let mut r2 = q.reader();
Solving,let mut r3 = q.reader();
Solving,assert_eq!(r1.pop(&q), Some(&1));
Solving,assert_eq!(r1.pop(&q), Some(&2));
Solving,assert_eq!(r1.pop(&q), Some(&3));
Solving,assert_eq!(r2.pop(&q), Some(&1));
Solving,assert_eq!(r2.pop(&q), Some(&2));
Solving,assert_eq!(r3.pop(&q), Some(&1));
Solving,q.restore_last();
Solving,assert_eq!(r1.pop(&q), None);
Solving,assert_eq!(r2.pop(&q), None);
Solving,assert_eq!(r3.pop(&q), Some(&2));
Solving,assert_eq!(r3.pop(&q), None);
Solving,let mut r = q.reader();
Solving,assert_eq!(r.pop(&q), Some(&1));
Solving,assert_eq!(r.pop(&q), Some(&2));
Solving,assert_eq!(r.pop(&q), None);
Solving,q.save_state();
Solving,q.push(4);
Solving,q.restore_last();
Solving,q.push(5);
Solving,q.save_state();
Solving,q.push(6);
Solving,q.restore_last();
Solving,assert_eq!(r.pop(&q), Some(&5));
Solving,assert_eq!(r.pop(&q), None);
Solving,let mut q = ObsTrail::new();
Solving,q.save_state();
Solving,q.save_state();
Solving,assert_eq!(Some((e.loc.decision_level, e.loc.event_index)), expected_pos);
Solving,assert_eq!(*e.event, n);
Solving,};
Solving,let dl = DecLvl::new;
Solving,let ei = EventIndex::new;
Solving,test_all(99, None);
Solving,test_all(-1, None);
Solving,test_all(1, Some((dl(0), ei(0))));
Solving,test_all(2, Some((dl(0), ei(1))));
Solving,test_all(3, Some((dl(2), ei(5))));
Solving,test_all(4, Some((dl(1), ei(3))));
Solving,test_all(5, Some((dl(2), ei(4))));
Solving,let last_decision_level = q.current_decision_level();
Solving,assert_eq!(Some((e.loc.decision_level, e.loc.event_index)), expected_pos);
Solving,assert_eq!(*e.event, n);
Solving,};
Solving,};
Solving,test_last(99, None);
Solving,test_last(-1, None);
Solving,test_last(1, None);
Solving,test_last(2, None);
Solving,test_last(3, Some((dl(2), ei(5))));
Solving,test_last(4, None);
Solving,test_last(5, Some((dl(2), ei(4))));
Solving,let mut trail = ObsTrail::new();
Solving,debug_assert_eq!(trail.current_decision_level(), DecLvl::ROOT);
Solving,let ia = trail.push("a");
Solving,let ib = trail.push("b");
Solving,trail.save_state();
Solving,let ic = trail.push("c");
Solving,let id = trail.push("d");
Solving,trail.save_state();
Solving,trail.save_state();
Solving,let ie = trail.push("e");
Solving,assert_eq!(trail.decision_level(ia), DecLvl::ROOT);
Solving,assert_eq!(trail.decision_level(ib), DecLvl::ROOT);
Solving,assert_eq!(trail.decision_level(ic), DecLvl::new(1));
Solving,assert_eq!(trail.decision_level(id), DecLvl::new(1));
Solving,assert_eq!(trail.decision_level(ie), DecLvl::new(3));
Solving,mod backtrack_trait;
Solving,mod queues;
Solving,mod trail;
Solving,pub use backtrack_trait::*;
Solving,pub use queues::*;
Solving,pub use trail::Trail;
Solving,use crate::backtrack::{DecLvl, EventIndex};
Solving,self.trail.push(e);
Solving,assert!(self.trail.len() > self.saved_states.last().copied().unwrap_or(0));
Solving,self.saved_states.push(self.trail.len());
Solving,let last = self.trail.pop().expect("No event left");
Solving,let last_index = self.saved_states.pop().expect("No saved state");
