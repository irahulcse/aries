Decomposition,mod numeric;
Decomposition,mod symmetry;
Decomposition,pub mod warm_up;
Decomposition,use crate::encoding::*;
Decomposition,use crate::solver::{init_solver, Metric};
Decomposition,use crate::Model;
Decomposition,use anyhow::{Context, Result};
Decomposition,use aries::core::state::Conflict;
Decomposition,use aries::core::*;
Decomposition,use aries::model::extensions::{AssignmentExt, Shaped};
Decomposition,use aries::model::lang::linear::LinearSum;
Decomposition,use aries::model::lang::mul::EqVarMulLit;
Decomposition,use aries::model::lang::{expr::*, IVar};
Decomposition,use aries::model::lang::{FAtom, FVar, IAtom, Variable};
Decomposition,use aries_planning::chronicles::constraints::encode_constraint;
Decomposition,use aries_planning::chronicles::*;
Decomposition,use env_param::EnvParam;
Decomposition,use numeric::iatom_mul_lit;
Decomposition,use std::cmp::{max, min};
Decomposition,use std::collections::{BTreeMap, HashMap, HashSet};
Decomposition,use std::ptr;
Decomposition,EnvParam::new("ARIES_LCP_RELAXED_TEMPORAL_CONSTRAINT_TASK_METHOD", "false");
Decomposition,let n = num_instances(template).context("Could not determine a number of occurrences for a template")? as usize;
Decomposition,};
Decomposition,let instance_id = pb.chronicles.len();
Decomposition,let instance = instantiate(instance_id, template, origin, Lit::TRUE, Sub::empty(), pb)?;
Decomposition,pb.chronicles.push(instance);
Decomposition,);
Decomposition,let default_label = VarLabel(Container::Base, VarType::Parameter("?".to_string()));
Decomposition,tracing::warn!("Chronicle parameter with no label.");
Decomposition,};
Decomposition,.expect("Presence variable not in parameters");
Decomposition,.new_presence_variable(scope, lbl_of_new(prez_template, &pb.model));
Decomposition,sub.add(prez_template, prez_instance.into())?;
Decomposition,let prez_lit = sub.sub_lit(template.chronicle.presence);
Decomposition,continue;
Decomposition,let label = lbl_of_new(v, &pb.model);
Decomposition,let (lb, ub) = pb.model.int_bounds(i);
Decomposition,let (lb, ub) = pb.model.int_bounds(f.num);
Decomposition,};
Decomposition,sub.add(v, fresh)?;
Decomposition,let mut subtasks = Vec::new();
Decomposition,let task_name = &task.task_name;
Decomposition,};
Decomposition,let refiners_ids = refinements_of_task(&subtask.task_name, pb, spec);
Decomposition,};
Decomposition,subtasks.push(group);
Decomposition,let mut new_subtasks = Vec::new();
Decomposition,let mut local_subtasks: Vec<SubtaskGroup> = Vec::with_capacity(16);
Decomposition,let mut refiners_presence_variables: Vec<Lit> = Vec::with_capacity(16);
Decomposition,let refined: Vec<TaskId> = task_group.tasks.iter().map(TaskId::from).collect();
Decomposition,let template = &spec.templates[template_id];
Decomposition,continue;
Decomposition,};
Decomposition,let mut sub = Sub::empty();
Decomposition,let task = &task_group.tasks[0];
Decomposition,let _ = sub.add_bool_expr_unification(template.chronicle.presence, task.scope);
Decomposition,let _ = sub.add_fixed_expr_unification(template.chronicle.start, task.start);
Decomposition,let _ = sub.add_fixed_expr_unification(template.chronicle.end, task.end);
Decomposition,let template_task_name = template.chronicle.task.as_ref().unwrap();
Decomposition,let _ = sub.add_expr_unification(template_task_name[i], task.task_name[i]);
Decomposition,let instance_id = pb.chronicles.len();
Decomposition,let instance = instantiate(instance_id, template, origin, task_group.shared_scope(), sub, pb)?;
Decomposition,pb.model.state.add_implication(instance.chronicle.presence, !o);
Decomposition,pb.model.state.add_implication(o, !instance.chronicle.presence);
Decomposition,refiners_presence_variables.push(instance.chronicle.presence);
Decomposition,pb.chronicles.push(instance);
Decomposition,let task = &subtask.task_name;
Decomposition,};
Decomposition,let refiners = refinements_of_task(&sub.task_name, pb, spec);
Decomposition,debug_assert!(group.tasks.iter().all(|t| pb.model.state.exclusive(t.scope, sub.scope)));
Decomposition,group.tasks.push(sub);
Decomposition,new_subtasks.extend(local_subtasks);
Decomposition,subtasks = new_subtasks;
Decomposition,let refined_tasks: Vec<_> = refined.iter().map(|tid| get_task_ref(pb, *tid)).collect();
Decomposition,encoding.tag(ch.chronicle.presence, Tag::Decomposition(*task, instance_id));
Decomposition,let clause: Vec<Lit> = refined_tasks.iter().map(|t| t.presence).collect();
Decomposition,model.state.add_implication(ch.chronicle.presence, single);
Decomposition,model.enforce(or(clause), [ch.chronicle.presence]);
Decomposition,};
Decomposition,let refiners = refinements_of(instance_id, task_id, pb);
Decomposition,enforce_refinement(subtask, refiners, model);
Decomposition,let clause: Vec<Lit> = supporters.iter().map(|s| s.presence).collect();
Decomposition,model.enforce(or(clause), [t.presence]);
Decomposition,model.enforce(or([!s1.presence, !s2.presence]), [t.presence]);
Decomposition,model.enforce(f_leq(t.start, s.start), [s.presence, t.presence]);
Decomposition,model.enforce(f_leq(s.end, t.end), [s.presence, t.presence]);
Decomposition,model.enforce(eq(s.start, t.start), [s.presence, t.presence]);
Decomposition,model.enforce(eq(s.end, t.end), [s.presence, t.presence]);
Decomposition,assert_eq!(s.task.len(), t.task.len());
Decomposition,let mut action_presence = Vec::with_capacity(8);
Decomposition,action_presence.push((ch_id, ch.chronicle.presence));
Decomposition,});
Decomposition,let plan_length = model.new_ivar(0, INT_CST_MAX, VarLabel(Container::Base, VarType::Cost));
Decomposition,model.enforce(action_costs.clone().leq(plan_length), []);
Decomposition,model.enforce(action_costs.geq(plan_length), []);
Decomposition,let mut costs = Vec::with_capacity(8);
Decomposition,assert!(cost >= 0, "A chronicle has a negative cost");
Decomposition,costs.push((ch_id, ch.chronicle.presence, cost));
Decomposition,});
Decomposition,let plan_cost = model.new_ivar(0, INT_CST_MAX, VarLabel(Container::Base, VarType::Cost));
Decomposition,model.enforce(action_costs.clone().leq(plan_cost), []);
Decomposition,model.enforce(action_costs.geq(plan_cost), []);
Decomposition,let to_minimize = model.new_ivar(INT_CST_MIN, INT_CST_MAX, VarLabel(Container::Base, VarType::Cost));
Decomposition,let sum = LinearSum::zero() + to_maximize + to_minimize;
Decomposition,model.enforce(sum.clone().leq(0), []);
Decomposition,model.enforce(sum.geq(0), []);
Decomposition,let mut encoding = Encoding::default();
Decomposition,let encode_span = tracing::span!(tracing::Level::DEBUG, "ENCODING");
Decomposition,let _x = encode_span.enter();
Decomposition,let model = pb.model.clone();
Decomposition,let mut solver = init_solver(model);
Decomposition,let effs: Vec<_> = effects(pb).collect();
Decomposition,let assigns: Vec<_> = assignments(pb).collect();
Decomposition,let conds: Vec<_> = conditions(pb).collect();
Decomposition,);
Decomposition,.collect();
Decomposition,tracing::debug!("#chronicles: {}", pb.chronicles.len());
Decomposition,tracing::debug!("#effects: {}", effs.len());
Decomposition,tracing::debug!("#conditions: {}", conds.len());
Decomposition,solver.enforce(f_leq(cond.start, cond.end), [prez_cond]);
Decomposition,solver.propagate()?;
Decomposition,let span = tracing::span!(tracing::Level::TRACE, "structural constraints");
Decomposition,let _span = span.enter();
Decomposition,let prez = ch.chronicle.presence;
Decomposition,solver.enforce(f_leq(ch.chronicle.end, pb.makespan_ub), [prez]);
Decomposition,solver.enforce(f_leq(ch.chronicle.start, ch.chronicle.end), [prez]);
Decomposition,solver.enforce(f_leq(subtask.start, subtask.end), [prez]);
Decomposition,solver.enforce(f_leq(ch.chronicle.start, subtask.start), [prez]);
Decomposition,solver.enforce(f_leq(subtask.end, ch.chronicle.end), [prez]);
Decomposition,add_decomposition_constraints(pb, &mut solver.model, &mut encoding);
Decomposition,solver.propagate()?;
Decomposition,let mut num_removed_chronicles = 0;
Decomposition,let prez = ch.chronicle.presence;
Decomposition,num_removed_chronicles += 1;
Decomposition,tracing::debug!("Chronicles removed by eager propagation: {}", num_removed_chronicles);
Decomposition,solver.enforce(f_leq(eff.transition_start, eff.transition_end), [prez_eff]);
Decomposition,solver.enforce(f_leq(eff.transition_end, pb.horizon), [prez_eff]);
Decomposition,debug_assert!(is_assignment(eff));
Decomposition,let mutex_end = eff_mutex_ends[&eff_id];
Decomposition,solver.enforce(f_leq(eff.transition_end, mutex_end), [prez_eff]);
Decomposition,solver.propagate()?;
Decomposition,let span = tracing::span!(tracing::Level::TRACE, "coherence");
Decomposition,let _span = span.enter();
Decomposition,let mut num_coherence_constraints = 0;
Decomposition,let mut clause: Vec<Lit> = Vec::with_capacity(32);
Decomposition,continue;
Decomposition,continue;
Decomposition,continue;
Decomposition,continue;
Decomposition,clause.clear();
Decomposition,debug_assert_eq!(e1.state_var.fluent, e2.state_var.fluent);
Decomposition,let a = e1.state_var.args[idx];
Decomposition,let b = e2.state_var.args[idx];
Decomposition,clause.push(solver.half_reify(neq(a, b)));
Decomposition,clause.push(solver.half_reify(f_leq(eff_mutex_ends[&j], e1.transition_start)));
Decomposition,clause.push(solver.half_reify(f_leq(eff_mutex_ends[&i], e2.transition_start)));
Decomposition,solver.enforce(or(clause.as_slice()), [p1, p2]);
Decomposition,num_coherence_constraints += 1;
Decomposition,tracing::debug!(%num_coherence_constraints);
Decomposition,solver.propagate()?;
Decomposition,let span = tracing::span!(tracing::Level::TRACE, "support");
Decomposition,let _span = span.enter();
Decomposition,let mut num_support_constraints = 0;
Decomposition,continue;
Decomposition,continue;
Decomposition,let mut supported: Vec<Lit> = Vec::with_capacity(128);
Decomposition,continue;
Decomposition,continue;
Decomposition,continue;
Decomposition,};
Decomposition,continue;
Decomposition,let mut supported_by_eff_conjunction: Vec<Lit> = Vec::with_capacity(32);
Decomposition,supported_by_eff_conjunction.push(prez_eff);
Decomposition,debug_assert_eq!(cond.state_var.fluent, eff.state_var.fluent);
Decomposition,let a = cond.state_var.args[idx];
Decomposition,let b = eff.state_var.args[idx];
Decomposition,supported_by_eff_conjunction.push(solver.half_reify(eq(a, b)));
Decomposition,let condition_value = cond.value;
Decomposition,supported_by_eff_conjunction.push(solver.half_reify(eq(condition_value, effect_value)));
Decomposition,supported_by_eff_conjunction.push(solver.half_reify(f_leq(eff.transition_end, cond.start)));
Decomposition,supported_by_eff_conjunction.push(solver.half_reify(f_leq(cond.end, eff_mutex_ends[&eff_id])));
Decomposition,let support_lit = solver.reify(and(supported_by_eff_conjunction));
Decomposition,encoding.tag(support_lit, Tag::Support(cond_id, eff_id));
Decomposition,.implies(prez_cond, solver.model.presence_literal(support_lit.variable())));
Decomposition,supported.push(support_lit);
Decomposition,num_support_constraints += 1;
Decomposition,solver.enforce(or(supported), [prez_cond]);
Decomposition,tracing::debug!(%num_support_constraints);
Decomposition,solver.propagate()?;
Decomposition,let span = tracing::span!(tracing::Level::TRACE, "mutex");
Decomposition,let _span = span.enter();
Decomposition,let mut num_mutex_constraints = 0;
Decomposition,.collect();
Decomposition,continue;
Decomposition,continue;
Decomposition,continue;
Decomposition,continue;
Decomposition,let mut non_overlapping: Vec<Lit> = Vec::with_capacity(32);
Decomposition,debug_assert_eq!(cond.state_var.fluent, eff.state_var.fluent);
Decomposition,let a = cond.state_var.args[idx];
Decomposition,let b = eff.state_var.args[idx];
Decomposition,non_overlapping.push(solver.half_reify(neq(a, b)));
Decomposition,non_overlapping.push(solver.half_reify(f_lt(cond.end, eff.transition_start)));
Decomposition,non_overlapping.push(solver.half_reify(f_leq(eff.transition_end, cond.start)));
Decomposition,solver.enforce(or(non_overlapping), [act1.chronicle.presence, act2.chronicle.presence]);
Decomposition,num_mutex_constraints += 1;
Decomposition,tracing::debug!(%num_mutex_constraints);
Decomposition,solver.propagate()?;
Decomposition,numeric::add_numeric_constraints(&mut solver, pb, &mut encoding, &eff_mutex_ends)?;
Decomposition,let metric = metric.map(|metric| add_metric(pb, &mut solver.model, metric));
Decomposition,symmetry::add_symmetry_breaking(pb, &mut solver.model, &encoding);
Decomposition,tracing::debug!("Done.");
Decomposition,mod numeric;
Decomposition,mod symmetry;
Decomposition,pub mod warm_up;
Decomposition,use crate::encoding::*;
Decomposition,use crate::solver::{init_solver, Metric};
Decomposition,use crate::Model;
Decomposition,use anyhow::{Context, Result};
Decomposition,use aries::core::state::Conflict;
Decomposition,use aries::core::*;
Decomposition,use aries::model::extensions::{AssignmentExt, Shaped};
Decomposition,use aries::model::lang::linear::LinearSum;
Decomposition,use aries::model::lang::mul::EqVarMulLit;
Decomposition,use aries::model::lang::{expr::*, IVar};
Decomposition,use aries::model::lang::{FAtom, FVar, IAtom, Variable};
Decomposition,use aries_planning::chronicles::constraints::encode_constraint;
Decomposition,use aries_planning::chronicles::*;
Decomposition,use env_param::EnvParam;
Decomposition,use numeric::iatom_mul_lit;
Decomposition,use std::cmp::{max, min};
Decomposition,use std::collections::{BTreeMap, HashMap, HashSet};
Decomposition,use std::ptr;
Decomposition,EnvParam::new("ARIES_LCP_RELAXED_TEMPORAL_CONSTRAINT_TASK_METHOD", "false");
Decomposition,let n = num_instances(template).context("Could not determine a number of occurrences for a template")? as usize;
Decomposition,};
Decomposition,let instance_id = pb.chronicles.len();
Decomposition,let instance = instantiate(instance_id, template, origin, Lit::TRUE, Sub::empty(), pb)?;
Decomposition,pb.chronicles.push(instance);
Decomposition,);
Decomposition,let default_label = VarLabel(Container::Base, VarType::Parameter("?".to_string()));
Decomposition,tracing::warn!("Chronicle parameter with no label.");
Decomposition,};
Decomposition,.expect("Presence variable not in parameters");
Decomposition,.new_presence_variable(scope, lbl_of_new(prez_template, &pb.model));
Decomposition,sub.add(prez_template, prez_instance.into())?;
Decomposition,let prez_lit = sub.sub_lit(template.chronicle.presence);
Decomposition,continue;
Decomposition,let label = lbl_of_new(v, &pb.model);
Decomposition,let (lb, ub) = pb.model.int_bounds(i);
Decomposition,let (lb, ub) = pb.model.int_bounds(f.num);
Decomposition,};
Decomposition,sub.add(v, fresh)?;
Decomposition,let mut subtasks = Vec::new();
Decomposition,let task_name = &task.task_name;
Decomposition,};
Decomposition,let refiners_ids = refinements_of_task(&subtask.task_name, pb, spec);
Decomposition,};
Decomposition,subtasks.push(group);
Decomposition,let mut new_subtasks = Vec::new();
Decomposition,let mut local_subtasks: Vec<SubtaskGroup> = Vec::with_capacity(16);
Decomposition,let mut refiners_presence_variables: Vec<Lit> = Vec::with_capacity(16);
Decomposition,let refined: Vec<TaskId> = task_group.tasks.iter().map(TaskId::from).collect();
Decomposition,let template = &spec.templates[template_id];
Decomposition,continue;
Decomposition,};
Decomposition,let mut sub = Sub::empty();
Decomposition,let task = &task_group.tasks[0];
Decomposition,let _ = sub.add_bool_expr_unification(template.chronicle.presence, task.scope);
Decomposition,let _ = sub.add_fixed_expr_unification(template.chronicle.start, task.start);
Decomposition,let _ = sub.add_fixed_expr_unification(template.chronicle.end, task.end);
Decomposition,let template_task_name = template.chronicle.task.as_ref().unwrap();
Decomposition,let _ = sub.add_expr_unification(template_task_name[i], task.task_name[i]);
Decomposition,let instance_id = pb.chronicles.len();
Decomposition,let instance = instantiate(instance_id, template, origin, task_group.shared_scope(), sub, pb)?;
Decomposition,pb.model.state.add_implication(instance.chronicle.presence, !o);
Decomposition,pb.model.state.add_implication(o, !instance.chronicle.presence);
Decomposition,refiners_presence_variables.push(instance.chronicle.presence);
Decomposition,pb.chronicles.push(instance);
Decomposition,let task = &subtask.task_name;
Decomposition,};
Decomposition,let refiners = refinements_of_task(&sub.task_name, pb, spec);
Decomposition,debug_assert!(group.tasks.iter().all(|t| pb.model.state.exclusive(t.scope, sub.scope)));
Decomposition,group.tasks.push(sub);
Decomposition,new_subtasks.extend(local_subtasks);
Decomposition,subtasks = new_subtasks;
Decomposition,let refined_tasks: Vec<_> = refined.iter().map(|tid| get_task_ref(pb, *tid)).collect();
Decomposition,encoding.tag(ch.chronicle.presence, Tag::Decomposition(*task, instance_id));
Decomposition,let clause: Vec<Lit> = refined_tasks.iter().map(|t| t.presence).collect();
Decomposition,model.state.add_implication(ch.chronicle.presence, single);
Decomposition,model.enforce(or(clause), [ch.chronicle.presence]);
Decomposition,};
Decomposition,let refiners = refinements_of(instance_id, task_id, pb);
Decomposition,enforce_refinement(subtask, refiners, model);
Decomposition,let clause: Vec<Lit> = supporters.iter().map(|s| s.presence).collect();
Decomposition,model.enforce(or(clause), [t.presence]);
Decomposition,model.enforce(or([!s1.presence, !s2.presence]), [t.presence]);
Decomposition,model.enforce(f_leq(t.start, s.start), [s.presence, t.presence]);
Decomposition,model.enforce(f_leq(s.end, t.end), [s.presence, t.presence]);
Decomposition,model.enforce(eq(s.start, t.start), [s.presence, t.presence]);
Decomposition,model.enforce(eq(s.end, t.end), [s.presence, t.presence]);
Decomposition,assert_eq!(s.task.len(), t.task.len());
Decomposition,let mut action_presence = Vec::with_capacity(8);
Decomposition,action_presence.push((ch_id, ch.chronicle.presence));
Decomposition,});
Decomposition,let plan_length = model.new_ivar(0, INT_CST_MAX, VarLabel(Container::Base, VarType::Cost));
Decomposition,model.enforce(action_costs.clone().leq(plan_length), []);
Decomposition,model.enforce(action_costs.geq(plan_length), []);
Decomposition,let mut costs = Vec::with_capacity(8);
Decomposition,assert!(cost >= 0, "A chronicle has a negative cost");
Decomposition,costs.push((ch_id, ch.chronicle.presence, cost));
Decomposition,});
Decomposition,let plan_cost = model.new_ivar(0, INT_CST_MAX, VarLabel(Container::Base, VarType::Cost));
Decomposition,model.enforce(action_costs.clone().leq(plan_cost), []);
Decomposition,model.enforce(action_costs.geq(plan_cost), []);
Decomposition,let to_minimize = model.new_ivar(INT_CST_MIN, INT_CST_MAX, VarLabel(Container::Base, VarType::Cost));
Decomposition,let sum = LinearSum::zero() + to_maximize + to_minimize;
Decomposition,model.enforce(sum.clone().leq(0), []);
Decomposition,model.enforce(sum.geq(0), []);
Decomposition,let mut encoding = Encoding::default();
Decomposition,let encode_span = tracing::span!(tracing::Level::DEBUG, "ENCODING");
Decomposition,let _x = encode_span.enter();
Decomposition,let model = pb.model.clone();
Decomposition,let mut solver = init_solver(model);
Decomposition,let effs: Vec<_> = effects(pb).collect();
Decomposition,let assigns: Vec<_> = assignments(pb).collect();
Decomposition,let conds: Vec<_> = conditions(pb).collect();
Decomposition,);
Decomposition,.collect();
Decomposition,tracing::debug!("#chronicles: {}", pb.chronicles.len());
Decomposition,tracing::debug!("#effects: {}", effs.len());
Decomposition,tracing::debug!("#conditions: {}", conds.len());
Decomposition,solver.enforce(f_leq(cond.start, cond.end), [prez_cond]);
Decomposition,solver.propagate()?;
Decomposition,let span = tracing::span!(tracing::Level::TRACE, "structural constraints");
Decomposition,let _span = span.enter();
Decomposition,let prez = ch.chronicle.presence;
Decomposition,solver.enforce(f_leq(ch.chronicle.end, pb.makespan_ub), [prez]);
Decomposition,solver.enforce(f_leq(ch.chronicle.start, ch.chronicle.end), [prez]);
Decomposition,solver.enforce(f_leq(subtask.start, subtask.end), [prez]);
Decomposition,solver.enforce(f_leq(ch.chronicle.start, subtask.start), [prez]);
Decomposition,solver.enforce(f_leq(subtask.end, ch.chronicle.end), [prez]);
Decomposition,add_decomposition_constraints(pb, &mut solver.model, &mut encoding);
Decomposition,solver.propagate()?;
Decomposition,let mut num_removed_chronicles = 0;
Decomposition,let prez = ch.chronicle.presence;
Decomposition,num_removed_chronicles += 1;
Decomposition,tracing::debug!("Chronicles removed by eager propagation: {}", num_removed_chronicles);
Decomposition,solver.enforce(f_leq(eff.transition_start, eff.transition_end), [prez_eff]);
Decomposition,solver.enforce(f_leq(eff.transition_end, pb.horizon), [prez_eff]);
Decomposition,debug_assert!(is_assignment(eff));
Decomposition,let mutex_end = eff_mutex_ends[&eff_id];
Decomposition,solver.enforce(f_leq(eff.transition_end, mutex_end), [prez_eff]);
Decomposition,solver.propagate()?;
Decomposition,let span = tracing::span!(tracing::Level::TRACE, "coherence");
Decomposition,let _span = span.enter();
Decomposition,let mut num_coherence_constraints = 0;
Decomposition,let mut clause: Vec<Lit> = Vec::with_capacity(32);
Decomposition,continue;
Decomposition,continue;
Decomposition,continue;
Decomposition,continue;
Decomposition,clause.clear();
Decomposition,debug_assert_eq!(e1.state_var.fluent, e2.state_var.fluent);
Decomposition,let a = e1.state_var.args[idx];
Decomposition,let b = e2.state_var.args[idx];
Decomposition,clause.push(solver.half_reify(neq(a, b)));
Decomposition,clause.push(solver.half_reify(f_leq(eff_mutex_ends[&j], e1.transition_start)));
Decomposition,clause.push(solver.half_reify(f_leq(eff_mutex_ends[&i], e2.transition_start)));
Decomposition,solver.enforce(or(clause.as_slice()), [p1, p2]);
Decomposition,num_coherence_constraints += 1;
Decomposition,tracing::debug!(%num_coherence_constraints);
Decomposition,solver.propagate()?;
Decomposition,let span = tracing::span!(tracing::Level::TRACE, "support");
Decomposition,let _span = span.enter();
Decomposition,let mut num_support_constraints = 0;
Decomposition,continue;
Decomposition,continue;
Decomposition,let mut supported: Vec<Lit> = Vec::with_capacity(128);
Decomposition,continue;
Decomposition,continue;
Decomposition,continue;
Decomposition,};
Decomposition,continue;
Decomposition,let mut supported_by_eff_conjunction: Vec<Lit> = Vec::with_capacity(32);
Decomposition,supported_by_eff_conjunction.push(prez_eff);
Decomposition,debug_assert_eq!(cond.state_var.fluent, eff.state_var.fluent);
Decomposition,let a = cond.state_var.args[idx];
Decomposition,let b = eff.state_var.args[idx];
Decomposition,supported_by_eff_conjunction.push(solver.half_reify(eq(a, b)));
Decomposition,let condition_value = cond.value;
Decomposition,supported_by_eff_conjunction.push(solver.half_reify(eq(condition_value, effect_value)));
Decomposition,supported_by_eff_conjunction.push(solver.half_reify(f_leq(eff.transition_end, cond.start)));
Decomposition,supported_by_eff_conjunction.push(solver.half_reify(f_leq(cond.end, eff_mutex_ends[&eff_id])));
Decomposition,let support_lit = solver.reify(and(supported_by_eff_conjunction));
Decomposition,encoding.tag(support_lit, Tag::Support(cond_id, eff_id));
Decomposition,.implies(prez_cond, solver.model.presence_literal(support_lit.variable())));
Decomposition,supported.push(support_lit);
Decomposition,num_support_constraints += 1;
Decomposition,solver.enforce(or(supported), [prez_cond]);
Decomposition,tracing::debug!(%num_support_constraints);
Decomposition,solver.propagate()?;
Decomposition,let span = tracing::span!(tracing::Level::TRACE, "mutex");
Decomposition,let _span = span.enter();
Decomposition,let mut num_mutex_constraints = 0;
Decomposition,.collect();
Decomposition,continue;
Decomposition,continue;
Decomposition,continue;
Decomposition,continue;
Decomposition,let mut non_overlapping: Vec<Lit> = Vec::with_capacity(32);
Decomposition,debug_assert_eq!(cond.state_var.fluent, eff.state_var.fluent);
Decomposition,let a = cond.state_var.args[idx];
Decomposition,let b = eff.state_var.args[idx];
Decomposition,non_overlapping.push(solver.half_reify(neq(a, b)));
Decomposition,non_overlapping.push(solver.half_reify(f_lt(cond.end, eff.transition_start)));
Decomposition,non_overlapping.push(solver.half_reify(f_leq(eff.transition_end, cond.start)));
Decomposition,solver.enforce(or(non_overlapping), [act1.chronicle.presence, act2.chronicle.presence]);
Decomposition,num_mutex_constraints += 1;
Decomposition,tracing::debug!(%num_mutex_constraints);
Decomposition,solver.propagate()?;
Decomposition,numeric::add_numeric_constraints(&mut solver, pb, &mut encoding, &eff_mutex_ends)?;
Decomposition,let metric = metric.map(|metric| add_metric(pb, &mut solver.model, metric));
Decomposition,symmetry::add_symmetry_breaking(pb, &mut solver.model, &encoding);
Decomposition,tracing::debug!("Done.");
